## 🐌 알고리즘 문제 풀이 _ with. Javascript 

### programmers_lv2. 이모티콘 할인행사

#### 📒문제

> 카카오톡에서는 이모티콘을 무제한으로 사용할 수 있는 이모티콘 플러스 서비스 가입자 수를 늘리려고 합니다.
> 이를 위해 카카오톡에서는 이모티콘 할인 행사를 하는데, 목표는 다음과 같습니다.
>
> 1. 이모티콘 플러스 서비스 가입자를 최대한 늘리는 것.
> 2. 이모티콘 판매액을 최대한 늘리는 것.
>
> **1번 목표가 우선이며, 2번 목표가 그 다음입니다.**
>
> 이모티콘 할인 행사는 다음과 같은 방식으로 진행됩니다.
>
> - `n`명의 카카오톡 사용자들에게 이모티콘 `m`개를 할인하여 판매합니다.
> - 이모티콘마다 할인율은 다를 수 있으며, 할인율은 10%, 20%, 30%, 40% 중 하나로 설정됩니다.
>
> 카카오톡 사용자들은 다음과 같은 기준을 따라 이모티콘을 사거나, 이모티콘 플러스 서비스에 가입합니다.
>
> - 각 사용자들은 자신의 기준에 따라 일정 비율 이상 할인하는 이모티콘을 모두 구매합니다.
> - 각 사용자들은 자신의 기준에 따라 이모티콘 구매 비용의 합이 일정 가격 이상이 된다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.
>
> 다음은 2명의 카카오톡 사용자와 2개의 이모티콘이 있을때의 예시입니다.
>
> | 사용자 | 비율 | 가격   |
> | ------ | ---- | ------ |
> | 1      | 40   | 10,000 |
> | 2      | 25   | 10,000 |
>
> | 이모티콘 | 가격  |
> | -------- | ----- |
> | 1        | 7,000 |
> | 2        | 9,000 |
>
> 1번 사용자는 40%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.
> 2번 사용자는 25%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.
>
> 1번 이모티콘의 가격은 7,000원, 2번 이모티콘의 가격은 9,000원입니다.
>
> 만약, 2개의 이모티콘을 모두 40%씩 할인한다면, 1번 사용자와 2번 사용자 모두 1,2번 이모티콘을 구매하게 되고, 결과는 다음과 같습니다.
>
> | 사용자 | 구매한 이모티콘 | 이모티콘 구매 비용 | 이모티콘 플러스 서비스 가입 여부 |
> | ------ | --------------- | ------------------ | -------------------------------- |
> | 1      | 1, 2            | 9,600              | X                                |
> | 2      | 1, 2            | 9,600              | X                                |
>
> 이모티콘 플러스 서비스 가입자는 0명이 늘어나고 이모티콘 판매액은 19,200원이 늘어납니다.
>
> 하지만, 1번 이모티콘을 30% 할인하고 2번 이모티콘을 40% 할인한다면 결과는 다음과 같습니다.
>
> | 사용자 | 구매한 이모티콘 | 이모티콘 구매 비용 | 이모티콘 플러스 서비스 가입 여부 |
> | ------ | --------------- | ------------------ | -------------------------------- |
> | 1      | 2               | 5,400              | X                                |
> | 2      | 1, 2            | 10,300             | O                                |
>
> 2번 사용자는 이모티콘 구매 비용을 10,000원 이상 사용하여 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입하게 됩니다.
> 따라서, 이모티콘 플러스 서비스 가입자는 1명이 늘어나고 이모티콘 판매액은 5,400원이 늘어나게 됩니다.
>
> 카카오톡 사용자 `n`명의 구매 기준을 담은 2차원 정수 배열 `users`, 이모티콘 `m`개의 정가를 담은 1차원 정수 배열 `emoticons`가 주어집니다. 이때, 행사 목적을 최대한으로 달성했을 때의 이모티콘 플러스 서비스 가입 수와 이모티콘 매출액을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.
>
> [<문제 출처>](https://school.programmers.co.kr/learn/courses/30/lessons/150368)



#### :pushpin: 제한 사항

- 1 ≤`users`의 길이 =`n`≤ 100

  - `users`의 원소는 [`비율`, `가격`]의 형태입니다.
  - `users[i]`는 `i+1`번 고객의 구매 기준을 의미합니다.
  - `비율`% 이상의 할인이 있는 이모티콘을 모두 구매한다는 의미입니다.
    - 1 ≤ `비율` ≤ 40
  - `가격`이상의 돈을 이모티콘 구매에 사용한다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입한다는 의미입니다.
    - 100 ≤ `가격` ≤ 1,000,000
    - `가격`은 100의 배수입니다.

- 1 ≤ `emoticons`의 길이 = `m`≤ 7

  - `emoticons[i]`는 `i+1`번 이모티콘의 정가를 의미합니다.
  - 100 ≤ `emoticons`의 원소 ≤ 1,000,000
  - `emoticons`의 원소는 100의 배수입니다.

  

---

> 예시

```
users - emoticons - result
1. [[40, 10000], [25, 10000]] - [7000, 9000] - [1, 5400]
2. [[40, 2900], [23, 10000], [11, 5200], [5, 5900], [40, 3100], [27, 9200], [32, 6900]] - [1300, 1500, 1600, 4900] - [4, 13860]
```

----




#### 🚀point

1. 배열을 다른 배열에 삽입할 때의 얕은 복사 이슈
2. 재귀를 통한 모든 경우의 수 구하기 
   1. dfs로 각 이모티콘에 적용할 수 있는 할인율의 모든 경우 찾기




#### 🔎풀이

1.  각 이모티콘은 10,20,30,40의 할인율을 가질 수 있다
    1.  모든 경우의 수를 구한 뒤 판단해야함

1.  가능한 모든 할인율 조합을 구한다
    1.  하나의 할인율 조합을 저장할 tmp 배열 선언

    1.  할인율 조합의 길이는 이모티콘의 개수와 같다

    1.  dfs를 재귀를통해 구현하여 모든 할인율 조합을 구한다

    1.  재귀를 한번 호출할 때마다 tmp 배열의 다음 칸을 채워야하므로 k에 1을 더해서 호출한다

    1.  만약 k가 이모티콘 길이와 같으면 더 이상 구할 필요가 없으므로 하나의 조합을 최종 배열에 삽입한다
        1.  이때, 그냥 삽입하면 얕은 복사로 인해 다음 반복문에서 값이 바뀜

        1.  따라서, spread operator를 활용하여 복사해야함

1.  모든 할인율을 구한뒤 각각의 할인율 조합일 때의 결과값을 모두 구한다
    1.  사용자 정보를 담은 배열을 순회하면서 다시 이모티콘을 순회해야하므로 이중 반복문을 사용

    1.  만약, 각 이모티콘의 할인율이 사용자가 원하는 할인율보다 높다면 할인율을 적용한 값을 cost(총 비용을 나타내는 변수)에 더한다

    1.  모든 이모티콘을 돈 뒤에 cost 값이 사용자가 생각하는 비용 이상이면 이모티콘 플러스 가입을 해야한다

    1.  result 배열은 첫번째 인덱스에 이모티콘 플러스 가입자 수를, 두번째 인덱스에 총 수익을 나타낸다
        1.  따라서, result[0]에 1을 더해준다

        1.  but, cost 값이 사용자가 생각하는 비용 미만이면 result[1]에 총 비용을 더해준다

    1.  모든 사용자에 대해서 해당 과정을 반복하고, 최종 result 배열을 answer 배열에 담아준다
        1.  이때도, 얕은 복사에 주의

    1.  그리고, 다음 할인율 조합으로 넘어가서 위 과정을 반복한다

1.  최종적으로 answer 배열에는 모든 할인율 조합의 경우에 해당하는 결과값들이 들어있다

1.  answer 배열을 이모티콘 가입자 수 기준으로 정렬하고, 동일하다면 이익 순으로 정렬한다

1.  이후, 가장 많은 이모티콘 가입자 수를 가진 경우, 동일한 값이 있다면 가장 큰 이익을 가진 경우의 정답을 출력한다



#### 💻코드

```javascript
function solution(users, emoticons) {
    let discountRes = []
    const discounts = [10,20,30,40]
    const emoticonLen = emoticons.length
    let tmp = []
    // 가능한 모든 할인율 구성 구하기
    function allDiscount (tmp,k) {
        if (k == emoticonLen) {
            // 얕은 복사로 인해 이전에 들어갔던 값들 다 변경
            discountRes.push([...tmp])
            return
        }

        for (let i=0; i<discounts.length; i++) {
            tmp[k] = discounts[i]
            allDiscount(tmp,k+1)
        }
    }

    allDiscount(tmp,0)
    let answer = []

    for (let discountRate of discountRes) {
      let result = [0,0]
      for (let i=0; i<users.length; i++ ) {
        let userInfo = users[i]
        let cost = 0
        for (let j=0; j<emoticonLen; j++) {
          // 원하는 할인율 보다 이모티콘 할인율이 높다면
          if (userInfo[0]<=discountRate[j]) {
            cost += emoticons[j]*(100-discountRate[j])/100
          }
        }
        if (cost>=userInfo[1]) {
          result[0] += 1
        }
        else {
          result[1] += cost
        }
      }
      answer.push([...result])
    } 
    answer.sort((a,b)=>{
      if (a[0]>b[0]) {
        return -1
      } else if (a[0]<b[0]) {
        return 1
      } else {
        if (a[1]>b[1]) {
          return -1
        } else {
          return 1
        }
      }

    })
    return answer[0];
}
```



#### ❌ 발생 오류 및 해결

- 
