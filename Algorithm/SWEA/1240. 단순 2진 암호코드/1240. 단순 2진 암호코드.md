## 🐌 알고리즘 문제 풀이

### SWEA_1240. 단순 2진 암호코드

#### 📒문제

> 어떤 국가에서는 자국 내 방송국에서 스파이가 활동하는 사실을 알아냈다. 스파이는 영상물에 암호 코드를 삽입하여 송출하고 있었다. 암호 코드는 국가 내 중요 시설을 의미하는 숫자임을 알아냈다. 암호 코드의 규칙은 아래와 같다.
>  
>
> 1. 총 8개의 숫자로 이루어져 있다.  
> 2. 앞 7자리는 상품 고유의 번호를 나타내며, 마지막 자리는 검증 코드를 나타낸다.  
>    - 검증코드는 아래와 같은 방법으로 계산한다.    “(홀수 자리의 합 x 3) + 짝수 자리의 합 + 검증 코드” 가 10의 배수가 되어야 한다.    상품 고유의 번호가 8801234일 경우,    “( ( 8 + 0 + 2 + 4 ) x 3 ) + ( 8 + 1 + 3 ) + 검증 코드”    = “42 + 12 + 검증 코드”    = “54 + 검증 코드” 가 10 의 배수가 되어야 하므로, 검증코드는 6이 되어야 한다.    즉, 88012346 이 정상적인 암호코드고, 그 외의 검증코드가 포함된 경우 비정상적인 암호코드다.
>
> 
>
> A 업체에서는 이 암호코드들을 빠르고 정확하게 인식할 수 있는 스캐너를 개발하려고 한다. 스캐너의 성능은 아래와 같은 방법으로 측정된다.
>  
>
> 1. 세로 50. 가로 100 이하의 크기를 가진 직사각형 배열에 암호코드 정보가 포함되어 전달된다. 이 때, 하나의 배열에는 1개의 암호코드가 존재한다. (단, 모든 암호코드가 정상적인 암호코드임을 보장할 수 없다. 비정상적인 암호코드가 포함될 수 있다.) 
>
> 2. 배열은 1, 0으로 이루어져 있으며 그 안에 포함되어 있는 암호코드 정보를 확인한다.  
> 3. 포함된 암호코드들의 검증코드를 확인하여 정상적인 암호코드인지 확인한다.  
> 4. 정상적인 암호코드들을 판별한 뒤 이 암호코드들에 적혀있는 숫자들의 합을 출력한다.  5. 이때, 총 소요시간이 적을수록 성능이 좋은 것으로 간주된다.
>    
>
> 배열에 포함되어 있는 암호코드의 세부 규칙은 아래와 같다.
>  
>
> 1. 암호코드 하나는 숫자 8개로 구성되며 시작 구분선, 종료 구분선은 별도로 존재하지 않는다.  
>
> 2. 암호코드가 일부만 표시된 경우는 없다. 모든 암호코드는 8개의 숫자로 구성되어 있다.  
> 2. 암호코드의 세로 길이는 5 ~ 50 칸이다.  
> 2. 암호코드의 가로 길이는 총 길이는 56칸이다. 암호코드에 구성하는 숫자 하나가 차지하는 길이는 7칸이다.
>
> [<문제 출처>](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15FZuqAL4CFAYD&categoryId=AV15FZuqAL4CFAYD&categoryType=CODE&problemTitle=1240&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1&&&&&&&&&)



---

> 예시

입력																																																			출력 

16 80
00000000000000000000000000000000000000000000000000000000000000000000000000000000									38
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000011101101100010111011011000101100010001101001001101110110000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000

----




#### 🚀point

1.  모든 input값을 봤을 때, 암호코드가 한줄에 주어지면 나머지 줄에 있는 암호코드도 모두 같다.

1. 무조건 시작과 끝 범위를 정해주어야하는 것 같다.

   


#### 🔎풀이

1. 우선 input값을 모두 받아야하기 때문에 배열을 만든다.

   1. 만들지 않고 풀려고 했으나 다음 test case에서 오류 발생할 확률이 높다고 판단

1. 암호 코드를 먼저 찾고 그 안에서 패턴을 찾을 범위를 구한 뒤 패턴과 맞춰본다.

   1. 주어진 배열 내에서 1이 있는 하나의 배열만 찾는다. (탐색 결과 나머지 배열도 다 똑같기 때문)
   1. 해당 배열 내에서 가장 뒤에 있는 1의 위치를 파악한다. (암호 패턴이 모두 1로 끝나기 때문에 뒤에서 찾는게 더 정확하다고 판단)
   1. 해당 1의 위치를 기준으로 시작과 끝점을 정한다.(암호 코드의 길이는 정해져있기 때문 : 7개씩 8개)
   1. 해당 범위 내에서 패턴을 찾고 검증 코드까지 계산한다.

   


#### 💻코드

```python
# 암호비트패턴
password = {
    "0001101" : 0,
    "0011001" : 1,
    "0010011" : 2,
    "0111101" : 3,
    "0100011" : 4,
    "0110001" : 5,
    "0101111" : 6,
    "0111011" : 7,
    "0110111" : 8,
    "0001011" : 9
}

# 마지막에 정상적인 암호코드인지 확인하기 위한 함수
def check_code(code):
    odd_num = even_num = 0
    for x in range(0,len(code),2) :
        odd_num += code[x] #홀수번째 값들의 합
        even_num += code[x+1] #짝수번째 값들의 합 (마지막 검증코드도 함께 계산)
    if (odd_num*3 + even_num) % 10 : #계산값이 10의 배수가 아니면 비정상적인 코드
        return 0
    else : #계산값이 10의 배수면 정상적인 코드
        return sum(code)

T=int(input())

for tc in range(T):

    N,M=map(int,input().split())

    codes = [input() for _ in range(N)] #주어진 배열

    password_code = "" 
    for code in codes :
        if "1" in code : #배열 중 한줄에 1이 있는 배열이 있다면
            password_code+=code #password_code에 넣어주고
            break #중단 (어차피 다 똑같기 때문에)

    loc_end = 0
    for i in range(M-1,-1,-1) : #1이 어디있는지 찾을 때 뒤에서부터 찾는다(모든 암호패턴이 1로 끝나기 때문에)
        if password_code[i] == "1": 
            loc_end = i #처음으로 1을 찾는 부분이 맨끝
            loc_start = i-55 #총 길이는 56이므로 시작점도 알 수 있음
            break #맨 뒤 1 하나만 찾으면 되므로 break
    real_code = password_code[loc_start:loc_end+1] #지정해준 범위로 새로운 변수에 할당

    result = []
    j=0
    while j <= len(real_code)-7 : #7개씩 끊어서
        if real_code[j:j+7] in password : #암호패턴에 맞는 숫자 찾기
            result.append(password.get(real_code[j:j+7])) #맞는 숫자를 result에 넣어준다
            j+=7
        else :
            j+=1

    print(f'#{tc+1} {check_code(result)}') #함수를 통해 결과값 반환

```



#### ❌ 발생 오류 및 해결

- 배열 내에서 패턴을 찾을 때 앞에서부터 찾았더니, 연속된 패턴이 나오지 않았다. 

  - 해결법 : 이에 뒤에서부터 1을 찾아서 아예 암호 코드에 해당하는 범위를 지정해주었다
  
  

