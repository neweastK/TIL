## 🐌 알고리즘 문제 풀이

### SWEA_1242. 암호코드 스캔

#### 📒문제

> 어떤 국가에서는 자국 내 방송국에서 스파이가 활동하는 사실을 알아냈다.
>
> 스파이는 영상물에 암호 코드를 삽입하여 송출하고 있었다.
>
> 암호 코드는 국가 내 중요 시설을 의미하는 숫자임을 알아냈다. 암호 코드의 규칙은 아래와 같다.
>  
>
> 1. 총 8개의 숫자로 이루어져 있다.  
>
> 2. 앞 7자리는 상품 고유의 번호를 나타내며, 마지막 자리는 검증 코드를 나타낸다.    
>
>    검증코드는 아래와 같은 방법으로 계산한다.    “(홀수 자리의 합 x 3) + 짝수 자리의 합 + 검증 코드” 가 10의 배수가 되어야 한다.    상품 고유의 번호가 8801234일 경우,    “( ( 8 + 0 + 2 + 4 ) x 3 ) + ( 8 + 1 + 3 ) + 검증 코드”    = “42 + 12 + 검증 코드”    = “54 + 검증 코드” 가 10 의 배수가 되어야 하므로, 검증코드는 6이 되어야 한다.    즉, 88012346 이 정상적인 암호코드고, 그 외의 검증코드가 포함된 경우 비정상적인 암호코드다.
>
> 
>
> A 업체에서는 이 암호코드들을 빠르고 정확하게 인식할 수 있는 스캐너를 개발하려고 한다. 스캐너의 성능은 아래와 같은 방법으로 측정된다.
>  
>
> 1. 세로 2000. 가로 500 이하의 크기를 가진 직사각형 배열에 암호코드 정보가 포함되어 전달된다. 이 때, 하나의 배열에는 1개 이상의 암호코드가 존재한다. (단, 모든 암호코드가 정상적인 암호코드임을 보장할 수 없다. 비정상적인 암호코드가 포함될 수 있다.)  
> 1. 배열은 16진수로 이루어져 있으며, 이 배열을 2진수로 변환하여 그 안에 포함되어 있는 암호코드 정보를 확인한다.  
> 1. 포함된 암호코드들의 검증코드를 확인하여 정상적인 암호코드인지 확인한다.  
> 1. 정상적인 암호코드들을 판별한 뒤 이 암호코드들에 적혀있는 숫자들의 합을 출력한다.  
> 1. 이때, 총 소요시간이 적을수록 성능이 좋은 것으로 간주된다.
>
> 
>
> 배열에 포함되어 있는 암호코드의 세부 규칙은 아래와 같다.
>  
>
> 1. 암호코드 하나는 숫자 8개로 구성되며 시작 구분선, 종료 구분선은 별도로 존재하지 않는다.  
> 2. 암호코드들이 붙어있는 경우는 존재하지 않는다. (각 암호코드의 둘레에는 최소 1칸 이상의 빈 공간이 존재한다.)  
> 3. 암호코드가 일부만 표시된 경우는 없다. 모든 암호코드는 8개의 숫자로 구성되어 있다.  
> 4. 암호코드의 세로 길이는 5 ~ 100 칸이다.  
> 5. 암호코드의 가로 길이는 암호코드 선의 두께에 따라 달라지며, 두께가 가장 가는 경우, 숫자 하나가 차지하는 길이는 7칸 이다.
>    암호코드의 가로 길이가 길어질 경우, 숫자 하나가 차지하는 길이는 7의 배수가 된다.
> 6. 암호코드 하나의 최소 가로 길이는 56이며, 암호코드 선이 굵어질 경우, 56의 배수의 길이를 갖게 된다. 예를 들어 암호코드 숫자 하나가 14칸을 사용하는 경우, 암호코드 하나의 가로길이는 112가 된다. 암호코드 하나에 포함되는 암호코드 숫자들은 모두 동일한 크기를 갖는다.
>
> 암호코드 정보가 포함된 2차원 배열을 입력으로 받아 정상적인 암호코드를 판별하는 프로그램을 작성하라.
>
> [<문제 출처>](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15JEKKAM8CFAYD)

---

> 예시

입력																	출력 

16 26																  38

00000000000000000000000000
00000000000000000000000000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
000000001DB176C588D26EC000
00000000000000000000000000
00000000000000000000000000

<hr>




#### 🚀point

1. 단순 2진 암호 코드와의 차이점

   1. 16진수로 이루어져있어 2진수로 바꿔주어야함.
   2. 정상적인 암호 코드가 여러개가 있을 수 있음
      1. 그 정상적인 암호 코드들의 합을 모두 구해주어야함
   
   3. 코드의 길이가 7로 고정되어있지 않기에 비율을 따져보아야한다.
   
   
   
   


#### 🔎풀이

1. 우선 내부의 16진수 코드를 모두 이진수로 변환한다.
1. 패턴과 직접 비교해보지 않고 비율로써 비교한다.
   1. 패턴은 0,1,0,1 순으로 있다는 것을 활용한다.
   

3. 모든 정상적인 코드의 합을 구한다.




#### 💻코드

```python
import sys
sys.stdin = open("input.txt")


def check_code(code):
    odd_num = even_num = 0
    for x in range(0,len(code),2) :
        odd_num += code[x] #홀수번째 값들의 합
        even_num += code[x+1] #짝수번째 값들의 합 (마지막 검증코드도 함께 계산)
    if (odd_num*3 + even_num) % 10 : #계산값이 10의 배수가 아니면 비정상적인 코드
        return 0
    else : #계산값이 10의 배수면 정상적인 코드
        return sum(code)

# 16진수를 2진수로 바꾸기 위한 수
hex_rule = {"A":10,"B":11,"C":12,"D":13,"E":14,"F":15}

# 비율을 계산하기 위한 암호 코드
password = {
    "211": 0, "221": 1, "122": 2, "411": 3,
    "132": 4, "231": 5, "114": 6, "312": 7,
    "213": 8, "112": 9
}


T = int(input())

for tc in range(T) :
    N,E = map(int,input().split())
    arrs = [input().strip() for _ in range(N)] #strip을 안했더니 입력 받을 때 오류남
    codes = []
    for arr in arrs :
        try : # 만약 배열 내에 숫자가 아닌 다른 것이 있다면 오류가 날 것
            if sum(map(int,arr)) and arr not in codes: 
           #숫자만 있는데, 0만 있는 경우가 아니라면 코드에 그 배열을 추가 그리고 중복이 없도록 체크
                codes.append(arr)
        except ValueError : # 그 뜻은 16진수의 문자가 있다는 뜻이므로 코드에 추가
            if arr not in codes : #중복이 없도록 체크
                codes.append(arr)
	# 즉, codes는 주어진 배열 중에서 16진수 문자열 즉, 암호코드가 있는 배열들의 모임
    
    
    search_target = []
    # 암호코드가 있는 배열들을 16진수로 바꿔주고 다시 2진수로 바꾸기
    for code in codes :
        res=[]
        nums = [int(c) if c not in hex_rule else hex_rule.get(c) for c in code]
        for j in range(len(nums)):
            bin_tmp = [0] * 4
            num = nums[j]
            k = 3
            while num > 0:
                bin_tmp[k] = num % 2
                num = num // 2
                k -= 1
            res += bin_tmp
        search_target.append("".join(map(str,res)).rstrip("0"))
        # search_target은 2진수로 바뀌어있는 암호 코드의 집합

	
    verify=[]
    answer = 0
    # 2진수로 바뀌어있는 코드 하나씩 검증
    for target in search_target : #target은 한줄짜리 배열
        result_code = []
        count_target = [0,0,0] # 비율을 계산하기 위한 리스트 [두번째1, 첫번째0, 첫번째1]
        for t in range(len(target)-1,-1,-1) :
   			# 값이 1이고 뒤에서 두번째 리스트가 0이라는 뜻은 가장 첫번째 1이라는 뜻
            if target[t] == "1" and count_target[-2] == 0  :
                count_target[-1] += 1 # 때문에 count_target의 마지막에 1추가
            # 값이 0이고 이미 맨 첫 1을 셈했다면 그리고 다음 1은 아직 세지 않았다면 첫 0
            elif target[t] == "0" and count_target[-3] == 0 and count_target[-1]>0 :
                count_target[-2] += 1 # 때문에 count_target 첫번째 0에 1추가
            elif target[t] == "1" and count_target[-1] != 0 : #두번째 1인 경우
                count_target[-3] += 1
            elif target[t] == "0" and count_target[0] != 0 : 
                # 첫0이 아니라면 이제 비율을 계산해야함
                if target[t-1] == "1" :
                    base = min(count_target) 
                    # 가장 작은 값으로 나누면 비율이 나옴
                    new_count = "".join(map(str,[tar//base for tar in count_target]))
                    # 비율을 적어놓은 password 딕셔너리를 활용하여 코드 값 추출
                    result_code.append(password.get(new_count))
                    count_target = [0, 0, 0] # 다시 초기화
			# 암호코드는 8자리이므로 8자리일 때 끊어주기
            if len(result_code) == 8 :
                result_codes = result_code[::-1] #뒤에서부터 뽑았으므로 역순으로 정렬
                # 이미 검증했던 코드가 아니라면
                if result_codes not in verify :
                    # 검증코드 확인
                    check_result = check_code(result_codes)
                    # 만약 결과가 0이 아니라면
                    if check_result :
                        answer += check_result #그 값을 answer에 더해준다
                        verify.append(result_codes) #중복 방지를 위해 추가
                result_code=[] #이미 검증했으므로 초기화

    print(f"#{tc+1} {answer}")
```



#### ❌ 발생 오류 및 해결

- 초반에 비율을 계산할 때 더 정확하게 하고싶어서 0까지 넣으려헀으나, 맨 앞에 0이 매우 많은 경우 오류 발생
- 암호코드의 중복 방지 코드를 짜지 않아서 입력값이 커질수록 값이 엄청나게 커짐
- 8자리로 끊었어야했는데 끊지 않아서 값이 역시나 크게 나옴

