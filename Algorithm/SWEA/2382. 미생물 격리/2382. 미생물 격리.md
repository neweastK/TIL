## 🐌 알고리즘 문제 풀이

### SWEA_2382. 미생물 격리

#### 📒문제

> 정사각형 구역 안에 K개의 미생물 군집이 있다.
>
> 이 구역은 가로 N개, 세로 N개, 총 N * N 개의 동일한 크기의 정사각형 셀들로 이루어져 있다.
>
> 미생물들이 구역을 벗어나는걸 방지하기 위해, 가장 바깥쪽 가장자리 부분에 위치한 셀들에는 특수한 약품이 칠해져 있다.
>
> ① 최초 각 미생물 군집의 위치와 군집 내 미생물의 수, 이동 방향이 주어진다. 약품이 칠해진 부분에는 미생물이 배치되어 있지 않다. 이동방향은 상, 하, 좌, 우 네 방향 중 하나이다.
>
> ② 각 군집들은 1시간마다 이동방향에 있는 다음 셀로 이동한다.
>
> ③ 미생물 군집이 이동 후 약품이 칠해진 셀에 도착하면 군집 내 미생물의 절반이 죽고, 이동방향이 반대로 바뀐다. 
>     미생물 수가 홀수인 경우 반으로 나누어 떨어지지 않으므로, 다음과 같이 정의한다.
>     **살아남은 미생물 수 = 원래 미생물 수를 2로 나눈 후 소수점 이하를 버림 한 값**
>     따라서 군집에 미생물이 한 마리 있는 경우 살아남은 미생물 수가 0이 되기 때문에, 군집이 사라지게 된다,
>
>  ④ 이동 후 두 개 이상의 군집이 한 셀에 모이는 경우 군집들이 합쳐지게 된다. 
>     합쳐 진 군집의 미생물 수는 군집들의 미생물 수의 합이며, 이동 방향은 군집들 중 미생물 수가 가장 많은 군집의 이동방향이 된다. 
>     **합쳐지는 군집의 미생물 수가 같은 경우는 주어지지 않으므로 고려하지 않아도 된다.**
>
> M 시간 동안 이 미생물 군집들을 격리하였다. M시간 후 남아 있는 미생물 수의 총합을 구하여라.
>
> [<문제 출처>](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV597vbqAH0DFAVl)



---

> 예시

입력					출력 

7 2 9  				145

1 1 7 1 
2 1 7 1
5 1 5 4
3 2 8 4 
4 3 14 1
3 4 3 3 
1 5 8 2 
3 5 100 1
5 5 1 1

----




#### 🚀point

1. 군집의 이동방향은 상하좌우 4방향 중 한 방향을 가진다. (상: 1, 하: 2, 좌: 3, 우: 4)

1. 주어진 입력으로 진행하였을 때, **동일한 셀에 같은 미생물 수를 갖는 두 군집이 모이는 경우는 발생하지 않는다.**

1. 최초에 둘 이상의 군집이 동일한 셀에 배치되는 경우는 없다.

   


#### 🔎풀이

1. 두가지 고민

   1. 배열에 표시를 하면서 문제를 풀이할 것인가?
1. input 받는 리스트를 고쳐가면서 문제를 풀이할 것인가?
   
   2번의 경우, 군집이 만날 때 리스트를 하나로 합쳐야하므로 작업에 어려움이 있을 것으로 예상됨
   

따라서, 1번의 방법으로 진행

2. 기존 군집의 위치가 arr 라면 한번 이동한 후의 새로운 배열 new_arr를 만들어 따로 저장한다.
   그리고 다음 반복을 돌 때, new_arr를 arr로 재설정하여 반복 진행한다.
3. 배열의 각 부분에는 미생물의 수와 방향을 나타내는 길이 2의 리스트를 삽입한다




#### 💻코드

```python
import sys
sys.stdin = open("input.txt")
from pprint import pprint


T = int(input())
for tc in range(T) :
    N, M, K = map(int,input().split())  # N=구역, M=시간, K=군집 개수
    
    # 군집의 최초 위치를 나타내는 배열 생성
    arr = [[0]*N for _ in range(N)]
    groups = [list(map(int,input().split())) for _ in range(K)]
    for group in groups:
        arr[group[0]][group[1]] = [group[2], group[3]]
	
    # 맨 끝에 부딪힐 경우 1은 2로, 2는 1로, 3은 4로, 4는 3으로 바꿔주도록 딕셔너리 생성
    cd = {1:2, 2:1, 3:4, 4:3}
    # 상하좌우가 1,2,3,4 순서이므로 인덱스 0 부분을 0으로 채워준다
    dx = [0,-1,1,0,0] 
    dy = [0,0,0,-1,1]
	

    for _ in range(M):
        new_arr = [[0] * N for _ in range(N)]
        tmp_arr = [[0]*N for _ in range(N)]
        for i in range(N) :
            for j in range(N) :
                val = arr[i][j]
                if val :
                    nx = i + dx[val[1]]
                    ny = j + dy[val[1]]
                    
                    # 약품 부분에 해당하는 경우
                    if nx==0 or nx==N-1 or ny==0 or ny==N-1 :
                        new_arr[nx][ny] = [val[0]//2, cd.get(val[1])]
                        
                    # 군집이 이동한 곳에 아무것도 없는 경우
                    elif new_arr[nx][ny] == 0  :
                        new_arr[nx][ny] = [val[0],val[1]]
                    
                    # 군집이 이동했는데 다른 군집이 그 자리에 있는 경우
                    else :
                        # 더 큰 군집을 그 자리에 두고 따로 tmp_arr을 만들어 거기에 군집 합을 저장해놓는다.
                        if new_arr[nx][ny][0] > val[0] :
                            tmp_arr[nx][ny] += val[0]
                        # 원래 있던 군집이 더 작은 경우 tmp_arr에 더해주고 새로운 값으로 바꿔준다
                        # 그렇게 되면 가장 큰 값의 방향이 남게됨
                        else :
                            tmp_arr[nx][ny] += new_arr[nx][ny][0]
                            new_arr[nx][ny] = [val[0],val[1]]

     	# 여러 군집이 한 곳에 있었던 경우를 찾아 new_arr에 그 값을 더해준다.
        for tmp_i in range(N) :
            for tmp_j in range(N) :
                if tmp_arr[tmp_i][tmp_j] :
                    new_arr[tmp_i][tmp_j][0] += tmp_arr[tmp_i][tmp_j]
        # 한번 변경된 결과인 new_arr를 다시 arr에 할당해줌으로써 반복이 가능하도록 한다.
        arr = [new[:] for new in new_arr]

    res = 0
    for ni in range(N) :
        for nj in range(N) :
            if new_arr[ni][nj] :
                res += new_arr[ni][nj][0]

    print(f'#{tc+1} {res}')
```



#### ❌ 발생 오류 및 해결

- 테스트 케이스 50개중 43개 정답 - 한곳에 여러개가 오는 경우

  - 기존 방법은 두개의 군집을 비교하여 큰 군집의 방향을 남겨두고 미생물 수를 더했다.

  - 그랬더니, 세번째 오는 군집과의 비교에서 오류가 발생했다. 

    ex) 군집1 : 40,위 / 군집2: 30, 아래 / 군집3 : 50, 좌 

    본래는 군집3의 방향으로 고정되야하는데, 군집1과 군집2를 더해버리면 70이 되어서 군집3이 더 작다고 판단해버린다. 그로 인해 좌로 가야하는 방향이 위로 가게되므로 오류가 발생한다.

  - 해결법 : tmp_arr를 새로 만들어서 해당 부분에서 미생물 수를 합하고 new_arr에서는 큰 값만 남겨놓는다. 이후, 작업이 끝나면 tmp_arr의 값을 new_arr를 더해준다.

  
