## 🐌 알고리즘 문제 풀이

### Baekjoon_13913. 숨바꼭질 4

#### 📒문제

> 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
>
> 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/13913)



#### :pushpin: 입력 및 출력

- 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

- 첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

  둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.



---

> 예시

```
input :
5 17
output :
4
5 10 9 18 17

input :
5 17
output :
5 4 8 16 17
```

----




#### 🚀point

1. 수빈이가 동생의 위치까지 가는 방법과 그때의 시간을 구해야함
   1. 다익스트라로 최단 시간을 구하고, 시간이 갱신될 때마다 이전 경로를 저장





#### 🔎풀이

1.  다익스트라 함수를 선언한다
    1.  각 위치로 오기 전 위치는 어디인지 기록할 visited 배열 선언
    1.  start 위치에서 각 위치까지 최단 도달 시간을 기록할 distance 배열 선언
    1.  queue에는 초기값을 넣어준다 (거리=0, 수빈이의 위치)
    1.  distance[수빈이위치]를 0으로 초기화
    1.  queue가 빈 배열이 될 때까지 아래 작업 반복
        1.  queue에서 pop해서 지금위치와 그 위치까지의 최단 도달시간을 받는다
        1.  현재 위치에서 갈 수 있는 새로운 위치들을 배열로 만든다(+1,-1,*2)
        1.  각 위치를 순회하면서 새로운 위치가 범위에 속하는지 확인한다
        1.  그 다음, 이미 기록된 해당 위치의 최단 도달시간과 지금 새로 받은 도달시간을 비교한다
            1.  만약, 이미 기록된 시간이 더 짧다면 이후 과정 필요없이 continue
            1.  5-4-1에 해당하지 않으면, 방문배열, 최단도달시간 배열을 갱신해준다
            1.  이 때, 갱신할 새로운 도달시간은 이전 위치까지의 도달시간+1이다
            1.  마지막으로 queue에 넣어준다

1.  입력값을 모두 받는다
1.  입력값을 기준으로 배열의 최대 길이를 정해준다
    1.  동생의 위치나 수빈이의 위치 중 큰 값+2 가 기준이 된다
    1.  특정 위치를 넘어갔다가 뒤로 올 수도 있으므로

1.  다익스트라 함수를 실행시켜서 visited 배열과 distance 배열을 반환받는다
1.  distance[동생위치]로 최단 도달시간을 출력한다
1.  vistied 배열을 순회하면서 동생 위치를 시작으로 수빈이 위치까지의 경로를 탐색한다
    1.  탐색한 경로를 역순으로 출력한다





#### 💻코드

```python
#어떻게 이동해야하는지 기록해야한다
#다익스트라 활용하기
import heapq
import sys
input = sys.stdin.readline

def dijkstra(start):
    INF = int(1e9)
    # visited[i]는 i위치에 오기 전에 어디에서 온건지 기록
    visited = [0]*length
    # distance[i]는 수빈이 위치에서 i까지 가는데 걸리는 최단 시간 기록
    distance = [INF]*length
    # queue에는 초기값 (거리=0, 수빈이의 위치값) 넣어주기
    queue = [(0,start)]
    # 수빈이 위치에서 수빈이 위치까지 걸리는 최단시간은 0
    distance[start] = 0

    while queue:
        # 현재위치까지최단도달시간, 현재위치
        dist,now = heapq.heappop(queue)
        
        # 현재 위치에서 이동할 수 있는 모든 경우의 수
        # 시간은 모두 동일하므로 위치만 배열로 생성
        delta = [now+1,now-1,now*2]
		
        # 위 배열을 순회하면서 각 위치의 최단시간 탐색
        for d in delta:
            # 그 전에, 위치가 배열 범위에 있는지 확인
            if 0<=d<=length-1:
                # 만약, 이미 그 위치까지의 도달시간이, 새로 갱신될 시간보다 작다면
                # continue
                if distance[d] <= dist+1:
                    continue
                # 위 조건이 아니라면, 최단시간 갱신
                # 거리는 지금 위치(now)까지 오는데 걸리는 시간+1
                distance[d] = dist+1
                # 방문배열에는 그 위치로 오기 전에 어디서 왔는지 기록
                # 어디서 왔는지는 now를 통해 알 수 있음(왜냐하면 now+1,now-1,now*2 배열을 탐색했으므로)
                visited[d] = now
                # queue에 넣어주기
                heapq.heappush(queue,(dist+1,d))

    return distance,visited

# 입력값을 받는다
N,K = map(int,input().split())

# 동생의 위치보다 앞으로 갔다가 돌아오는 경우도 있으므로 
# 동생의 위치+1만큼 배열의 길이를 설정한다
length = N+2 if N>K else K+2

# 현재 수빈이의 위치에서 각 위치로 이동할 수 있는 최단 거리 배열과
# 최단거리로 이동할 때, 각 위치 이전 위치는 어디인지 기록한 방문 배열 반환
distance_arr,visited_arr = dijkstra(N)

# res에는 동생 위치로 오기까지의 경로를 저장한다
res = [K]
# 동생을 만나기까지 최단 시간 출력
print(distance_arr[K])

# 동생의 위치를 시작으로 수빈이 위치까지 어떤 경로로 갔는지 탐색
while True:
    if K == N:
        break
    K = visited_arr[K]
    res.append(K)
# 해당 경로를 수빈이의 위치부터 출력
print(*res[::-1])
```



#### ❌ 발생 오류 및 해결

- 

  
