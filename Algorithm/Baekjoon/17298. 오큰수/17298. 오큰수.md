## 🐌 알고리즘 문제 풀이

### Baekjoon_17298. 오큰수

#### 📒문제

> 크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.
>
> 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.
> 
>    [<문제 출처>](https://www.acmicpc.net/problem/17298)



#### :pushpin: 입력 및 출력

- 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

- 총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다

---

> 예시

```
input :
4
3 5 2 7

output :
5 7 7 -1

input :
4
9 5 4 8

output :
-1 8 8 -1
```

----




#### 🚀point

1. 



#### 🔎풀이

1.  NEG(i)는 A(i)와 오른쪽으로 가장 가까운 A(i)보다 큰 수
1.  따라서, 가장 오른쪽 수부터 NEG를 구하면 됨
    1.  가장 오른쪽 수의 NEG는 더 이상 오른쪽에 수가 없으므로 -1
    1.  다음 숫자부터 아래의 과정을 반복
        1.  자신의 오른쪽 수와 비교한다.
        1.  만약, 오른쪽 수가 더 크다면 NEG는 바로 오른쪽 수
        1.  더 작다면, 가장 오른쪽부터 끝까지 해당 수의 NEG를 비교한다.
        1.  더 큰 NEG를 만나면 해당 NEG가 지금 숫자의 NEG가 된다.
        1.  끝까지 가도 없다면 NEG는 없으므로 -1
        1.  혹은, NEG가 -1인 수를 만나면 지금부터 아무리 오른쪽으로 가도 더 큰 숫자는 없다는 뜻이므로 NEG는 -1


#### 💻코드

```python
import sys
input = sys.stdin.readline

N = int(input())
arr = list(map(int,input().split()))
# 오큰수를 담을 배열
ans = [-1]*N
# 오른쪽 숫자부터 시작하기
for i in range(N-2,-1,-1):
    # 만약 바로 오른쪽의 수가 더 크면 해당 숫자가 가장 가까우므로 오큰수가 됨
    if arr[i] < arr[i+1] :
        ans[i] = arr[i+1]
    # 작다면?
    else :
        # 바로 오른쪽의 숫자부터 끝까지 오큰수 비교
        for j in range(i+1,N):
            # 만약 오큰수가 -1이면 오큰수는 -1
            if ans[j] == -1 :
                ans[i] = -1
                break
            # 본인보다 더 큰 오큰수를 만나면
            elif arr[i] < ans[j] :
                # 본인의 오큰수는 그 오큰수가 됨
                ans[i] = ans[j]
                break
        # 끝까지 가도 없다면, 오큰수는 -1 
    	else:
            ans[i] = -1

print(*ans)
```



#### ❌ 발생 오류 및 해결

- 오큰수가 -1일 때 break문을 넣어주지 않아서 시간 초과 발생
  - -1이면 더 이상 보지 않아도 되기 때문
