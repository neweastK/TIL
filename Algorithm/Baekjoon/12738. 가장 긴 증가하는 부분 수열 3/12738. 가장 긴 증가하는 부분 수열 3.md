## 🐌 알고리즘 문제 풀이

### Baekjoon_12738. 가장 긴 증가하는 부분 수열 3

#### 📒문제

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/12738)



#### :pushpin: 입력 및 출력

- 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)

- 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.


---

> 예시

```
input :
6
10 20 10 30 20 50

output :
4
```

----




#### 🚀point

1. 이분탐색으로 LIS 문제 풀이
2. bisect_left를 활용해서 현재 배열의 값이 임시 배열의 몇번째로 들어갈지 구한다



#### 🔎풀이

1.  입력값을 모두 받는다
    
1.  가장 긴 증가하는 부분 수열의 길이를 나타낼 tmp 배열 생성
    1.  첫번째 값 넣어주기
    
1.  배열을 순회하면서 tmp 배열의 마지막 값보다 현재 배열 값이 큰지 확인
    1.  크다면 바로 append 하면 되기 때문
    
1.  작다면, tmp 배열에서 몇번째에 위치할 수 있는지 확인
    1.  해당 값으로 갱신해준다
    
1.  최종적으로 tmp 배열의 길이 출력
    



#### 💻코드

```python
import bisect

N = int(input())
arr = list(map(int,input().split()))

tmp = [arr[0]]
for i in range(1,N):
    if tmp[-1] < arr[i]:
        tmp.append(arr[i])
    else:
        tmp_loc = bisect.bisect_left(tmp,arr[i])
        tmp[tmp_loc] = arr[i]
print(len(tmp))
```



#### ❌ 발생 오류 및 해결

- bisect 라이브러리를 안쓰고 직접 구현해본 결과
  - 정답처리는 되지만 시간이 너무 오래걸림
  - start와 end 값을 갱신해주는 과정에서 뭔가 잘못된 것 같은데 아직 잘 모르겠음
