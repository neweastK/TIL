## 🐌 알고리즘 문제 풀이

### Baekjoon_4948. 베르트랑 공준

#### 📒문제

> 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.
>
> 이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.
>
> 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)
>
> 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. 
>
> [<문제 출처>](https://www.acmicpc.net/problem/4948)

#### :pushpin: 입력 및 출력

- 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.

  입력의 마지막에는 0이 주어진다.

- 각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.

---

> 예시

입력						 출력 

1							  1
10							4
13							3
100						 21
1000					  135
10000					1033
100000				  8392
0

----




#### 🚀point

1. n부터 2n까지의 소수이므로 범위를 1부터 n으로 지정하는 실수 주의!

1. 시간초과 발생하지 않는 것이 이 문제의 포인트인 것 같다.

   


#### 🔎풀이

1. 소수인지 판별하는 함수를 작성한다.
1. ~~n을 입력받고 n부터 2n까지 숫자 중 소수가 몇개인지 세고 출력한다.~~
   1. 시간 초과로 인해 오류 발생
   1. 따라서, 소수를 매번 구하지 않고 전체 범위 내에 속하는 소수를 한번에 구한다.
   1. 그 후, n에서 2n의 범위 내에 소수가 몇개 있는지 세는 방향으로 문제를 풀이한다.




#### 💻코드

```python
import sys

# 소수 판별 함수
def checking(number):
    # 반복을 줄이기 위해 루트값까지만 확인
    # (약수는 짝으로 이루어져있기 때문에 루트값 이전까지 약수가 없다면 그 이후로도 없음)
    for i in range(1,int(number**0.5)+1):
        if i == 1:
            continue
        if number % i == 0:
            return False
    else:
        return True

# 시간 초과를 막기 위해 입력값을 한번에 받는다
numbers = []
while True :
    N = int(sys.stdin.readline())
    # 입력값이 0이면 중단
    if N == 0 :
        break
    else :
        numbers.append(N)

# 소수를 담을 리스트
primes = []
# 입력값 중 가장 작은 값부터 가장 큰값의 2배까지를 범위로 지정하여 소수를 구한다
maximum_number = max(numbers)
minimum_number = min(numbers)
for number in range(minimum_number,2*maximum_number+1):
    if checking(number) and number!=1:
        primes.append(number)

# 입력값을 돌면서 해당 입력값부터 입력값의 두배까지 범위에 속하는 소수가 몇개인지 센다
for num in numbers :
    cnt = 0
    for i in range(len(primes)):
        if num<primes[i]<=2*num :
            cnt+=1
    print(cnt)
```



#### ❌ 발생 오류 및 해결

- 시간 초과 오류 발생
  - 입력값을 받을 때마다 소수를 새로 구하다보니 시간초과가 난 것 같다.
  - 입력값을 한번에 받고 전체의 소수를 구한 뒤 해당 리스트 내에서 찾도록 코드 수정
  - 시간 초과 오류가 없어도 위 문제 같은 경우는 효율적인 방법을 생각했어야되지 않나 싶다.
    - 왜냐하면, 같은 소수를 몇번이나 똑같이 구하는 로직이었기 때문
    - 반복을 줄이기 위한 노력을 하자.
