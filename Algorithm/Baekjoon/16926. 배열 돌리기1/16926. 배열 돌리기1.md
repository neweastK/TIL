## 🐌 알고리즘 문제 풀이

### Baekjoon_16926. 배열 돌리기1

#### 📒문제

> 크기가 N×M인 배열이 있을 때, 배열을 돌려보려고 한다. 배열은 다음과 같이 반시계 방향으로 돌려야 한다.
>
> ```
> A[1][1] ← A[1][2] ← A[1][3] ← A[1][4] ← A[1][5]
>    ↓                                       ↑
> A[2][1]   A[2][2] ← A[2][3] ← A[2][4]   A[2][5]
>    ↓         ↓                   ↑         ↑
> A[3][1]   A[3][2] → A[3][3] → A[3][4]   A[3][5]
>    ↓                                       ↑
> A[4][1] → A[4][2] → A[4][3] → A[4][4] → A[4][5]
> ```
>
> 예를 들어, 아래와 같은 배열을 2번 회전시키면 다음과 같이 변하게 된다.
>
> ```
> 1 2 3 4       2 3 4 8       3 4 8 6
> 5 6 7 8       1 7 7 6       2 7 8 2
> 9 8 7 6   →   5 6 8 2   →   1 7 6 3
> 5 4 3 2       9 5 4 3       5 9 5 4
>  <시작>         <회전1>        <회전2>
> ```
>
> 배열과 정수 R이 주어졌을 때, 배열을 R번 회전시킨 결과를 구해보자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/16926)



#### :pushpin: 입력 및 출력

- 첫째 줄에 배열의 크기 N, M과 수행해야 하는 회전의 수 R이 주어진다.

  둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.
  
- 입력으로 주어진 배열을 R번 회전시킨 결과를 출력한다.


---

> 예시

```
input :
4 4 2
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

output :
3 4 8 12
2 11 10 16
1 7 6 15
5 9 13 14

input :
5 4 7
1 2 3 4
7 8 9 10
13 14 15 16
19 20 21 22
25 26 27 28

output :
28 27 26 25
22 9 15 19
16 8 21 13
10 14 20 7
4 3 2 1
```

----


#### 🚀point

1. 각 조건을 올바르게 설정해야함
   1. 한쪽 방향으로의 이동을 멈출 조건
   1. 전체 회전을 멈출 조건





#### 🔎풀이

1. 먼저 4방향 탐색을 위한 델타 배열을 생성한다.
   
1. 특정 값을 하나의 배열 안에서 이동시키면 나중에 값이 중복되어버리므로 이동 결과를 나타낼 새로운 배열을 생성한다.
   
1. 한쪽 방향으로 몇번 이동할건지 셀 카운트 변수를 생성한다.
   
1. 한 그룹의 회전이 끝나고 그 안의 그룹을 회전시킬 때, 시작점 갱신을 위한 변수 r을 생성한다.
   
1. N,M은 R번만큼 회전시킬 때마다 기준점이 되어야하므로 다른 변수에 할당해서 사용한다.
   
1. N과 M 중 하나라도 0이하가 되면 더 이상 회전시킬 수 없으므로 해당 조건을 while 문에 삽입한다.
   
1. 4방향 모두 돌면 한 그룹의 회전은 끝이므로 d<4 조건을 설정한다.
   
1. 새로 이동할 때마다 c변수에 1을 증가시키고 c 변수가 N 혹은 M 조건에 맞을 경우 이동방향을 변경한다.
   
1. 시작점을 변경해주고 안쪽 그룹에서 또 다시 회전을 시킨다.
   1. 이 때, c,d,On,Om 등 모든 변수를 초기화 시켜준다.
   1. 그리고 새롭게 이동된 배열을 maps에 복사하여서 새로운 new_maps를 만들 수 있게 한다.
   
1. R번만큼 회전을 반복한다.
   

#### 💻코드

```python
import sys
input = sys.stdin.readline

N,M,R = map(int,input().split())
maps = [list(map(int,input().split())) for _ in range(N)]

# 아래 -> 오른쪽 -> 위 -> 왼쪽
dx = [1,0,-1,0]
dy = [0,1,0,-1]
d = 0

# R번만큼 회전 시켜야하므로 R번만큼 반복
for _ in range(R):
    # 새로운 위치를 저장할 배열 생성
    new_maps = [[0]*M for _ in range(N)]
    
    # 한쪽 방향으로 몇번 이동할건지 확인할 변수 c
    c = 0
    
    # 시작점을 나타내줄 변수 r
    r = 0
    x,y = (r,r)
    
    # N,M은 변하면 안되므로 On, Om에 할당해서 새로운 변수 생성
    On = N
    Om = M
    
    # 한번 회전하는 과정
    while On>0 and Om>0:
        # 4방향 이동하면 이동 끝!
        while d<4 :
            # 원래의 위치를
            tmp = maps[x][y]
            # 새로 이동한 위치로
            x = x+dx[d]
            y = y+dy[d]
            # 지정
            new_maps[x][y] = tmp
            # 이동횟수 증가
            c+=1
            # 좌,우 이동일 경우
            if d%2 :
                # M-1만큼 이동했을 경우 이동방향 변경
                if c == Om-1 :
                    d+=1
                    c=0
            # 상,하 이동일 경우
            else :
                # N-1만큼 이동했을 경우 이동방향 변경
                if c == On-1 :
                    d+=1
                    c=0
        # 바깥쪽에서 안쪽으로 들어가는 과정
        # 시작점 변경
        r+=1
        x,y=(r,r)
        # 이동방향 초기화
        d=0
        # 위아래, 양옆이 두칸씩 줄어드는 것을 표현
        On=On-2
        Om=Om-2
    # 새롭게 이동된 배열을 maps에 재할당
    maps = [new_map[:] for new_map in new_maps[:]]

# 최종적으로 나온 maps를 프린트
for map in maps :
    print(*map)
```



#### ❌ 발생 오류 및 해결

- 회전 종료 설정을 N 기준으로만 세워서 인덱스 에러 발생
  - On과 Om 모두 0 이상일 때만 회전시키도록 설정
