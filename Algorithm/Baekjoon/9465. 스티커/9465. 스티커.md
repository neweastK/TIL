## 🐌 알고리즘 문제 풀이

### Baekjoon_9465. 스티커

#### 📒문제

> 상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.
>
> 상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.
>
> ![img](https://www.acmicpc.net/upload/images/sticker.png)
>
> 모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.
>
> 위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/9465)



#### :pushpin: 입력 및 출력

- 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 

- 각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.

---

> 예시

```txt
input :
2
5
50 10 100 20 40
30 50 70 10 60
7
10 30 10 50 100 20 40
20 40 30 50 60 20 80

output :
260
290
```

----




#### 🚀point

1. DP를 활용하여 문제를 해결한다.
   1. 즉, 이전의 계산 결과가 이후의 결과에 영향을 주지 않음
   2. X번째 열까지의 최선의 결과값을 구한 뒤 다음 X+1번째 열에서의 최선의 결과값을 구하는 방식으로 dp를 구현한다





#### 🔎풀이 계획

1. n-1번째 열에서의 최선의 결과값을 구하기 위한 dp 배열을 만든다
1. 첫번째 값을 그대로 dp 배열에 입력한다.
1. 두번째 값은 [첫번째 열의 다른 행의 점수] + [두번째 열의 현재 행의 점수] 값을 입력한다
1. 세번째부터 조건문과 반복문을 활용한다.
   1. 바로 이전 열, 다른 행의 값과 두번째 전 열의 같은 행의 값 중 큰 값을 현재 값과 더해준다.
   1. 이 과정을 반복한다.

1. 최종적으로 나온 배열에서 마지막 열 중 가장 큰 값을 구한다.
1. N이 1일 때, 즉, 열이 하나일 때는 반복문을 돌리지 않고 바로 두 값 중 큰 값을 출력하도록한다.




#### 💻코드

```python
import sys
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    N = int(input())
    first = list(map(int,input().split()))
    second = list(map(int,input().split()))

    dp = [[0]*2 for _ in range(N)]
    dp[0][0] = first[0]
    dp[0][1] = second[0]

    try:

        dp[1][0] = dp[0][1] + first[1]
        dp[1][1] = dp[0][0] + second[1]

        for i in range(2,N) :
            dp[i][0] = max(dp[i-1][1],dp[i-2][1]) + first[i]
            dp[i][1] = max(dp[i-1][0],dp[i-2][0]) + second[i]

        print(max(dp[-1]))
    except IndexError :
        print(max(dp[0]))
```



#### ❌ 발생 오류 및 해결

- N이 1인 경우 dp의 배열도 한개밖에 안되므로 IndexError 발생

  - try, except 구문으로 따로 조건 설정
  
  
  
  
  

