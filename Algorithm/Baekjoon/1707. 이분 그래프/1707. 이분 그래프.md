## 🐌 알고리즘 문제 풀이

### Baekjoon_1707. 이분 그래프

#### 📒문제

> 그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.
>
> 그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1707)



#### :pushpin: 입력 및 출력

- 입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈 칸을 사이에 두고 주어진다. 

- K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.



---

> 예시

```
input :
2
3 2
1 3
2 3
4 4
1 2
2 3
3 4
4 2

output :
YES
NO
```

----




#### 🚀point

1. 방문 처리를 기존 BFS와는 다르게해서 문제 해결





#### 🔎풀이

1.  인접 리스트로 각 정점간의 연결관계 표시
1.  방문처리 할 visited 배열 생성
    1.  방문처리를 1과 0 뿐만 아니라 1,-1,0 세가지로 표현
    1.  1,-1은 두 집단 표시
    1.  0은 아직 탐색하지 않은 경우

1.  bfs 탐색 함수 생성
    1.  각 노드와 연결된 노드들을 탐색하면서 지금 노드와 다른 집단 번호를 visited배열에 입력한다
    1.  만약, 이전 노드와 같은 집단에 이미 배치가 됐다면, 이분그래프가 아니므로 res에 False 할당
    1.  그렇지 않고 끝까지 탐색을하면 res에 True 할당

1.  bfs 탐색을 했는데도 아직 탐색하지 않은 노드가 있다면 (모든 정점이 연결되어있지 않은 경우)
    1.  해당 노드를 시작점으로 해서 다시 bfs 탐색
    1.  단, 이미 bfs 탐색 결과 False 값이 할당됐다면, 즉 이미 이분그래프가 아닌거로 판명이 됐다면 바로 No 출력

1.  res값에 따라 Yes 또는 No 출력



#### 💻코드

```python
import sys
from collections import deque
input = sys.stdin.readline

# 노드 탐색
def bfs(start):
    queue = deque([start])
    visited[start] = 1
    while queue:
        now = queue.popleft()
        # 각 노드에 연결된 다른 노드들을 탐색
        for i in arr[now]:
            # 현재 노드와 이미 서로 같은 집단이라면 이분그래프의 실패
            if visited[i] == visited[now]:
                return False
           	# 만약 아직 방문하지 않았다면 이전 노드와 다른 집단으로 판정
            elif visited[i] == 0:
                # queue에 넣어주고
                queue.append(i)
                # 방문처리 (now 노드와 다른 집단)
                visited[i] = -visited[now]
    return True

K = int(input())
for _ in range(K):
    V,E = map(int,input().split())

    arr = [[] for _ in range(V+1)]
    for _ in range(E):
        a,b = map(int,input().split())
        arr[a].append(b)
        arr[b].append(a)

    visited = [0]*(V+1)
    visited[0] = 1
    start_num = 1
    # 떨어져있는 노드까지 탐색해야하므로 while문 사용
    while True:
        # bfs탐색 실행
        res = bfs(start_num)
        # 아직 탐색하지 않은 노드가 있고, 탐색결과 아직까지 이분그래프라면
        if 0 in visited and res:
            # 0인 노드를 시작점으로 해서 다시 탐색
            start_num = visited.index(0)
            continue
        # 탐색하지 않은 노드가 없거나, 이분그래프가 이미 아니면 반복문 중단
        break

    if res:
        print("YES")
    else:
        print("NO")
```



#### ❌ 발생 오류 및 해결

- 노드가 떨어져있는 경우를 생각 X
- 탐색결과가 이미 이분그래프가 아니라면 반복문을 중지하고 바로 No출력해야하는데 그 조건 빼먹음
