## 🐌 알고리즘 문제 풀이

### Baekjoon_2293. 동전

#### 📒문제

> n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.
>
> 사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2293)



#### :pushpin: 입력 및 출력

- 첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

- 첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.


---

> 예시

```
input :
3 10
1
2
5

output :
10
```

----




#### 🚀point

1. DP를 활용하여 문제 풀이

2. DP 배열의 의미

   - 행은 사용할 동전
   - 열은 금액을 의미
   - dp[i]\[j]는 i행까지의 동전을 사용하여 j금액을 만드는 경우의 수

   |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 2    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    |
   | 6    | 1    | 0    | 1    | 0    | 1    | 0    | 2    | 0    | 2    | 0    | 2    |
   | 10   | 1    | 0    | 1    | 0    | 1    | 0    | 2    | 0    | 2    | 0    | 3    |

   - 이러한 배열을 1차원으로 만들 수 있음




#### 🔎풀이

1.  입력값을 받고 dp 배열 생성
    1.  dp는 1차원 배열

    1.  dp[i] = i원을 만들 수 있는 경우의 수

    1.  배열의 길이는 k원을 만들 수 있는 경우의 수. 즉, dp[k]를 원하므로 k+1만큼으로 지정한다

1.  dp[0]은 1로 초기화
    1.  0을 만들 수 있는 경우는 어떠한 상황에도 1

    1.  갖고 있는 동전을 안내는 경우

1.  N번만큼 순회하면서 지금 사용하는 동전으로 i 금액을 만들 수 있는 경우를 구한다
    1.  지금 사용하는 동전이 n원이라 했을 때, n원 이하의 금액에는 영향을 주지 못함
        1.  만약, 10원짜리 동전을 받았다면, 1원~9원까지는 10원짜리 동전으로 할 수 있는게 없다는 뜻

    1.  따라서, n원이면 dp의 n번째 값부터 갱신

    1.  dp[i] 즉, 지금까지의 동전으로 i원을 만들 수 있는 경우는, 이전까지의 경우의 수에 지금 동전의 경우의 수를 추가해주는 것
        1.  예시
            1.  만약, 지금 동전이 5원이라 가정하자
            1.  dp[6]은 지금까지 받은 동전들로 6원을 만들 수 있는 경우의 수다
            1.  dp[1]은 지금까지 받은 동전들로 1원을 만들 수 있는 경우의 수다
            1.  dp[1]의 경우들에 지금 동전인 5원을 추가하면, 5원을 포함하여 6원을 만들 수 있는 경우의 수다

        1.  따라서, dp[i]는 dp[i]+dp[i-지금동전금액]이 된다

    1.  모든 dp 배열을 채워준다

1.  최종 dp배열에서 마지막 인덱스(=K) 값을 출력한다




#### 💻코드

```python
N,K = map(int,input().split())

dp = [0]*(K+1)
dp[0] = 1

for _ in range(N):
    n = int(input())
    for i in range(n,K+1):
        dp[i] = dp[i]+dp[i-n]

print(dp[-1])
```



#### ❌ 발생 오류 및 해결

- 

  
