## 🐌 알고리즘 문제 풀이

### Baekjoon_12015. 가장 긴 증가하는 부분 수열 2

#### 📒문제

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/12015)



#### :pushpin: 입력 및 출력

- 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

- 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.



---

> 예시

```
input :
6
10 20 10 30 20 50

output :
4
```

----




#### 🚀point

1. 이분탐색으로 LIS를 구하는 문제
   1. LIS를 구할 때는 DP와 이분탐색 사용 가능
   1. 이 문제에서는 DP를 사용하면 시간초과 발생
   1. DP는 O(N^2), 이분탐색은 O(N log N)의 시간복잡도이기 때문




#### 🔎풀이

1.  이분탐색을 직접 구현하는 방법과 라이브러리 사용하는 방법 중 라이브러리 사용해보기
1.  이분탐색으로 특정 값의 위치를 구할 수 있는 bisect 라이브러리 import
1.  입력값을 받고, LIS 길이를 구하기 위한 res 배열 생성
1.  입력값으로 받은 배열을 순회하면서 res 값과 비교
    1.  만약 res의 가장 큰 값보다 크면 바로 append
    1.  작으면 이분탐색으로 해당 값이 res 배열의 몇번째 인덱스로 들어가는지 확인
        1.  이때, bisect_left 이용
        1.  bisect_left(배열, 특정 값)

    1.  해당 위치에 배열 값 넣기

1.  최종적으로 만들어진 res 배열에서 초기값인 0을 뺀 길이 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline
from bisect import bisect_left

N = int(input())
arr = list(map(int,input().split()))
res = [0]

for i in range(N):
    if res[-1]<arr[i]:
        res.append(arr[i])
    else:
        idx = bisect_left(res,arr[i])
        res[idx] = arr[i]

print(len(res)-1)
```



#### ❌ 발생 오류 및 해결

- 
