## 🐌 알고리즘 문제 풀이

### Baekjoon_2458. 키 순서

#### 📒문제

> 1번부터 N번까지 번호가 붙여져 있는 학생들에 대하여 두 학생끼리 키를 비교한 결과의 일부가 주어져 있다. 단, N명의 학생들의 키는 모두 다르다고 가정한다. 예를 들어, 6명의 학생들에 대하여 6번만 키를 비교하였고, 그 결과가 다음과 같다고 하자. 
>
> - 1번 학생의 키 < 5번 학생의 키
> - 3번 학생의 키 < 4번 학생의 키
> - 5번 학생의 키 < 4번 학생의 키
> - 4번 학생의 키 < 2번 학생의 키
> - 4번 학생의 키 < 6번 학생의 키
> - 5번 학생의 키 < 2번 학생의 키
>
> 이 비교 결과로부터 모든 학생 중에서 키가 가장 작은 학생부터 자신이 몇 번째인지 알 수 있는 학생들도 있고 그렇지 못한 학생들도 있다는 사실을 아래처럼 그림을 그려 쉽게 확인할 수 있다. a번 학생의 키가 b번 학생의 키보다 작다면, a에서 b로 화살표를 그려서 표현하였다. 
>
> ![img](https://upload.acmicpc.net/8f9e2484-a3aa-4b97-b1fa-387df4ae58d0/-/preview/)
>
> 1번은 5번보다 키가 작고, 5번은 4번보다 작기 때문에, 1번은 4번보다 작게 된다. 그러면 1번, 3번, 5번은 모두 4번보다 작게 된다. 또한 4번은 2번과 6번보다 작기 때문에, 4번 학생은 자기보다 작은 학생이 3명이 있고, 자기보다 큰 학생이 2명이 있게 되어 자신의 키가 몇 번째인지 정확히 알 수 있다. 그러나 4번을 제외한 학생들은 자신의 키가 몇 번째인지 알 수 없다. 
>
> 학생들의 키를 비교한 결과가 주어질 때, 자신의 키가 몇 번째인지 알 수 있는 학생들이 모두 몇 명인지 계산하여 출력하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2458)



#### :pushpin: 입력 및 출력

- 첫째 줄에 학생들의 수 N (2 ≤ N ≤ 500)과 두 학생 키를 비교한 횟수 M (0 ≤ M ≤ N(N-1)/2)이 주어진다. 다음 M개의 각 줄에는 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a와 b가 주어진다. 이는 번호가 a인 학생이 번호가 b인 학생보다 키가 작은 것을 의미한다. 

- 자신이 키가 몇 번째인지 알 수 있는 학생이 모두 몇 명인지를 출력한다. 



---

> 예시

```
input :
6 6
1 5
3 4
5 4
4 2
4 6
5 2

output :
1

input :
6 7
1 3
1 5
3 4
5 4
4 2
4 6
5 2

output :
2

input :
6 3
1 2
2 3
4 5

output :
0
```

----




#### 🚀point

1. 플로이드 워셜 알고리즘 사용하기
1. 모든 배열이 완성됐을 때, 각 노드가 자신의 위치를 명확히 알 수 있는지 여부 점검
   1. a→b 라는 입력값이 있을 때, arr\[a][b]에는 양수를 arr\[b][a]에는 음수를 할당
   1. 혹은, 행의 정보는 해당 노드보다 큰 노드의 개수, 열의 정보는 해당 노드보다 작은 노드의 개수로 풀이




#### 🔎풀이

1.  입력값을 받고 노드 개수만큼 arr 배열 생성
    1.  주어지는 입력값의 정보가 0이 아닌 1부터 시작하므로 N+1 길이의 배열 생성

1.  자기 자신을 가르키는 배열에는 0 할당
1.  입력값을 받으면서 연결된 노드를 1로 표시
1.  직접 연결된 노드 외에도 특정 노드들을 거쳐서 연결된 노드가 있는지 확인 필요
    1.  3중 반복으로, 첫 반복에서 k를 지정
    1.  k는 k번째 노드를 거쳐서 간다는 의미
    1.  거쳐갈 수 있다면 해당 위치에 재할당

1.  최종적으로 자기 노드보다 크거나 작은 노드의 개수를 합해서 할당할 배열 생성
1.  i번째 노드보다 큰 노드의 개수는 i행에 있는 0이나 INF 가 아닌 값의 개수
1.  i번째 노드보다 작은 노드의 개수는 i열에 있는 0이나 INF가 아닌 값의 개수
1.  최종적으로 res배열에서 N-1의 개수를 출력
    1.  N-1은 자기보다 작은 노드의 개수와 큰 노드의 개수가 N-1개면 모든 노드와의 관계를 안다는 것
    1.  자기 자신을 뺀 모든 노드의 개수이므로




#### 💻코드

```python
import sys
input = sys.stdin.readline

N,M = map(int,input().split())
# 연결되지 않은 경우 INF로 표현
INF = int(1e9)
arr = [[INF]*(N+1) for _ in range(N+1)]

# 자신을 타겟으로 할 때는 0으로 할당
for i in range(1,N+1):
    for j in range(1,N+1):
        if i == j:
            arr[i][j] = 0
            
# 입력값을 받아서 연결된 노드는 1로 표시
for _ in range(M):
    a,b = map(int,input().split())
    arr[a][b] = 1

# 플로이드 워셜을 통해 특정 노드를 거쳐서 갈 수 있는지 체크 
for k in range(1,N+1):
    for i in range(1, N + 1):
        for j in range(1, N + 1):
            # 특정 노드로 갈 수 있다면 INF가 아닌 다른 값이 나올 것이고,
            # 특정 노드로 갈 수 없다면 INF가 나올 것
            arr[i][j] = min(arr[i][j], arr[i][k]+arr[k][j])

# 자신보다 크거나 작은 노드의 개수            
res = [0]*(N+1)

# 완성된 배열을 순회
for i in range(1,N+1):
    for j in range(1, N + 1):
        # 만약 i행에 INF나 0이 아닌 값이 있다면 자신보다 큰 값의 개수를 나타내는 것
        if arr[i][j] != INF and arr[i][j] != 0:
            res[i]+=1
        # 만약 j행에 INF나 0이 아닌 값이 있다면 자신보다 작은 값의 개수를 나타내는 것
        if arr[j][i] != INF and arr[j][i] != 0:
            res[i]+=1
# 최종 답은 총 개수가 N-1인 인덱스의 개수
ans = res.count(N-1)
print(ans)
```



#### ❌ 발생 오류 및 해결

- 
