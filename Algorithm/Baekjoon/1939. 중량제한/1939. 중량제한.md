## 🐌 알고리즘 문제 풀이

### Baekjoon_1939. 중량제한

#### 📒문제

> N(2 ≤ N ≤ 10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.
>
> 영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.
>
> 한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1939)



#### :pushpin: 입력 및 출력

- 첫째 줄에 N, M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1 ≤ A, B ≤ N), C(1 ≤ C ≤ 1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 섬 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.

- 첫째 줄에 답을 출력한다.


---

> 예시

```
input :
3 3
1 2 2
3 1 3
2 3 2
1 3

output :
3
```

----




#### 🚀point

1. BFS와 이분탐색 사용하여 풀이
2. 이분탐색으로 물품의 중량을 탐색하고, bfs로 해당 중량으로 공장에서 다른 공장으로 이동 가능한지 확인한다



#### 🔎풀이

1.  입력값을 모두 받는다
    1.  다리에 대한 입력값을 받을 때, 인접행렬을 사용하면 메모리 초과 발생

    1.  인접 리스트로 연결관계를 표현해야함.
        1.  인접행렬로 할 때는 중량제한의 최댓값만 갖고 있어도 됐음

        1.  but, 인접리스트로 할 때는 그 작업이 쉽지 않으므로 그냥 모든 값을 받는다

        1.  동일한 섬으로의 이동이 있어도 방문배열로 인해 중복체크 되지 않음

1.  물건의 중량이 주어졌을 때, 해당 물건이 공장에서 공장으로 이동 가능한지 확인할 bfs 함수 선언
    1.  현재 섬에서 다른 섬으로 이동할 때, 해당 물건보다 중량제한이 크거나 같은 경우만 이동
    1.  이동 가능하면 True, 불가능하면 False 반환

1.  이분탐색으로 물건의 중량 선정
    1.  최솟값인 1부터 최댓값인 10억까지 범위를 정한다

    1.  mid 값이 bfs에서 무게 변수
    1.  이동 가능하면 answer 변수에 저장하고, 더 무거운 물건도 가능한지 확인하기 위해 left값 조정
    1.  이동 불가능하면 더 가벼운 물건을 탐색해야하므로 right값 조정

1.  최종적으로 answer 변수에 담긴 값 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline
from collections import deque

N,M = map(int,input().split())
edges = [[] for _ in range(N+1)]

for _ in range(M):
    a,b,c = map(int,input().split())
    edges[a].append([b,c])
    edges[b].append([a,c])

start,end = map(int,input().split())

def bfs(start,end,maximum):
    queue = deque([start])
    visited = [0]*(N+1)
    visited[start]=1

    while queue:
        now = queue.popleft()

        for next,weight in edges[now]:
            if weight>=maximum and visited[next] == 0:
                if next == end:
                    return True
                queue.append(next)
                visited[next] = 1
    return False

left = 1
right = 1000000000
answer = 0
while left<=right:
    mid = (left+right)//2

    if bfs(start,end,mid):
        answer = mid
        left = mid+1
    else:
        right = mid-1

print(answer)
```



#### ❌ 발생 오류 및 해결

- 인접 행렬로 섬간의 연결관계를 표현해서 메모리 초과 발생
