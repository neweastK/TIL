## 🐌 알고리즘 문제 풀이

### Baekjoon_2573. 빙산

#### 📒문제

> 지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.
>
> |      |      |      |      |      |      |      |
> | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> |      | 2    | 4    | 5    | 3    |      |      |
> |      | 3    |      | 2    | 5    | 2    |      |
> |      | 7    | 6    | 2    | 4    |      |      |
> |      |      |      |      |      |      |      |
>
> 그림 1. 행의 개수가 5이고 열의 개수가 7인 2차원 배열에 저장된 빙산의 높이 정보
>
> 빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.
>
> 그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.
>
> |      |      |      |      |      |      |      |
> | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> |      |      | 2    | 4    | 1    |      |      |
> |      | 1    |      | 1    | 5    |      |      |
> |      | 5    | 4    | 1    | 2    |      |      |
> |      |      |      |      |      |      |      |
>
> 그림 2
>
> |      |      |      |      |      |      |      |
> | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> |      |      |      | 3    |      |      |      |
> |      |      |      |      | 4    |      |      |
> |      | 3    | 2    |      |      |      |      |
> |      |      |      |      |      |      |      |
>
> 그림 3
>
> 한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2573)



#### :pushpin: 입력 및 출력

- 첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다. N과 M은 3 이상 300 이하이다. 그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0 이상 10 이하이다. 배열에서 빙산이 차지하는 칸의 개수, 즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다. 배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.

- 첫 줄에 빙산이 분리되는 최초의 시간(년)을 출력한다. 만일 빙산이 다 녹을 때까지 분리되지 않으면 0을 출력한다.

---

> 예시

```
input :
5 7
0 0 0 0 0 0 0
0 2 4 5 3 0 0
0 3 0 2 5 2 0
0 7 6 2 4 0 0
0 0 0 0 0 0 0
output :
2
```

----


#### 🚀point

1.  dfs와 bfs 동시 사용
1.  주어진 배열을 깊은 복사하여 새로운 배열 생성이 필요함

#### 🔎풀이

1. 입력값을 받고 주어진 배열과 똑같이 생긴 배열을 하나 복사한다.
   
1. 또한, 주어진 배열과 같은 크기의 방문처리용 배열을 생성한다.
   
1. 배열을 순회하면서 빙산을 찾으면 녹은 결과를 따로 저장한다.
   
1. 한바퀴 다 돌았을 때 bfs로 몇개의 그룹이 남았는지 확인한다.
   
1. 2개 이상이면 그 때의 시간을, 2개 이하이면 다시 녹는 과정을 진행한다.
   
1. 배열 내에 더 이상 빙산이 없고, 그룹도 2개 이상이 안됐다면, 0을 출력한다.
   

#### 💻코드

```python
import sys
from collections import deque
input = sys.stdin.readline


# 몇개의 그룹으로 이루어져있는지 확인하기 위한 함수
def bfs(arr):
    # 그룹의 개수
    c=0
    for i in range(N):
        for j in range(M):
            if arr[i][j] > 0 and check_arr[i][j] == 0 :
                c+=1
                queue = deque([(i,j)])

                while queue :
                    x,y = queue.popleft()
                    check_arr[x][y] = c

                    for d in range(4):
                        nx = x+dx[d]
                        ny = y+dy[d]

                        if 0<=nx<N and 0<=ny<M and arr[nx][ny]>0 and check_arr[nx][ny] == 0 :
                            check_arr[nx][ny] = c
                            queue.append((nx,ny))
    return c

# 4방향 순회 후 0의 개수만큼 빼기
def melting(x,y):
    for d in range(4):
        nx = x+dx[d]
        ny = y+dy[d]
        if arr[nx][ny] <= 0 :
            new_arr[x][y] -= 1

            
N,M = map(int,input().split())
arr = []
dx = [0,0,1,-1]
dy = [1,-1,0,0]
cnt = 0

for _ in range(N):
    arr.append(list(map(int,input().split())))

# 빙산이 다 녹을 때까지 혹은 두개의 그룹이 될때까지 반복
while True:
    # 두개 이상의 그룹이 나올 수 없는 경우 확인을 위한 변수
    cnt_zero = 0
    cnt+=1
    # 녹은 결과를 저장할 배열
    new_arr = [x[:] for x in arr[:]]
    # 방문처리할 배열
    check_arr = [[0]*M for _ in range(N)]

    for i in range(N):
        for j in range(M):
            # 만약 빙산이라면 녹인다
            if arr[i][j] > 0 :
                melting(i,j)
            # 아니라면 0의 개수를 센다
            else :
                cnt_zero += 1
	# 녹은 결과를 기존 배열에 업데이트해준다
    arr = new_arr
    # bfs로 몇개의 그룹인지 확인한다
    res = bfs(arr)
    
    # 만약 2개 이상의 그룹이면
    if res >= 2:
        # 그때의 지난 시간 출력
        print(cnt)
        break
        
    else :
        # 2개 이상의 그룹이 안나오고, 빙산이 다 녹았다면
        if cnt_zero == N*M:
            # 0 출력
            print(0)
            break
```



#### ❌ 발생 오류 및 해결

- 
