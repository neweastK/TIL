## 🐌 알고리즘 문제 풀이

### Baekjoon_1697. 숨바꼭질

#### 📒문제

> 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
>
> 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1697)



#### :pushpin: 입력 및 출력

- 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

- 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.



---

> 예시

```
input :
5 17

output :
4
```

----




#### 🚀point

1. BFS로 풀되, 각종 예외사항을 잘 처리해야함
   1. K보다 큰 수로 갔다가 -1 해서 오는 경우가 더 빨리 올 수도 있음!
   1. 따라서, 방문 배열 길이를 K로 해서는 안됨




#### 🔎풀이

1.  수빈이의 위치와 동생의 위치를 입력값으로 받는다
1.  몇번만에 해당 칸에 갈 수 있는지를 기록할 배열을 생성한다
    1.  이때, 배열의 길이는 무조건 최댓값으로 한다 (100000)
    1.  N 혹은 K로 기준을 잡으면 안되는 이유
        1.  N 혹은 K 보다 큰 위치로 갔다가 -1 을 통해 돌아올 수도 있기 때문

1.  해당 배열을 채우는 로직은 BFS 사용
1.  우선 시작점인 arr[N]을 0으로 초기화 시켜준다
1.  queue에 출발점을 넣어준다
1.  queue가 빌 때까지 반복한다
    1.  현재 위치를 popleft로 반환
    1.  현재 위치에서 갈 수 있는 곳들을 배열로 생성 (-1,+1,x2)
    1.  해당 배열을 순회
        1.  해당 값이 범위에 속하고, 방문한 적이 없다면 방문처리
        1.  이전 위치에서 +1 한 값을 할당해준다 (해당값만에 도착할 수 있다는 뜻)
        1.  해당 위치를 queue에 넣어준다

    1.  BFS이기 때문에 처음 할당한 값이 가장 최단시간만에 도착할 수 있다는 뜻




#### 💻코드

```python
from collections import deque
import sys
input = sys.stdin.readline

N,K = map(int,input().split())

# idx와 value의 관계 : idx는 최소 value 시간만에 도착 가능
arr = [-1]*100001

# 출발점 초기화
arr[N] = 0
queue = deque([N])

while queue:
    now = queue.popleft()
    # 현재 위치에서 이동할 수 있는 곳
    tmp = [now+1,now-1,now*2]
    for t in tmp:
        # 범위에 속하고, 방문한 적이 없는 경우
        if 0<=t<=100000 and arr[t] == -1 :
            arr[t] = arr[now]+1
            queue.append(t)

print(arr[K])
```



#### ❌ 발생 오류 및 해결

- 동생의 위치를 넘었다가 뒤로 돌아오는 경우 오답처리
