## 🐌 알고리즘 문제 풀이

### Baekjoon_1261. 알고스팟

#### 📒문제

> 알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.
>
> 알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.
>
> 벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.
>
> 만약 이 문제가 [알고스팟](https://www.algospot.com/)에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 [Baekjoon Online Judge](https://www.acmicpc.net/)에 수록되어 있기 때문에, sudo를 사용할 수 없다.
>
> 현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1261)



#### :pushpin: 입력 및 출력

- 첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다.

  (1, 1)과 (N, M)은 항상 뚫려있다

- 첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.




---

> 예시

```
input :
3 3
011
111
110

output :
3

input :
4 2
0001
1000

output :
0

input :
6 6
001111
010000
001111
110001
011010
100010

output :
2
```

----




#### 🚀point

1. deque의 appendleft와 append를 통해 이동할 노드의 우선순위를 정한다.
1. queue에 넣는 순간에 비용을 계산해준다.



#### 🔎풀이

1.   각 노드까지의 비용을 나타낼 distance 배열, 방문여부를 나타내는 visit 배열, 벽 유무를 나타내는 maps 배열을 생성한다.
    1.  maps 배열에는 input값들을 넣어놓는다.

1.  bfs 함수를 정의한다.
    1.  기본적인 틀은 유지하되 벽의 유무에 따라 분기 처리를 한다.
    1.  벽이 있으면 queue의 맨 뒤에 넣어주고(append), 벽이 없으면 queue의 맨 앞에 넣어준다.(appendleft)
    1.  또한, queue에 넣어주는 순간 해당 노드까지의 비용을 계산한다.
        1.  이때, 계산해야 최소비용이 나오기 때문
        1.  벽이 있으면 이전 노드까지의 비용 + 1, 벽이 없으면 이전 노드까지의 비용 + 0 으로 계산해준다.

1.  bfs함수를 실행시키고 나면 각 노드별 최소 비용이 나오기 때문에 마지막 목적지의 비용을 출력한다.

#### 💻코드

```python
import sys
from collections import deque
input = sys.stdin.readline


def bfs(sx, sy):
    queue = deque([])
    queue.append((sx, sy))

    while queue:
        x, y = queue.popleft()

        for d in range(4):
            nx = x + dx[d]
            ny = y + dy[d]

            if 0 <= nx < M and 0 <= ny < N and visit[nx][ny] == 0:
                visit[nx][ny] = 1
                if maps[nx][ny]:
                    queue.append((nx, ny))
                    distance[nx][ny] = distance[x][y] + 1
                else:
                    queue.appendleft((nx, ny))
                    distance[nx][ny] = distance[x][y]


N,M = map(int,input().split())
maps = []
distance = [[0]*N for _ in range(M)]
visit = [[0]*N for _ in range(M)]
for _ in range(M):
    maps.append(list(map(int,input().rstrip())))

dx = [0,0,1,-1]
dy = [1,-1,0,0]

bfs(0,0)
print(distance[M-1][N-1])
```



#### ❌ 발생 오류 및 해결

- [참고 블로그](https://codingfull.tistory.com/26)
- rstrip 없어서 오류 발생
