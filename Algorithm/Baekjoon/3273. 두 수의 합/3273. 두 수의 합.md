## 🐌 알고리즘 문제 풀이

### Baekjoon_3273. 두 수의 합

#### 📒문제

> n개의 서로 다른 양의 정수 a1, a2, ..., an으로 이루어진 수열이 있다. ai의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 x가 주어졌을 때, ai + aj = x (1 ≤ i < j ≤ n)을 만족하는 (ai, aj)쌍의 수를 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/3273)



#### :pushpin: 입력 및 출력

- 첫째 줄에 수열의 크기 n이 주어진다. 다음 줄에는 수열에 포함되는 수가 주어진다. 셋째 줄에는 x가 주어진다. (1 ≤ n ≤ 100000, 1 ≤ x ≤ 2000000)

- 문제의 조건을 만족하는 쌍의 개수를 출력한다.



---

> 예시

```
input :
9
5 12 7 10 9 1 2 3 11
13

output :
3
```

----




#### 🚀point

1. 순회 혹은 완전 탐색시 시간초과 발생
1. 포인터를 어떤 조건에서 어떻게 이동시킬 것인지가 중요
   1. 시작 포인터는 작은 수부터 큰 수로 올라가고, 끝 포인터는 큰 수부터 작은수로 내려옴
   1. 두 수의 합이 x와 같다면, 시작 포인터가 더 올라가도 의미없음(계속 수는 커질 것이기 때문에)
      1. 따라서, 끝 포인터가 한칸 내려와야함
      1. 지금 위치 바로 직전의 시작포인터 값과 내려오기 전 끝 포인터의 값의 합은 x보다 작을 것
         1. 따라서, 시작포인터가 한칸 내려간다면, 어차피 갱신된 값들끼리의 합은 여전히 x보다 작음
         1. 즉, 시작포인터는 내려올 필요 없이 그대로 있으면 됨

   1. 두 수의 합이 x보다 크다면, 시작 포인터가 더 올라가도 의미 없음
      1. 따라서, 끝포인터가 한칸 내려와야함
      1. 2-2와 마찬가지로 시작포인터는 그대로 있으면 됨 (한칸 내려가면 어차피 더 작을 수밖에 없음)

   1. 두 수의 합이 x보다 작으면, 시작 포인터를 한칸 더 올림
      1. x와 같아질 수 있는 가능성이 있으므로




#### 🔎풀이

1.  모든 입력값을 받고, 배열을 정렬한다

1.  시작 포인트와 끝 포인트의 인덱스를 나타낼 변수를 선언한다

1.  시작 포인트는 배열의 맨 앞, 끝 포인트는 배열의 맨 뒤를 가리킨다

1.  시작 포인트가 끝 포인트보다 작을 때까지 반복한다

1.  시작 지점의 값과, 끝 지점 값의 합에 따라 분기처리한다

    1.  합이 x보다 크다면 제일 큰 값을 가리키던 끝 포인트를 1 감소시킨다
        1.  그러면, 그 다음부터는 더 작은 수 탐색

    1.  합이 x보다 작다면 제일 큰 값을 가리키는 끝 포인트는 그대로 두고, 시작 포인트를 1 증가시킨다
        1.  그러면, 합이 점점 커질 것
    1.  합이 x와 같다면 끝 포인트는 1 감소시킨다
        1.  그리고, 조건을 만족하는 경우이므로 cnt 에 1을 더해준다

1.  최종적으로 cnt를 출력한다



#### 💻코드

```python
N = int(input())
arr = list(map(int, input().split()))
arr.sort()

X = int(input())

start = 0
end = N-1
cnt = 0
while start < end:
    tmp = arr[start] + arr[end]
    if tmp > X:
        end -= 1
    elif tmp == X:
        cnt += 1
        end-=1
    else:
        start += 1
print(cnt)
```



#### ❌ 발생 오류 및 해결

- 배열의 각 원소는 서로 다른 정수로 이뤄져있다는 것을 모르고 더 복잡하게 문제풀이
