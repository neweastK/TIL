## 🐌 알고리즘 문제 풀이

### Baekjoon_1463. 1로 만들기

#### 📒문제

> 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
>
> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
>    3. 1을 뺀다.
>    
>    정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오..
>    
>    [<문제 출처>](https://www.acmicpc.net/problem/1463)



#### :pushpin: 입력 및 출력

- 첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

- 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.


---

> 예시

```
input :
2

output :
1

input :
10

output :
3
```

----




#### 🚀point

1. dp 구현 문제



#### 🔎풀이

1.  N+1 길이의 dp 배열을 생성하고 0으로 초기화한다.
1.  배열의 각 값은 각 인덱스가 1이 되기 위한 가장 적은 연산횟수를 뜻함
    1.  예를 들어 dp[2] 는 2가 1이 되기 위한 최소 연산횟수로 1을 값으로 갖는다.
    1.  dp[5] 는 5 -> 4 -> 2 -> 1 로 3을 값으로 갖는다

1.  1부터 순서대로 구하고 최종적으로 dp[N] 구한다
    1.  우선 이전 값에 1을 더한 값을 넣는다 (-1을 한 경우)
    1.  만약 2로 나눠진다면 %2 한 위치값에 1을 더한 값과 기존 값을 비교한다. (2로 나눈 경우와 -1을 한 경우 비교.)
    1.  만약 3으로 나눠진다면 %3 한 위치값에 1을 더한 값과 기존 값을 비교한다.
    1.  비교 결과 가장 작은 값을 dp[i]에 넣어준다 


#### 💻코드

```python
N = int(input())

dp = [0]*(N+1)

for i in range(2,N+1):
    dp[i] = dp[i-1]+1

    if i%2 == 0 :
        dp[i] = min(dp[i//2]+1,dp[i])

    if i%3 == 0 :
        dp[i] = min(dp[i//3]+1,dp[i])

print(dp[N])
```



#### ❌ 발생 오류 및 해결

- 
