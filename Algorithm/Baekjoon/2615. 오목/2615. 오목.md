## 🐌 알고리즘 문제 풀이

### Baekjoon_2615. 오목

#### 📒문제

> 오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고 세로줄은 왼쪽에서부터 오른쪽으로 1번, 2번, ... 19번의 번호가 붙는다.
>
> ![img](https://upload.acmicpc.net/42c87203-247a-49d1-bc63-44397a7184db/-/preview/)
> 
>    위의 그림에서와 같이 같은 색의 바둑알이 연속적으로 다섯 알을 놓이면 그 색이 이기게 된다. 여기서 연속적이란 가로, 세로 또는 대각선 방향 모두를 뜻한다. 즉, 위의 그림은 검은색이 이긴 경우이다. 하지만 여섯 알 이상이 연속적으로 놓인 경우에는 이긴 것이 아니다.
>    
>    입력으로 바둑판의 어떤 상태가 주어졌을 때, 검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성하시오. 단, 검은색과 흰색이 동시에 이기거나 검은색 또는 흰색이 두 군데 이상에서 동시에 이기는 경우는 입력으로 들어오지 않는다.
>    
>    [<문제 출처>](https://www.acmicpc.net/problem/2615)



#### :pushpin: 입력 및 출력

- 19줄에 각 줄마다 19개의 숫자로 표현되는데, 검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시되며, 숫자는 한 칸씩 띄어서 표시된다.

- 첫줄에 검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력한다. 검은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알(연속된 다섯 개의 바둑알이 세로로 놓인 경우, 그 중 가장 위에 있는 것)의 가로줄 번호와, 세로줄 번호를 순서대로 출력한다.



---

> 예시

```
input :
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 0 0 2 2 2 1 0 0 0 0 0 0 0 0 0 0
0 0 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

output :
1
3 2
```

----


#### 🚀point

1. 기존에는 델타를 통한 한방향 탐색이었으나 양방향 탐색을 해야 풀이 가능
1. (좌,우),(상,하)를 동시에 탐색해야함



#### 🔎풀이

1.  4개의 델타 생성
    1.  각각 좌우, 상하, 왼쪽대각, 오른쪽대각을 탐색하도록 설정

1.  오목판을 순회하면서 돌이 있다면 해당 돌을 기준으로 주변을 탐색
1.  오목이 되는지 확인
    1.  상하, 좌우, 대각1, 대각2 를 돌면서 각 상황에서 같은 색깔의 돌이 몇개 있는지 확인
    1.  상하를 다 돌고, 좌우를 다 돌고 즉, 각 방향을 다 돌았을 때 같은 돌의 색이 몇개 이어져있는지 확인
    1.  만약 없다면 중간에 break

1.  오목이 된다면 처음 시작했던 위치 출력
    1.  가장 왼쪽 위치를 뽑기 위해 전체 순회 방향을 가로-> 세로가 아닌 세로-> 가로 방향으로 탐색함

1.  전체를 순회해도 오목이 없다면 0 출력

#### 💻코드

```python
def check_omok(si,sj,color):
    for delta in range(4):
        cnt = 1
        for d in range(2):
            x, y = si, sj
            while True :
                ni = x+dx[delta][d]
                nj = y+dy[delta][d]

                if 0<=ni<19 and 0<=nj<19 and maps[ni][nj] == color:
                    cnt+=1
                    x = ni
                    y = nj
                else :
                    break

        if cnt == 5:
            return True

    return False

dx = [(0,0),(1,-1),(1,-1),(-1,1)]
dy = [(1,-1),(0,0),(1,-1),(1,-1)]
maps = [list(map(int,input().split())) for _ in range(19)]


for j in range(19):
    for i in range(19):
        if maps[i][j] != 0:
            if check_omok(i,j,maps[i][j]):
                print(maps[i][j])
                print(i+1,j+1)
                quit()

print(0)
```



#### ❌ 발생 오류 및 해결

- 시간을 줄이기 위해 이미 탐색한 곳은 배제하였더니 6개 이상의 돌이 있는 경우도 오목이라고 판단
  - 예를 들어서, 7개의 돌이 있음에도 2개를 이미 탐색했기 때문에 카운트를 하지 않으면 7목임에도 오목이라고 판정
- 탐색이 끝나고 추가로 이동하기 위해 x값을 nx로 바꿔주고 y값을 ny로 바꿔주는 방법으로 진행했으나, 이전 방향에 영향을 받아 오답 출력
