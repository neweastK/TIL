## 🐌 알고리즘 문제 풀이

### Baekjoon_4963. 섬의 개수

#### 📒문제

> 정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.
>
> 한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다. 
>
> 두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/4963)

#### :pushpin: 입력 및 출력

- 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 지도의 너비 w와 높이 h가 주어진다. w와 h는 50보다 작거나 같은 양의 정수이다.
- 둘째 줄부터 h개 줄에는 지도가 주어진다. 1은 땅, 0은 바다이다. 입력의 마지막 줄에는 0이 두 개 주어진다.
- 각 테스트 케이스에 대해서, 섬의 개수를 출력한다.

---

> 예시

입력						 출력 

1 1							0
0							   1
2 2							1
0 1							3
1 0							1
3 2							9
1 1 1
1 1 1
5 4
1 0 1 0 0
1 0 0 0 0
1 0 1 0 1
1 0 0 1 0
5 4
1 1 1 0 1
1 0 1 0 1
1 0 1 0 1
1 0 1 1 1
5 5
1 0 1 0 1
0 0 0 0 0
1 0 1 0 1
0 0 0 0 0
1 0 1 0 1
0 0

----




#### 🚀point

1. 몇 칸으로 이어져있든 하나의 섬으로 친다

1. 지도로 받은 배열 원본에 계속 적용시켜야 한다.

1. 대각까지 확인해야한다

   


#### 🔎풀이

1. 섬 하나를 발견하면 이어져있는 모든 섬을 체크한다
1. 체크 방법은 1이 아닌 다른 숫자로 한다.
- 카운트하기 위해 몇번째 섬인지 나타낼 수 있는 숫자를 마크한다

3. 가장 마지막 카운트 = 섬의 개수이므로 해당 값을 출력한다




#### 💻코드

```python
# 상하좌우, 대각 총 8방향
dx = [-1,1,0,0,-1,-1,1,1]
dy = [0,0,-1,1,-1,1,-1,1]

# 이어져있는 섬 표시하는 함수
def make_island(x,y,cnt):
    global maps
    for d in range(8): # 여덟방향 탐색
        nx = x+dx[d]
        ny = y+dy[d]
		
        #내 근처 여덟방향으로 섬이 있다면
        if 0<=nx<h and 0<=ny<w and maps[nx][ny] == 1:
            maps[nx][ny] = cnt #섬 체크해주고
            make_island(nx,ny,cnt) #해당 위치로 이동해서 다시 섬 탐색


while True :
    w,h = map(int,input().split()) 
    #입력값이 0,0이면 중단
    if (w,h) == (0,0) :
        break

    maps = [list(map(int,input().split())) for _ in range(h)]
    # 1로 하면 섬 표시하는 숫자와 겹치므로 2부터 하고 마지막에 빼준다.
    cnt=2
    for i in range(h):
        for j in range(w):
            if maps[i][j] == 1:
                make_island(i,j,cnt)
                cnt+=1 #섬의 개수를 증가시켜준다

    print(cnt-2) #최종 섬의 개수
```



#### ❌ 발생 오류 및 해결

- 입력을 계속 받다가 0,0 이 들어오면 멈춰야하는데 주어지지 않는 입력 개수를 찾느라 시간을 보냈다.
