## 🐌 알고리즘 문제 풀이

### Baekjoon_14938. 서강그라운드

#### 📒문제

> 예은이는 요즘 가장 인기가 있는 게임 서강그라운드를 즐기고 있다. 서강그라운드는 여러 지역중 하나의 지역에 낙하산을 타고 낙하하여, 그 지역에 떨어져 있는 아이템들을 이용해 서바이벌을 하는 게임이다. 서강그라운드에서 1등을 하면 보상으로 치킨을 주는데, 예은이는 단 한번도 치킨을 먹을 수가 없었다. 자신이 치킨을 못 먹는 이유는 실력 때문이 아니라 아이템 운이 없어서라고 생각한 예은이는 낙하산에서 떨어질 때 각 지역에 아이템 들이 몇 개 있는지 알려주는 프로그램을 개발을 하였지만 어디로 낙하해야 자신의 수색 범위 내에서 가장 많은 아이템을 얻을 수 있는지 알 수 없었다.
>
> 각 지역은 일정한 길이 l (1 ≤ l ≤ 15)의 길로 다른 지역과 연결되어 있고 이 길은 양방향 통행이 가능하다. 예은이는 낙하한 지역을 중심으로 거리가 수색 범위 m (1 ≤ m ≤ 15) 이내의 모든 지역의 아이템을 습득 가능하다고 할 때, 예은이가 얻을 수 있는 아이템의 최대 개수를 알려주자.
> 
>    ![img](https://upload.acmicpc.net/ef3a5124-833a-42ef-a092-fd658bc8e662/-/preview/)
> 
>    주어진 필드가 위의 그림과 같고, 예은이의 수색범위가 4라고 하자. ( 원 밖의 숫자는 지역 번호, 안의 숫자는 아이템 수, 선 위의 숫자는 거리를 의미한다) 예은이가 2번 지역에 떨어지게 되면 1번,2번(자기 지역), 3번, 5번 지역에 도달할 수 있다. (4번 지역의 경우 가는 거리가 3 + 5 = 8 > 4(수색범위) 이므로 4번 지역의 아이템을 얻을 수 없다.) 이렇게 되면 예은이는 23개의 아이템을 얻을 수 있고, 이는 위의 필드에서 예은이가 얻을 수 있는 아이템의 최대 개수이다.
> 
>    [<문제 출처>](https://www.acmicpc.net/problem/14938)



#### :pushpin: 입력 및 출력

- 첫째 줄에는 지역의 개수 n (1 ≤ n ≤ 100)과 예은이의 수색범위 m (1 ≤ m ≤ 15), 길의 개수 r (1 ≤ r ≤ 100)이 주어진다.

  둘째 줄에는 n개의 숫자가 차례대로 각 구역에 있는 아이템의 수 t (1 ≤ t ≤ 30)를 알려준다.
  
  세 번째 줄부터 r+2번째 줄 까지 길 양 끝에 존재하는 지역의 번호 a, b, 그리고 길의 길이 l (1 ≤ l ≤ 15)가 주어진다.
  
- 예은이가 얻을 수 있는 최대 아이템 개수를 출력한다.



---

> 예시

```
input :
5 5 4
5 7 8 2 3
1 4 5
5 2 4
3 2 3
1 2 3

output :
23
```

----


#### 🚀point

1. 다익스트라로 각 지점에서 다른 노드까지의 최단거리를 모두 활용한다.



#### 🔎풀이

1. 입력값을 받고, 다익스트라 함수를 작성한다.
   1. 다익스트라 함수는 start 노드가 주어졌을 때, 해당 노드로부터 다른 모든 노드까지의 최소거리를 나타내는 distance 배열을 구하는 것이 목적이다.
   
1. 각 지역을 순회하면서 다익스트라 함수를 실행하고, 해당 지역에서 얻을 수 있는 아이템의 개수를 구한다.
   1. 다익스트라 함수를 통해 구해진 distance를 순회하면서 수색범위 이하의 거리만큼 떨어진 곳들의 인덱스를 구한다.
   
   1. 해당 지역의 아이템 개수를 임시 변수에 더해놓는다.
   
   1. 최종적으로 해당 아이템 개수들 중 가장 높은 수를 구한다.
   

#### 💻코드

```python
import sys
import heapq
input = sys.stdin.readline

def dijkstra(start) :
    queue = []
    heapq.heappush(queue, (start,0))
    # 출발지에서 출발지까지는 거리가 0
    distance[start] = 0

    while queue :
    # 출발지에서 가장 가까운 노드와 거리
        target,dist = heapq.heappop(queue)
		
        # 만약, 거리가 이미 구해진 거리보다 길다면 패스
        if distance[target] < dist :
            continue
		
        # 목적지를 거쳐 가는 다른 노드까지의 거리를 구한다
        for i in graph[target] :
            # 목적지까지의 거리 + 목적지부터 다른 노드까지의 거리
            cost = dist+i[1]
            # 만약 그 값이 기존 출발노드에서 바로 가는 거리보다 짧다면
            if cost < distance[i[0]]:
                # 바꿔준다.
                distance[i[0]] = cost
                # 더 이어진 노드까지의 거리를 구하기 위해 queue에 추가해준다.
                # 이때, 거리를 방금 구한 최소거리로 한다.
                heapq.heappush(queue, (i[0],cost))

n,m,r = map(int,input().split())
items = list(map(int,input().split()))
graph = [[] for _ in range(n+1)]
for _ in range(r):
    a,b,l = map(int,input().split())
    heapq.heappush(graph[a],(b,l))
    heapq.heappush(graph[b],(a, l))

res = 0
for area in range(1,n+1):
    distance = [int(1e9)]*(n+1)
    dijkstra(area)
    tmp = 0
    # 거리 중 탐색 범위보다 짧은 거리인 곳이라면
    for d in range(1,n+1):
        if distance[d]<=m:
            # 임시변수에 그 곳의 아이템 개수를 더해준다.
            tmp += items[d-1]
    # 최종적으로 res 값과 비교하여 갱신해준다.
    if res < tmp :
        res = tmp

print(res)
```



#### ❌ 발생 오류 및 해결

- 
