## 🐌 알고리즘 문제 풀이

### Baekjoon_5014. 스타트링크

#### 📒문제

> 강호는 코딩 교육을 하는 스타트업 스타트링크에 지원했다. 오늘은 강호의 면접날이다. 하지만, 늦잠을 잔 강호는 스타트링크가 있는 건물에 늦게 도착하고 말았다.
>
> 스타트링크는 총 F층으로 이루어진 고층 건물에 사무실이 있고, 스타트링크가 있는 곳의 위치는 G층이다. 강호가 지금 있는 곳은 S층이고, 이제 엘리베이터를 타고 G층으로 이동하려고 한다.
>
> 보통 엘리베이터에는 어떤 층으로 이동할 수 있는 버튼이 있지만, 강호가 탄 엘리베이터는 버튼이 2개밖에 없다. U버튼은 위로 U층을 가는 버튼, D버튼은 아래로 D층을 가는 버튼이다. (만약, U층 위, 또는 D층 아래에 해당하는 층이 없을 때는, 엘리베이터는 움직이지 않는다)
>
> 강호가 G층에 도착하려면, 버튼을 적어도 몇 번 눌러야 하는지 구하는 프로그램을 작성하시오. 만약, 엘리베이터를 이용해서 G층에 갈 수 없다면, "use the stairs"를 출력한다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/5014)



#### :pushpin: 입력 및 출력

- 첫째 줄에 F, S, G, U, D가 주어진다. (1 ≤ S, G ≤ F ≤ 1000000, 0 ≤ U, D ≤ 1000000) 건물은 1층부터 시작하고, 가장 높은 층은 F층이다.

- 첫째 줄에 강호가 S층에서 G층으로 가기 위해 눌러야 하는 버튼의 수의 최솟값을 출력한다. 만약, 엘리베이터로 이동할 수 없을 때는 "use the stairs"를 출력한다.


---

> 예시

```
input :
10 1 10 2 1

output :
6

input :
100 2 1 1 0

output :
use the stairs
```

----




#### 🚀point

1. bfs로 계산하되 몇번째 순회 과정인지 함께 구한다.

   



#### 🔎풀이

1. 방문 여부와 몇번째에 방문한 것인지 확인할 수 있는 배열 생성

1. 순회하면서 층 조건에 맞고 방문한 적이 없다면 방문 처리 후 이전 층의 횟수 + 1을 해준다.

   

#### 💻코드

```python
from collections import deque
import sys
input = sys.stdin.readline


def bfs(queue) :

    global visited

    while queue :
        cf = queue.popleft()
        if cf == G :
            return

        for i in (U,-D) :
            nf = cf+i
            if 0<nf<=F and visited[nf] == 0 :
                visited[nf] = 1
                counted[nf] = counted[cf]+1
                queue.append(nf)

F,S,G,U,D = map(int,input().split())

# 방문 여부를 판단할 배열
visited = [0] * (F+1)
# n번째 층에는 몇번만에 도착했는지 확인
# 출발지가 목적지일 경우를 대비해서 -1로 설정
counted = [-1] * (F+1)

start = deque([S])

# 방문처리 및 counted를 0으로 초기화
visited[S] = 1
counted[S] = 0
bfs(start)
# 방문한 적이 없다는 뜻이므로 엘리베이터 이용 불가
if counted[G] == -1 :
    print('use the stairs')
else :
    print(counted[G])
```



#### ❌ 발생 오류 및 해결

- bfs를 재귀로 돌리는 방법을 썼었는데 메모리 초과 오류가 발생
