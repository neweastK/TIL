## 🐌 알고리즘 문제 풀이

### Baekjoon_15684. 사다리 조작

#### 📒문제

> 사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다. 인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15684/1.png)
>
> 초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15684/2.png)
>
> 위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다.
>
> 사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.
>
> 위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다.
>
> | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15684/3.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15684/4.png) |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 1번 세로선                                                   | 2번 세로선                                                   |
>
> 사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/15684)



#### :pushpin: 입력 및 출력

- 첫째 줄에 세로선의 개수 N, 가로선의 개수 M, 세로선마다 가로선을 놓을 수 있는 위치의 개수 H가 주어진다. (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)

  둘째 줄부터 M개의 줄에는 가로선의 정보가 한 줄에 하나씩 주어진다.

  가로선의 정보는 두 정수 a과 b로 나타낸다. (1 ≤ a ≤ H, 1 ≤ b ≤ N-1) b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결했다는 의미이다.

  가장 위에 있는 점선의 번호는 1번이고, 아래로 내려갈 때마다 1이 증가한다. 세로선은 가장 왼쪽에 있는 것의 번호가 1번이고, 오른쪽으로 갈 때마다 1이 증가한다.

  입력으로 주어지는 가로선이 서로 연속하는 경우는 없다.

- i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야 하는 가로선 개수의 최솟값을 출력한다. 만약, 정답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다.


---

> 예시

```
input :
2 0 3

output :
0

input :
2 1 3
1 1

output :
1

input :
5 5 6
1 1
3 2
2 3
5 1
5 4

output :
3

input :
6 5 6
1 1
3 2
1 3
2 5
5 5

output :
3

input :
5 8 6
1 1
2 2
3 3
4 4
3 1
4 2
5 3
6 4

output :
-1
```



----




#### 🚀point

1. itertools의 combinations를 이용하여 사다리를 추가할 수 있는 모든 경우의 수 구하기
1. 사다리 연결 및 이동 과정을 배열로 구현



#### 🔎풀이

1.  먼저 사다리 연결과 이동 과정을 어떻게 정의할 것인지 정한다.
    1.  사다리를 가로로 눕혀놓는다는 생각으로 이중리스트 구현
    2.  왼쪽 맨 위 == N=1,H=1이고 오른쪽 아래로 갈 수록 증가

2.  입력값을 받고 연결 여부를 표시한다
    1.  시작점은 1로 끝점은 2로 표시하여 왼쪽으로 갈지 오른쪽으로 갈지 정하도록 한다
    2.  나중에 추가할 수 있는 사다리 위치를 최소화하기 위해 사다리의 접점을 -1로 표시한다
    3.  1로 표시된 곳의 왼쪽(위)를 -1로 표시한다

3.  사다리 이동 과정을 구현한 함수를 정의한다
    1.  시작점과 배열을 입력값으로 받고 최종 도착지점이 시작점과 같다면 True를 반환한다

4.  입력값을 받은 후 초기 입력값이 정답이 될 수 있는지 3번의 함수로 체크한다
5.  불가능 할 경우 사다리를 조작해야하므로 조작 과정으로 넘어간다
6.  먼저 배열을 순회하면서 아직 0 (아무 사다리도 없고 사다리를 놓아도 되는 곳)인 위치를 replace_area 배열에 담는다
7.  모두 담고 나서 combinations로 k 개수만큼의 사다리 위치를 뽑는다
    1.  k는 1부터 3까지 순회한다.

8.  뽑은 추가 가능한 사다리 위치들을 순회하면서 해당 위치에 사다리를 추가한다.
    1.  추가할 때는 원 배열이 망가지지 않도록 새로 할당한 후에 사다리를 추가한다.
    2.  추가한 후에 정답이 되는지 체크하고 정답일 경우 k개를 출력하고 모든 코드를 종료한다.

9.  3까지 순회하고도 정답이 안나오면 -1을 출력한다.



#### 💻코드

```python
from itertools import combinations
import sys
input = sys.stdin.readline

# 사다리 타고 이동해보기
def check_answer(maps,start_n):
    x,y = start_n,1
    # 가로선 끝까지 갈 때까지
    while y<=H:
        if maps[x][y] == 1:
            x+=1
            y+=1
        elif maps[x][y] == 2:
            x-=1
            y+=1
        else:
            y+=1
    # 출발지와 도착지가 같은 경우 true 반환
    if start_n==x:
        return True
    else:
        return False

# 사다리를 추가하고 추가했을 때, 정답이 될 수 있는지 확인
def add_ladder(maps, ladders):
    for ladder in ladders:
        aa, bb = ladder
        maps[aa][bb] = 1
        maps[aa + 1][bb] = 2
    for i in range(1, N + 1):
        if not check_answer(maps,i):
            return False
    return True

N,M,H = map(int,input().split())
maps = [[0]*(H+1) for _ in range(N+1)]

for _ in range(M):
    a,b = map(int,input().split())
    # 나중에 조작할 사다리 위치를 줄이기 위한 사전작업
    if maps[b-1][a] == 0:
        maps[b-1][a] = -1
    maps[b][a] = 1
    maps[b+1][a] = 2

# 초반 검색
first_check = True
for i in range(1,N+1):
    if not check_answer(maps,i):
        first_check = False

if first_check:
    print(0)
else:
    # 조작 가능한 곳 찾기
    replace_area = []
    # 마지막 줄에는 사다리를 어차피 추가할 수 없음(i번째 사다리면 i+1번째 사다리도 필요하기 때문)
    for n in range(1,N):
        for m in range(1,H+1):
            if maps[n][m] == 0:
                replace_area.append([n,m])
    # 조작
    # 3번까지만 수정해보면 되므로 나머지는 모두 예외처리
    for k in range(1,4):
        # combinations 으로 바꿀 수 있는 위치 경우의 수를 모두 저장
        replace_list = list(combinations(replace_area,k))
        # 반복하면서 사다리를 수정해보고 조건에 맞는지 확인
        for replace_idx in replace_list:
            tmp_maps = [map[:] for map in maps]
            res = add_ladder(tmp_maps,replace_idx)
            if res:
                print(k)
                quit()                
    print(-1)
```



#### ❌ 발생 오류 및 해결

- 

  
