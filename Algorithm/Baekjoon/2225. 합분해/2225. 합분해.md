## 🐌 알고리즘 문제 풀이

### Baekjoon_2225. 합분해

#### 📒문제

> 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.
>
> 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.
> 
>    [<문제 출처>](https://www.acmicpc.net/problem/2225)



#### :pushpin: 입력 및 출력

- 첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

- 첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

> 예시

```
input :
20 2

output :
21

input :
6 4

output :
84
```

----


#### 🚀point

1. dp를 활용한 문제 풀이



#### 🔎풀이

1. N,K에 따른 경우의 수를 기록하기 위한 이중 리스트 dp를 생성한다. (길이는 최댓값 200)

1. 점화식 도출

   1. 예시, N=4, K=4 인 경우

   1. 맨 앞의 숫자를 1로 두고 0~3까지 3개 써서 3만드는 경우의 수
      맨 앞의 숫자를 2로 두고 0~2까지 3개 써서 2만드는 경우의 수
      맨 앞의 숫자를 3으로 두고 0~1까지 3개 써서 1만드는 경우의 수
      맨 앞의 숫자를 0으로 두고 0~4까지 3개 써서 4만드는 경우의 수
      맨 앞의 숫자를 4로 두고 나머지 모두 0인 경우의 수

   1. 위 경우의 수를 모두 합한 것이 dp[4][4]

   1. 위 경우를 식으로 변형하면 다음과 같아짐

      dp[4] [4] = dp[3] [3] + dp[2] [3] + dp[1] [3] + dp[0] [3] + 1 (맨 앞의 숫자가 4인 경우)

   1. 이 식을 일반화하면 다음곽 ㅏㅌ아짐

      dp[n] [k] = dp[0] [k-1] + dp[1] [k-1] + ... + dp[n-1] [k-1] + dp[n] [k-1] +1

1. n=1 일 때와 k=1일 때, 각각의 기본값 넣어주기

1. 위 점화식에 따라 나머지 dp 배열 채우기

#### 💻코드

```python
N,K = map(int,input().split())

dp = [[0]*200 for _ in range(200)]

# N=1 일 때, 값 채우기
dp[0] = [x for x in range(1,201)]

for i in range(1,200):
    # K=1 일 때, 기본값 채우기
    dp[i][0] = 1
    for j in range(1,200):
        tmp = 0
        # 0부터 n-1까지,dp[a][k-1] 값 더해주기
        for a in range(i+1):
            tmp+=dp[a][j-1]
        # 마지막에 1 더해주고 (맨 앞의 숫자가 n인 경우), 알맞은 위치에 넣어주기
        dp[i][j] = tmp+1
# 나머지 값 구하기
print(dp[N-1][K-1]%1000000000)
```



#### ❌ 발생 오류 및 해결

- 마지막 나눗셈 안해줘서 오답 처리
