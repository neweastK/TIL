## 🐌 알고리즘 문제 풀이

### Baekjoon_13023. ABCDE

#### 📒문제

> BOJ 알고리즘 캠프에는 총 N명이 참가하고 있다. 사람들은 0번부터 N-1번으로 번호가 매겨져 있고, 일부 사람들은 친구이다.
>
> 오늘은 다음과 같은 친구 관계를 가진 사람 A, B, C, D, E가 존재하는지 구해보려고 한다.
>
> - A는 B와 친구다.
> - B는 C와 친구다.
> - C는 D와 친구다.
> - D는 E와 친구다.
>
> 위와 같은 친구 관계가 존재하는지 안하는지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/13023)



#### :pushpin: 입력 및 출력

- 첫째 줄에 사람의 수 N (5 ≤ N ≤ 2000)과 친구 관계의 수 M (1 ≤ M ≤ 2000)이 주어진다.

  둘째 줄부터 M개의 줄에는 정수 a와 b가 주어지며, a와 b가 친구라는 뜻이다. (0 ≤ a, b ≤ N-1, a ≠ b) 같은 친구 관계가 두 번 이상 주어지는 경우는 없다.

- 문제의 조건에 맞는 A, B, C, D, E가 존재하면 1을 없으면 0을 출력한다.

---

> 예시

```
input :
5 4
0 1
1 2
2 3
3 4

output :
1

input :
5 5
0 1
1 2
2 3
3 0
1 4

output :
1

input :
6 5
0 1
0 2
0 3
0 4
0 5

output :
0

input :
8 8
1 7
3 7
4 7
3 4
4 6
3 5
0 4
2 7

output :
1
```



----


#### 🚀point

1. ~~최소 신장 트리가 있는지 체크~~
1. DFS로 순회하면서 깊이가 5 이상이 되면 조건에 충족하는 것이므로 정답 출력

   

#### 🔎풀이

1.  입력값을 받고 단방향 연결이 아니므로 연결을 나타내는 배열에 양방향으로 연결 표시를 한다
1.  5명이 연이어 친구가 되어있는지 확인하기 위한 dfs 함수를 정의한다.
    1.  시작 지점, 연결 개수, 방문 배열을 인자로 받는다
    1.  시작 지점과 연결되어 있는 노드들을 순회한다.
        1.  만약, 그 노드가 아직 방문하지 않은 상태라면 그 노드를 시작점으로 하는 새로운 dfs 함수를 재귀로 호출한다.
        1.  방문처리와 연결 개수는 인자값에 더해준다. (최대 깊이까지 탐색한 후에 돌아왔을 때, 원래 방문배열과 연결 개수를 유지하기 위해)
        1.  만약 연결 개수가 5개 이상이라면 전역 변수인 res 값을 1로 변경해준다.

1.  2번의 dfs 함수를 각 노드를 시작점으로 해서 한번씩 돌려본다.
    1.  중간에 res 값이 바뀌었다면, 즉, 이미 5명이 연결되어 있는 것을 확인했다면 반복을 중지하고 res 값을 출력한다.
    1.  만약 어떤 노드를 시작점으로 해도 5명이 이어져있지 않다면 원래의 res값인 0을 출력한다.


#### 💻코드

```python
def dfs(start,cnt,visited):
    global res
    if cnt >= 4:
        res = 1
        return
    else:
        # start에 연결된 애들
        for node in maps[start]:
            if node not in visited:
                dfs(node,cnt+1,visited+[node])

N,M = map(int,input().split())
maps = [[] for _ in range(N)]
res = 0
for _ in range(M):
    a,b = map(int,input().split())
    maps[a].append(b)
    maps[b].append(a)

for i in range(N):
    dfs(i,0,[i])
    if res == 1:
        break
print(res)
```



#### ❌ 발생 오류 및 해결

- 최소 신장 트리를 활용하려다 실패
  - 조상이 같으나 연이어 연결되어있지 않은 경우가 있음
  - ex) 1번 노드가 중심이 되고 나머지 4개의 노드가 1번 노드하고만 연결되어 있을 때
- 시작점을 달리한 경우를 생각하지 않아서 오답처리
- 시작점마다 다른 visited 배열을 담아야하는데 그렇지 않아서 오답처리
