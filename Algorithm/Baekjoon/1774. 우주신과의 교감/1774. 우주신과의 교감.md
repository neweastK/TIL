## 🐌 알고리즘 문제 풀이

### Baekjoon_1774. 우주신과의 교감

#### 📒문제

> 황선자씨는 우주신과 교감을 할수 있는 채널러 이다. 하지만 우주신은 하나만 있는 것이 아니기때문에 황선자 씨는 매번 여럿의 우주신과 교감하느라 힘이 든다. 이러던 와중에 새로운 우주신들이 황선자씨를 이용하게 되었다.
>
> 하지만 위대한 우주신들은 바로 황선자씨와 연결될 필요가 없다. 이미 황선자씨와 혹은 이미 우주신끼리 교감할 수 있는 우주신들이 있기 때문에 새로운 우주신들은 그 우주신들을 거쳐서 황선자 씨와 교감을 할 수 있다.
>
> 우주신들과의 교감은 우주신들과 황선자씨 혹은 우주신들 끼리 이어진 정신적인 통로를 통해 이루어 진다. 하지만 우주신들과 교감하는 것은 힘든 일이기 때문에 황선자씨는 이런 통로들이 긴 것을 좋아하지 않는다. 왜냐하면 통로들이 길 수록 더 힘이 들기 때문이다.
>
> 또한 우리들은 3차원 좌표계로 나타낼 수 있는 세상에 살고 있지만 우주신들과 황선자씨는 2차원 좌표계로 나타낼 수 있는 세상에 살고 있다. 통로들의 길이는 2차원 좌표계상의 거리와 같다.
>
> 이미 황선자씨와 연결된, 혹은 우주신들과 연결된 통로들이 존재한다. 우리는 황선자 씨를 도와 아직 연결이 되지 않은 우주신들을 연결해 드려야 한다. 새로 만들어야 할 정신적인 통로의 길이들이 합이 최소가 되게 통로를 만들어 “빵상”을 외칠수 있게 도와주자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1774)



#### :pushpin: 입력 및 출력

- 첫째 줄에 우주신들의 개수(N<=1,000) 이미 연결된 신들과의 통로의 개수(M<=1,000)가 주어진다.

  두 번째 줄부터 N개의 줄에는 황선자를 포함하여 우주신들의 좌표가 (0<= X<=1,000,000), (0<=Y<=1,000,000)가 주어진다. 그 밑으로 M개의 줄에는 이미 연결된 통로가 주어진다. 번호는 위의 입력받은 좌표들의 순서라고 생각하면 된다. 좌표는 정수이다.

- 첫째 줄에 만들어야 할 최소의 통로 길이를 출력하라. 출력은 소수점 둘째짜리까지 출력하여라.



---

> 예시

```
input :
4 1
1 1
3 1
2 3
4 3
1 4

output :
4.00
```

----




#### 🚀point

1. 최소 신장 트리를 만들었을 때의 가중치 구하기
1. 두 좌표 간의 거리 구하기 + 소숫점 설정하기
1. 이미 연결된 좌표가 입력값으로 주어질 때 중복이 될 수 있음
   1. (a,b)와 (b,a)가 입력값으로 올 수 있다는 뜻






#### 🔎풀이

1.  union-find 알고리즘의 find와 union 함수 정의
1.  입력값을 받고 각 노드의 부모 노드를 나타내는 parents 배열 생성
1.  N만큼 반복하면서 좌표값 받기
    1.  받은 좌표값은 따로 리스트에 저장
    1.  순회하면서 parents 배열값 갱신
        1.  자기 자신의 부모값을 자신으로 지정

1.  M만큼 반복하면서 이미 연결된 노드들의 정보 받기
    1.  만약 두 노드가 아직 연결되지 않은 상태라면, union함수 사용하여 연결

1.  edges 배열을 생성하여, 모든 노드 간의 거리 계산 후 삽입
    1.  a,b,cost 형식으로 삽입
    1.  모든 값을 삽입 후에는 edges 배열을 cost 기준으로 정렬

1.  edges 배열을 반복하면서 아직 연결 안된 노드들을 연결해줌
    1.  이때, 연결해줄 때 거리를 cost로 하여 누적합 계산

1.  모든 노드들이 연결됐다면, 그 떄의 가중치 출력
1.  누적합을 소숫점 2자리까지 반올림하여 출력
    1.  이때, 4.00 같은 경우 4.0으로 출력되므로 format을 이용하여 소수점 두자리까지 출력




#### 💻코드

```python
import sys
input = sys.stdin.readline

def find_parent(x):
    if parents[x] != x:
        parents[x] = find_parent(parents[x])
        return parents[x]
    return x

def union(a,b):
    a = find_parent(a)
    b = find_parent(b)

    if a>b:
        parents[a] = b
    else:
        parents[b] = a

N,M = map(int,input().split())
parents = [0]*(N+1)
# 좌표값을 담아놓는 배열
locations = [(0,0)]*(N+1)

for i in range(1,N+1):
    # 자기 자신의 부모는 자기 자신으로 우선 설정
    parents[i] = i
    # 입력받은 좌표 
    locations[i] = list(map(int,input().split()))

# 이미 연결된 노드들에 관한 정보 받기
for _ in range(M):
    a,b = map(int,input().split())
    # 만약, 아직 두 노드가 연결되지 않았다면!
    if find_parent(a) != find_parent(b):
        union(a,b)

# 모든 노드간의 거리 구하기
edges = []
for n in range(1,N+1):
    for i in range(n,N+1):
            cost = (locations[n][0]-locations[i][0])**2 + (locations[n][1]-locations[i][1])**2
            edges.append((n,i,cost**0.5))

# 정렬 필수!!            
edges.sort(key=lambda x:x[-1])
res = 0
for edge in edges:
    a,b,cost = edge
    # 아직 연결이 안됐다면
    if find_parent(a) != find_parent(b):
        union(a,b)
        # 연결 후, 거리값 더해주기
        res+=cost
# 둘째자리까지 반올림
ans = round(res,2)
# 둘째자리까지 출력
print(f"{ans:.2f}")
```



#### ❌ 발생 오류 및 해결

- 소숫점 2자리까지 반올림은 했는데 출력할 때, 소수점 부분이 0일 경우 한자리만 나오는 오류 발견
- 입력값이 중복이 될 수 있다는 점을 간과함
