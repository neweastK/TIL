## 🐌 알고리즘 문제 풀이

### Baekjoon_7569. 토마토

#### 📒문제

> 철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.
>
> ![img](https://upload.acmicpc.net/c3f3343d-c291-40a9-9fe3-59f792a8cae9/-/preview/)
>
> 창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.
>
> 토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/7569)



#### :pushpin: 입력 및 출력

- 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.

  토마토가 하나 이상 있는 경우만 입력으로 주어진다.
  
- 여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.


---

> 예시

```
input :
5 3 1
0 -1 0 0 0
-1 -1 0 1 1
0 0 0 1 1

output :
-1

input :
5 3 2
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0

output :
4

input :
4 3 2
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
-1 -1 -1 -1
1 1 1 -1

output :
0
```

----




#### 🚀point

1. 델타 탐색시 4방향이 아닌 6방향으로 고려한다.
1. 높이 즉, 층이 있는 그래프를 배열로 표현할 때는 3중 리스트를 활용한다.
   - arr\[x]\[y][z] 는 x층에 있는 y,z 좌표를 뜻한다.
   - x값만 다르고 y,z 가 같다면 서로 다른 층의 같은 좌표를 뜻함
1. 최종적으로 몇번만에 모든 작업을 마쳤는지 알아야하므로 방문 배열에 이전 위치의 값 + 1 을 표시해준다.




#### 🔎풀이

1. 토마토의 위치 정보를 입력받아 배열을 생성한다.

1. 토마토 위치 배열을 한번 순회하면서, 비어있는 곳의 개수와 최초로 토마토가 위치한 곳의 좌표를 찾는다.
   - 최초로 토마토가 위치한 곳은 bfs에서 활용하기 위해 queue에 담는다.

1. bfs 함수를 실행 전에 모든 토마토가 이미 익었는지 확인한다.
   - 전체 칸의 개수 중 비어있는 곳의 개수를 빼면 모든 토마토의 개수
   - 만약 전체 토마토의 개수와 queue에 들어간 토마토 위치들의 개수가 같다면 이미 다 익은 것이므로 함수를 종료한다.

1. bfs 함수를 실행한다.
   1. 6방향을 탐색하고, 탐색 위치에 안 익은 토마토가 있다면, 익었다는 표시를 토마토 배열에 해준다.
   1. 그 후, 방문 배열에 몇번째 순회 중인지 표시한다.
   1. 그리고, 해당 토마토에서 또 탐색을 시작하도록 queue에 해당 토마토의 위치를 삽입한다.
   1. 마지막으로 해당 탐색 숫자가 가장 큰 숫자인지 확인하고 추후 최대 탐색 횟수를 출력하기 위한 maximum 값을 갱신한다.

1. 실행 후 모든 토마토가 익었다면 최대 탐색 횟수를 익지 않았다면 -1을 출력한다.



#### 💻코드

```python
from collections import deque
import sys
input = sys.stdin.readline

def bfs(queue) :
    maximum = 0
    while queue:
        sh,si,sj = queue.popleft()

        for d in range(6):
            nh = sh+dh[d]
            ni = si+di[d]
            nj = sj+dj[d]

            if 0<=nh<H and 0<=ni<N and 0<=nj<M and maps[nh][ni][nj]==0:
                maps[nh][ni][nj] = 1
                visited[nh][ni][nj] = visited[sh][si][sj] + 1
                queue.append([nh,ni,nj])
                maximum = max(maximum,visited[nh][ni][nj])
    return maximum


M,N,H = map(int,input().split())
maps = [[list(map(int,input().split())) for _ in range(N)] for _ in range(H)]
visited = [[[0]*M for _ in range(N)] for _ in range(H)]

dh = [1,-1,0,0,0,0]
di = [0,0,1,-1,0,0]
dj = [0,0,0,0,1,-1]

queue = deque([])
E = 0
for i in range(H):
    for j in range(N):
        for k in range(M):
            if maps[i][j][k] == 1 :
                visited[i][j][k] = 1
                queue.append([i,j,k])
            elif maps[i][j][k] == -1 :
                # 빈 공간의 개수
                E += 1

answer = 0
# 모든 토마토의 개수
tomatos = H*M*N-E
# 모든 토마토가 익었다면
if len(queue) == tomatos :
    answer = 0
else :
    total = 0
    # maximum 탐색 횟수
    res = bfs(queue)
    # 최종적으로 갱신된 maps를 돌면서 익은 토마토의 개수를 센다
    for a in range(H):
        for b in range(N):
            total += sum(maps[a][b])
    # 다 익었다면 (total+E 인 이유는 위에서 sum으로 토마토의 개수를 셀 때, E만큼 한번 더 뺄셈이 되기 때문 )
    if total+E == tomatos :
        answer = res-1
    # 다 익지 않았다면
    else :
        answer = -1

print(answer)
```



#### ❌ 발생 오류 및 해결

- 마지막에 토마토가 다 익었는지 확인하는 과정에서 오류 발생
  - sum으로 각 배열의 합을 계산할 경우, 비어있는 곳은 -1이기 때문에 익은 토마토들의 개수에서 비어있는 곳의 위치를 한번 더 빼주는 꼴이 되버린다.

  - 따라서, 계산 후에 비어있는 곳의 위치를 한번 더 더해줘야만, 순수 익은 토마토들의 개수만을 얻을 수 있다.
