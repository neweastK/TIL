## 🐌 알고리즘 문제 풀이

### Baekjoon_19238. 스타트 택시

#### 📒문제

> 스타트링크가 "스타트 택시"라는 이름의 택시 사업을 시작했다. 스타트 택시는 특이하게도 손님을 도착지로 데려다줄 때마다 연료가 충전되고, 연료가 바닥나면 그 날의 업무가 끝난다.
>
> 택시 기사 최백준은 오늘 M명의 승객을 태우는 것이 목표이다. 백준이 활동할 영역은 N×N 크기의 격자로 나타낼 수 있고, 각 칸은 비어 있거나 벽이 놓여 있다. 택시가 빈칸에 있을 때, 상하좌우로 인접한 빈칸 중 하나로 이동할 수 있다. 알고리즘 경력이 많은 백준은 특정 위치로 이동할 때 항상 최단경로로만 이동한다.
>
> M명의 승객은 빈칸 중 하나에 서 있으며, 다른 빈칸 중 하나로 이동하려고 한다. 여러 승객이 같이 탑승하는 경우는 없다. 따라서 백준은 한 승객을 태워 목적지로 이동시키는 일을 M번 반복해야 한다. 각 승객은 스스로 움직이지 않으며, 출발지에서만 택시에 탈 수 있고, 목적지에서만 택시에서 내릴 수 있다.
>
> 백준이 태울 승객을 고를 때는 현재 위치에서 최단거리가 가장 짧은 승객을 고른다. 그런 승객이 여러 명이면 그중 행 번호가 가장 작은 승객을, 그런 승객도 여러 명이면 그중 열 번호가 가장 작은 승객을 고른다. 택시와 승객이 같은 위치에 서 있으면 그 승객까지의 최단거리는 0이다. 연료는 한 칸 이동할 때마다 1만큼 소모된다. 한 승객을 목적지로 성공적으로 이동시키면, 그 승객을 태워 이동하면서 소모한 연료 양의 두 배가 충전된다. 이동하는 도중에 연료가 바닥나면 이동에 실패하고, 그 날의 업무가 끝난다. 승객을 목적지로 이동시킨 동시에 연료가 바닥나는 경우는 실패한 것으로 간주하지 않는다.
>
> ![img](https://upload.acmicpc.net/b4dfd78f-5276-44a4-a1f1-a5ccde6fbc8b/-/preview/)
>
> <그림 1>
>
> <그림 1>은 택시가 활동할 영역의 지도를 나타내며, 택시와 세 명의 승객의 출발지와 목적지가 표시되어 있다. 택시의 현재 연료 양은 15이다. 현재 택시에서 각 손님까지의 최단거리는 각각 9, 6, 7이므로, 택시는 2번 승객의 출발지로 이동한다.
>
> | ![img](https://upload.acmicpc.net/3a0360d0-7aa4-4f6e-89aa-8f29ceb3db8d/-/preview/)<그림 2> | ![img](https://upload.acmicpc.net/fb1d41e5-a420-4957-8fe8-1a6f822b284e/-/preview/)<그림 3> |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> |                                                              |                                                              |
>
> <그림 2>는 택시가 2번 승객의 출발지로 가는 경로를, <그림 3>은 2번 승객의 출발지에서 목적지로 가는 경로를 나타낸다. 목적지로 이동할 때까지 소비한 연료는 6이고, 이동하고 나서 12가 충전되므로 남은 연료의 양은 15이다. 이제 택시에서 각 손님까지의 최단거리는 둘 다 7이므로, 택시는 둘 중 행 번호가 더 작은 1번 승객의 출발지로 이동한다.
>
> | ![img](https://upload.acmicpc.net/a4ad059c-f909-4cf2-a401-9d72a69a2549/-/preview/)<그림 4> | ![img](https://upload.acmicpc.net/3abc49bb-33a3-4828-a6c3-1be22fd3967d/-/preview/)<그림 5> |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> |                                                              |                                                              |
>
> <그림 4>와 <그림 5>는 택시가 1번 승객을 태워 목적지로 이동시키는 경로를 나타낸다. 남은 연료의 양은 15 - 7 - 7 + 7×2 = 15이다.
>
> | ![img](https://upload.acmicpc.net/86aa0566-f468-4343-a83d-d978f0120cec/-/preview/)<그림 6> | ![img](https://upload.acmicpc.net/aebc9d40-2c56-4e6c-b914-d8d9b55f8ff5/-/preview/)<그림 7> |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> |                                                              |                                                              |
>
> <그림 6>과 <그림 7>은 택시가 3번 승객을 태워 목적지로 이동시키는 경로를 나타낸다. 최종적으로 남은 연료의 양은 15 - 5 - 4 + 4×2 = 14이다.
>
> 모든 승객을 성공적으로 데려다줄 수 있는지 알아내고, 데려다줄 수 있을 경우 최종적으로 남는 연료의 양을 출력하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/19238)



#### :pushpin: 입력 및 출력

- 첫 줄에 N, M, 그리고 초기 연료의 양이 주어진다. (2 ≤ N ≤ 20, 1 ≤ M ≤ N2, 1 ≤ 초기 연료 ≤ 500,000) 연료는 무한히 많이 담을 수 있기 때문에, 초기 연료의 양을 넘어서 충전될 수도 있다.

  다음 줄부터 N개의 줄에 걸쳐 백준이 활동할 영역의 지도가 주어진다. 0은 빈칸, 1은 벽을 나타낸다.

  다음 줄에는 백준이 운전을 시작하는 칸의 행 번호와 열 번호가 주어진다. 행과 열 번호는 1 이상 N 이하의 자연수이고, 운전을 시작하는 칸은 빈칸이다.

  그다음 줄부터 M개의 줄에 걸쳐 각 승객의 출발지의 행과 열 번호, 그리고 목적지의 행과 열 번호가 주어진다. 모든 출발지와 목적지는 빈칸이고, 모든 출발지는 서로 다르며, 각 손님의 출발지와 목적지는 다르다.

- 모든 손님을 이동시키고 연료를 충전했을 때 남은 연료의 양을 출력한다. 단, 이동 도중에 연료가 바닥나서 다음 출발지나 목적지로 이동할 수 없으면 -1을 출력한다. 모든 손님을 이동시킬 수 없는 경우에도 -1을 출력한다.



---

> 예시

```
input :
6 3 15
0 0 1 0 0 0
0 0 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 1 0
0 0 0 1 0 0
6 5
2 2 5 6
5 4 1 6
4 2 3 5

output :
14

input :
6 3 13
0 0 1 0 0 0
0 0 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 1 0
0 0 0 1 0 0
6 5
2 2 5 6
5 4 1 6
4 2 3 5

output :
-1

input :
6 3 100
0 0 1 0 0 0
0 0 1 0 0 0
0 0 0 1 0 0
0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 1 0 0
6 5
2 2 5 6
5 4 1 6
4 2 3 5

output :
-1
```

----




#### 🚀point

1. BFS를 활용한 각 위치간 거리 계산
1. 여러 예외처리 필요
   1. 손님이 목적지로 갈 수 없는 경우
   1. 택시가 손님에게 갈 수 없는 경우
   1. 연료가 떨어지는 경우




#### 🔎풀이

1.  전체 로직
    1.  택시와 모든 손님간의 거리를 구하고, 1순위를 찾는다
        1.  BFS 탐색이기 때문에 가장 먼저 찾는 손님을 1순위로 정할 수 있지만, 거리가 같은 경우가 있어서 모두 찾아야함

    1.  택시 - 승객 이동 연료와, 출발지 - 목적지 이동 연료를 한번에 계산한다
        1.  만약, 기존 연료에서 위 연료값을 뺀 값이 0 미만이면 이미 중간에 연료가 다 떨어졌다는 뜻

    1.  한 승객의 이동이 끝나면, 지도 상에서 해당 손님 정보를 지워주고 1-1로 반복

1.  필요한 함수와 배열을 선언한다
    1.  손님의 목적지 정보를 저장해놓을 배열
        1.  N*N 배열을 선언한다
        1.  손님의 위치에 해당하는 곳에 목적지 좌표와 출발지-목적지 간 거리를 저장한다

    1.  손님의 출발지 - 목적지 간 거리를 계산할 BFS 함수
        1.  출발지 - 목적지 이동이 불가한 경우 FALSE 반환

    1.  택시-손님 간의 거리를 계산할 또 다른 BFS 함수
        1.  모든 손님과의 거리를 계산한다
        1.  손님과 택시의 거리, 손님의 목적지 정보 확인을 위한 손님 좌표를 모두 구한다
        1.  그 중 거리가 가장 짧고, 거리가 같다면 행이 제일 낮은, (이후엔 열이 가장 낮은) 손님 정보를 반환한다
        1.  한명이라도 택시-손님 간 이동이 불가한 경우 FALSE 반환

1.  모든 입력값을 받는다
    1.  손님 정보를 받을 때, 한번에 받지 않고 반복문으로 하나씩 받는다
    1.  지도 배열상에 손님이 있다는 표시를 한다 (2로 표시, bfs 탐색시 조건 분기를 위해)
    1.  해당 손님의 출발지-목적지 거리를 계산한다
        1.  만약, 이동 불가라면 -1 출력하고 모든 코드 종료

    1.  목적지 정보 배열에 필요한 값들을 저장한다

1.  손님 수만큼 반복하며 한번씩 한명의 손님을 이동시킨다
    1.  우선 택시와 가장 가까운 손님을 BFS 함수를 통해 얻는다
        1.  만약, 이동 불가한 손님이라면 -1 출력 후 코드 종료

    1.  목적지 배열을 통해 목적지 좌표와 목적지까지의 거리를 구한다
        1.  목적지 좌표는 마지막에 택시 위치를 갱신시켜주기 위함

    1.  손님을 이동시켰으므로 지도 배열에 손님 정보(2로 표시되어있음)를 초기화시켜준다
    1.  이동 후 남은 기름량을 계산한다
        1.  만약, 0보다 작다면 -1 출력 후 종료

    1.  손님을 이동시켰고, 연료가 중간에 떨어지지 않았으므로 출발지-목적지 소요 연료의 두배만큼 충전해준다
    1.  택시 위치를 갱신한다
    1.  다시 반복한다

1.  마지막으로 남은 기름량을 출력한다 



#### 💻코드

```python
from collections import deque
import heapq
import sys
input = sys.stdin.readline

# 1.고객 출발지 - 도착지간 거리
# 고객 출발지 - 도착지가 벽에 막혀 못가는 경우
def get_distance(start,target):
    # 방문처리를 나타낼 배열
    visited_dist = [[0]*N for _ in range(N)]
    queue = deque([start])
    visited_dist[start[0]][start[1]] = 1

    while queue:
        sx,sy = queue.popleft()

        for d in range(4):
            nx,ny = sx+delta_x[d],sy+delta_y[d]
			
            # 범위에 벗어나지 않고, 벽이 아닌 경우
            if 0<=nx<N and 0<=ny<N and maps[nx][ny] != 1:
                # 방문한 적이 없거나, 더 짧은 경로로 온 경우
                if visited_dist[nx][ny] == 0 or visited_dist[nx][ny] > visited_dist[sx][sy]+1:
                    visited_dist[nx][ny] = visited_dist[sx][sy]+1
                    queue.append((nx,ny))
                    # 만약, 해당 위치가 목적지라면 이동 가능하다는 뜻이므로 목적지까지의 거리 반환 후 함수 종료
                    if (nx,ny) == target:
                        return visited_dist[nx][ny]-1
    # 함수가 종료되지 않았으므로 이동 불가 = False 반환
    return False


# 2.택시-승객간 최단거리 구하기(BFS)
# 택시 자리에 손님이 있는 경우
def bfs(x,y):
    # 손님들의 정보를 담을 배열
    passengers = []
    # 방문처리 배열
    visited = [[0] * N for _ in range(N)]
    # 처음 위치 방문처리
    visited[x][y] = 1

    # 시작점이 손님이라면
    if maps[x][y] == 2:
        heapq.heappush(passengers, [0, x, y])

    queue = deque([(x,y)])

    while queue:
        sx,sy = queue.popleft()

        for d in range(4):
            nx,ny = sx+delta_x[d], sy+delta_y[d]

            # 범위 안에 있고, 벽이 아니고, 방문한 적이 없다면 탐색
            if 0<=nx<N and 0<=ny<N and maps[nx][ny] != 1:
                # 방문한적이 없거나 더 최단거리라면
                if visited[nx][ny]==0 or visited[nx][ny]>visited[sx][sy]+1:
                    # 방문처리
                    visited[nx][ny] = visited[sx][sy]+1
                    # 손님이라면
                    if maps[nx][ny] == 2:
                        # 먼저 태울 승객 조건에 맞추기위해 heapq 사용
                        # 거리, 행 좌표, 열 좌표 순으로 삽입
                        heapq.heappush(passengers,[visited[nx][ny]-1,nx,ny])
                    queue.append((nx,ny))
    # 태울 수 있는 손님이 있다면
	if passengers:
        # 가장 1순위 손님 정보만 반환
        res = heapq.heappop(passengers)
        return res
    # 태울 수 있는 손님이 없다면
    else:
        # 종료
        return False

N,M,oil = map(int,input().split())
maps = [list(map(int,input().split())) for _ in range(N)]

# 지도 상에서의 이동을 위한 델타
delta_x = [0,0,1,-1]
delta_y = [1,-1,0,0]

# 손님들의 목적지 좌표를 담을 배열
target_info = [[0]*N for _ in range(N)]

# 택시 위치
tmp_taxi_x, tmp_taxi_y = list(map(int,input().split()))
taxi = [tmp_taxi_x-1,tmp_taxi_y-1]

# 출발지 위치, 목적지 위치
for k in range(M):
    x1,y1,x2,y2 = map(int,input().split())
    # 지도상에 손님 정보 표시
    maps[x1-1][y1-1] = 2
    # 출발지 - 도착지 간 거리 계산
    distance = get_distance((x1-1,y1-1),(x2-1,y2-1))
    
    # 만약 출발지-도착지 간 이동이 불가하다면 코드 종료
    if distance == False:
        print(-1)
        quit()
    
    # 이동이 가능하다면, 목적지 배열에 승객 목적지 좌표와 거리 저장
    target_info[x1-1][y1-1] = (x2-1,y2-1,distance)


# 손님 수만큼 반복하며 한명씩 이동
for _ in range(M):
    # 가장 우선순위 손님 정보 가져오기
    passenger = bfs(taxi[0],taxi[1])
    # 단 한명의 손님한테도 갈 수 없다면, 함수 종료
    if passenger == False:
        print(-1)
        break
    # 택시-손님간 거리와, 손님 위치
    taxi_start_dist,start_x,start_y = passenger
    # 손님 위치를 활용하여 목적지 정보 구하기
    target_x,target_y,start_target_dist = target_info[start_x][start_y]
    # 손님 이동 처리
    maps[start_x][start_y] = 0
	
    # 기름량 계산
    oil -= (taxi_start_dist+start_target_dist)
    # 중간에 기름이 떨어졌다면 -1 출력 후 종료
    if oil<0:
        print(-1)
        break
    # 아니라면 기름 충전 및 택시 위치 갱신    
    else:
        oil+=2*start_target_dist
        taxi = [target_x,target_y]
# 모든 손님을 이동시켰다면 남은 기름량 출력
else:
    print(oil)
```



#### ❌ 발생 오류 및 해결

- BFS 함수에서 시작값 방문처리를 하지 않아서 오답처리
- 손님과 택시가 겹치는 경우, 손님이 출발지-목적지 이동 불가한 경우를 예외처리하지 않아 오답 처리
- 개선사항
  - BFS 탐색 시, 더 짧은 경로로 온 경우는 생각하지 않아도됨 (BFS이기 때문)
