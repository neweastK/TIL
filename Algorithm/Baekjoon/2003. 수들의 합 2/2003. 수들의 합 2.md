## 🐌 알고리즘 문제 풀이

### Baekjoon_2003. 수들의 합 2

#### 📒문제

> N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2003)

#### :pushpin: 입력 및 출력

- 첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.
- 첫째 줄에 경우의 수를 출력한다.


---

> 예시

```
input :
4 2
1 1 1 1

output :
3

input :
10 5
1 2 3 4 2 5 3 1 1 2

output :
3
```

----




#### 🚀point

1. 몇가지 예외 조건을 잘 처리하여야함




#### 🔎풀이

1. i부터 j까지의 범위이므로 i를 시작점으로 잡고 i+(N-i)까지 즉, i부터 끝까지 각 합을 구한다.

1. 각, 합이 M이 되는 순간 더 이상 다음 숫자를 탐색해도 의미가 없으므로 cnt를 더해주고 반복문을 종료한다.

   (다음 i를 탐색)

1. 단, i가 이미 M인 경우, 즉, i부터 i까지의 합이 M인 경우에는 j 반복을 돌리지 않고 break 한다

1. i에서 i+x 까지 더한 값이 M보다 작으면 i에서 i+x+1 까지 더하고 그래도 작으면 i+x+2 까지 더해보는 식으로 계속 진행한다.

1. 그렇게 총 개수를 탐색하면 끝


#### 💻코드

```python
import sys
input = sys.stdin.readline

N,M = map(int,input().split())

arr = list(map(int,input().split()))

cnt = 0
for i in range(N):
    start = arr[i]

    if start == M :
        cnt+=1
        continue
    tmp = start
    for j in range(i+1,N):
        tmp += arr[j]
        if tmp>M :
            break
        elif tmp == M :
            cnt += 1
            break
print(cnt)
```



#### ❌ 발생 오류 및 해결

- TMP 배열을 만들지 않아서, 두번째 칸 이후의 값을 구할 때 첫번째 칸이 바뀐 상태에서 값을 계산해버려서 오류 발생
