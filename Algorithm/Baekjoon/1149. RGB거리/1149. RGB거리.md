## 🐌 알고리즘 문제 풀이

### Baekjoon_1149. RGB거리

#### 📒문제

> RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
>
> 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.
> 
>    - 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
>    - N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
>    - i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
>    
>    [<문제 출처>](https://www.acmicpc.net/problem/1149)



#### :pushpin: 입력 및 출력

- 첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

- 첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.




---

> 예시

```
input :
3
26 40 83
49 60 57
13 89 99

output :
96

input :
3
1 100 100
100 1 100
100 100 1

output :
3

input :
3
1 100 100
100 100 100
1 100 100

output :
102

input :
6
30 19 5
64 77 64
15 19 97
4 71 57
90 86 84
93 32 91

output :
208

input :
8
71 39 44
32 83 55
51 37 63
89 29 100
83 58 11
65 13 15
47 25 29
60 66 19

output :
253
```

----




#### 🚀point

1. DP 활용
1. 이전의 계산된 값들은 절대 변경하지 않도록 해보자!



#### 🔎풀이

1.  조건을 우선 확인한다.
    1.  조건 3개는 결국 i-2, i-1, i 가 모두 같은 색이면 안된다는 뜻

1.  dp 배열에 어떤 값을 담을지 정의한다.
    1.  현재의 위치에서 선택한 색에 따른 최솟값
    1.  현재 집을 색칠할 때 이전 집의 색깔만 영향을 준다.
        1.  즉, 두번째 전 집은 무슨 색이든 전혀 상관이 없다.

    1.  따라서, dp에는 이전값을 활용하여 지금 집에서 칠하는 색에 따른 최솟값을 기록한다.

1.  따라서, 열의 개수는 빨,초,파 3개, 행의 개수는 집의 수만큼 지정하여 빈 배열을 만든다.
1.  초기값을 설정해준다. 
    1.  dp 배열의 0번째 인덱스, 즉 첫번째 집은 따로 계산할 필요 없이 해당 값이 최솟값이다.

1.  반복문으로 순회하며 각 집에서 각 색을 칠했을 때의 최솟값을 구해준다.
    1.  빨강색 자리에는 
        **이전 집에 초록색을 칠했을 때의 비용 + 현재 집에 빨강색을 칠했을 때 비용** 과
        **이전 집에 파랑색을 칠했을 때의 비용 + 현재 집에 빨강색을 칠했을 때 비용** 을 비교하여 더 작은 값을 넣어준다. (빨강 빨강 연속으로 칠할수는 없으므로)
    1.  초록색 자리에는 
        **이전 집에 빨강색을 칠했을 때의 비용 + 현재 집에 초록색을 칠했을 때 비용** 과
        **이전 집에 파랑색을 칠했을 때의 비용 + 현재 집에 초록색을 칠했을 때 비용** 을 비교하여 더 작은 값을 넣어준다. 
    1.  파랑색 자리에도 위와 마찬가지로 넣어준다.

1.  최종적으로 완성된 dp 코드의 마지막 행 중 가장 작은 값을 출력한다.

#### 💻코드

```python
N = int(input())
arr = []
for i in range(N):
    arr.append(list(map(int,input().split())))

dp = [[0]*3 for _ in range(N)]
dp[0] = arr[0][:]

for j in range(1,N):
    dp[j][0] = dp[j-1][1]+arr[j][0] if dp[j-1][1] < dp[j-1][2] else dp[j-1][2]+arr[j][0]
    dp[j][1] = dp[j-1][0]+arr[j][1] if dp[j-1][0] < dp[j-1][2] else dp[j-1][2]+arr[j][1]
    dp[j][2] = dp[j-1][0]+arr[j][2] if dp[j-1][0] < dp[j-1][1] else dp[j-1][1]+arr[j][2]
print(min(dp[N-1]))
```



#### ❌ 발생 오류 및 해결

- 
