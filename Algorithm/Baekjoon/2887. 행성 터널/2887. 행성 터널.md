## 🐌 알고리즘 문제 풀이

### Baekjoon_2887. 행성 터널

#### 📒문제

> 때는 2040년, 이민혁은 우주에 자신만의 왕국을 만들었다. 왕국은 N개의 행성으로 이루어져 있다. 민혁이는 이 행성을 효율적으로 지배하기 위해서 행성을 연결하는 터널을 만들려고 한다.
>
> 행성은 3차원 좌표위의 한 점으로 생각하면 된다. 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.
>
> 민혁이는 터널을 총 N-1개 건설해서 모든 행성이 서로 연결되게 하려고 한다. 이때, 모든 행성을 터널로 연결하는데 필요한 최소 비용을 구하는 프로그램을 작성하시오.
> 
> [<문제 출처>](https://www.acmicpc.net/problem/2887)



#### :pushpin: 입력 및 출력

- 첫째 줄에 행성의 개수 N이 주어진다. (1 ≤ N ≤ 100,000) 다음 N개 줄에는 각 행성의 x, y, z좌표가 주어진다. 좌표는 -109보다 크거나 같고, 109보다 작거나 같은 정수이다. 한 위치에 행성이 두 개 이상 있는 경우는 없다. 

- 첫째 줄에 모든 행성을 터널로 연결하는데 필요한 최소 비용을 출력한다.




---

> 예시

```
input :
5
11 -15 -15
14 -5 -15
-1 -1 -5
10 -4 -1
19 -4 19

output :
4
```

----




#### 🚀point

1. 최소 신장 트리의 비용을 구하는 문제

2. 어떻게 하면 최소 신장 트리에서의 탐색을 최소화 할 것인가?

   == 어떻게 간선을 최소화 시킬 것인가?



#### 🔎풀이

1.  최소 신장 트리를 구하기 위한 find 함수와 union 함수 생성
1.  입력값 N과 행성들의 정보 받기
1.  ~~간선 구하기 (간선을 담을 edges 배열 생성)~~
    1.  각 행성별로 만들 수 있는 모든 간선 생성
    1.  x,y,z중 가장 작은 값으로 생성 (문제 조건에 따라)
    1.  메모리 초과 발생
    
1.  간선 재설정
    1.  문제 조건을 잘 보면 x,y,z 중 가장 짧은 것 하나만 사용
    1.  또한, 최소신장트리는 어차피 가장 짧은 간선을 사용
    1.  a,b 행성을 연결할 수 있는 M개의 간선이 있다 하더라도 가장 짧은 1개만 필요
    1.  원래라면 a행성에서 b,c,d,e... 모든 행성을 연결하는 간선을 찾았겠지만, 가장 짧은 것만 사용하면 되므로 간선을 다르게 설정
    1.  x,y,z 위치 좌표들을 각각 서로 다른 배열에 행성 번호와 함께 append
    1.  x,y,z 배열을 각각 정렬
        1.  그러면, x좌표 기준 특정 행성 a와 a와 가장 가까운 b, b와 가장 가까운 c 순으로 배열이 정렬됨
        1.  y,z좌표 역시도 위와 같이 정렬됨
        1.  그러면 a행성과 x기준 가장 가까운 행성의 거리, y기준 가장 가까운 행성의 거리, z기준 가장 가까운 행성의 거리를 알 수 있게됨

    1.  간선의 개수는 N-1개만 필요하므로, N-1만큼 반복하면서 필요한 간선 사용
        1.  단, x기준이 가장 짧은지, y기준이 가장 짧은지, z기준이 가장 짧은지는 모르기 때문에 3개 모두 탐색
        1.  a행성과 b 행성을 연결하는 cost 값을 edges배열에 append
            1.  a행성에서 가장 가까운 b 행성까지의 cost

1.  parent 배열 초기화 (모두 자기 자신을 가리키도록)
1.  간선을 정렬해주고, union, find 함수를 사용해서 MST 최소 비용 계산
    1.  이미 연결되어 있다면 pass, 연결되어있지 않다면 연결 후 비용 추가




#### 💻코드

```python
import sys
input = sys.stdin.readline

def find_parents(x):
    if x!=parents[x]:
        parents[x] = find_parents(parents[x])
        return parents[x]
    return x

def union(a,b):
    a = find_parents(a)
    b = find_parents(b)

    if a>b:
        parents[a] = b
    else:
        parents[b] = a

N = int(input())

planets = [list(map(int,input().split())) for _ in range(N)]
edges = []
x = []
y = []
z = []

for i in range(len(planets)):
    x.append((planets[i][0],i))
    y.append((planets[i][1],i))
    z.append((planets[i][2],i))

x.sort()
y.sort()
z.sort()

for j in range(1,N):
    edges.append((x[j][0]-x[j-1][0],x[j-1][1],x[j][1]))
    edges.append((y[j][0]-y[j-1][0],y[j-1][1],y[j][1]))
    edges.append((z[j][0]-z[j-1][0],z[j-1][1],z[j][1]))


parents = [0]*N
for p in range(N):
    parents[p] = p

res = 0

edges.sort()
for edge in edges:
    cost,a,b = edge
    # 연결되어있지 않다면
    if find_parents(a) != find_parents(b):
        # 연결해주고
        union(a,b)
        res += cost

print(res)
```



#### ❌ 발생 오류 및 해결

- 탐색하는 간선의 길이가 너무 많아서 메모리 초과 발생
  - 탐색할 간선의 수 최소화 하기
