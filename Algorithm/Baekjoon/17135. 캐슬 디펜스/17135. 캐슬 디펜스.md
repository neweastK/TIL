## 🐌 알고리즘 문제 풀이

### Baekjoon_17135. 캐슬 디펜스

#### 📒문제

> 캐슬 디펜스는 성을 향해 몰려오는 적을 잡는 턴 방식의 게임이다. 게임이 진행되는 곳은 크기가 N×M인 격자판으로 나타낼 수 있다. 격자판은 1×1 크기의 칸으로 나누어져 있고, 각 칸에 포함된 적의 수는 최대 하나이다. 격자판의 N번행의 바로 아래(N+1번 행)의 모든 칸에는 성이 있다.
>
> 성을 적에게서 지키기 위해 궁수 3명을 배치하려고 한다. 궁수는 성이 있는 칸에 배치할 수 있고, 하나의 칸에는 최대 1명의 궁수만 있을 수 있다. 각각의 턴마다 궁수는 적 하나를 공격할 수 있고, 모든 궁수는 동시에 공격한다. 궁수가 공격하는 적은 거리가 D이하인 적 중에서 가장 가까운 적이고, 그러한 적이 여럿일 경우에는 가장 왼쪽에 있는 적을 공격한다. 같은 적이 여러 궁수에게 공격당할 수 있다. 공격받은 적은 게임에서 제외된다. 궁수의 공격이 끝나면, 적이 이동한다. 적은 아래로 한 칸 이동하며, 성이 있는 칸으로 이동한 경우에는 게임에서 제외된다. 모든 적이 격자판에서 제외되면 게임이 끝난다. 
>
> 게임 설명에서 보다시피 궁수를 배치한 이후의 게임 진행은 정해져있다. 따라서, 이 게임은 궁수의 위치가 중요하다. 격자판의 상태가 주어졌을 때, 궁수의 공격으로 제거할 수 있는 적의 최대 수를 계산해보자.
>
> 격자판의 두 위치 (r1, c1), (r2, c2)의 거리는 |r1-r2| + |c1-c2|이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/17135)



#### :pushpin: 입력 및 출력

- 첫째 줄에 격자판 행의 수 N, 열의 수 M, 궁수의 공격 거리 제한 D가 주어진다. 둘째 줄부터 N개의 줄에는 격자판의 상태가 주어진다. 0은 빈 칸, 1은 적이 있는 칸이다.

- 첫째 줄에 궁수의 공격으로 제거할 수 있는 적의 최대 수를 출력한다.



---

> 예시

```
input :
5 5 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1

output :
3

input :
5 5 2
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
1 1 1 1 1
0 0 0 0 0

output :
5

input :
5 5 5
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1

output :
15

input :
6 5 2
1 0 1 0 1
0 1 0 1 0
1 1 0 0 0
0 0 0 1 1
1 1 0 1 1
0 0 1 0 0

output :
14
```

----




#### 🚀point

1. 동시에 일어나는 일을 어떻게 구현할 것인가?!



#### 🔎풀이

1.   combinations를 활용하여 궁수가 위치할 수 있는 모든 경우의 수를 구한다
1.  모든 경우의 수를 순회하면서 각각의 경우에 따른 제거할 수 있는 적의 수를 구한다
    1.  배열을 순회하면서, 적이 있는 경우 각 궁수와의 최단거리를 구한다
    1.  그 중 최솟값이면서, D보다 작은 경우의 적의 위치를 따로 저장한다
    1.  만약, 거리가 같으면 더 왼쪽에 있는 적을 제거대상으로 삼는다

1.  반복문을 다 돌면, 궁수 3명이 이번 턴에 제거할 수 있는 적들의 위치를 알 수 있다
1.  배열을 한번 더 순회하면서 제거 대상의 적들을 제거해준다
    1.  제거 대상이 아니라면 한칸 아래로 이동시켜준다
        1.  이때, 적이 아직 남아있다는 것을 알아야하므로 tmp_cnt 변수에 1을 더해준다
        1.  tmp_cnt 변수가 0이면 적이 없다는 뜻이므로 반복문을 중지한다

    1.  이를 위해 반복문을 순회할 때 뒤에서부터 순회하도록 한다
        1.  왜냐하면, 위에서부터 하면 밑에있는 정보가 갱신되어버리므로 올바른 정답이 나오지 않을 것

    1.  제거 대상의 적들을 제거하면서 카운트해준다

1.  최종적으로 가장 큰 cnt값을 ans 변수에 할당해 ans 변수를 출력한다



#### 💻코드

```python
import sys
from itertools import combinations
input = sys.stdin.readline

# 거리 측정
def distance(x1,y1,x2,y2):
    distance = abs(x1-x2)+abs(y1-y2)
    return distance

N,M,D = map(int,input().split())

arr_original = [list(map(int,input().split())) for _ in range(N)]
enemies = []
# 성과 궁수가 위치할 공간
arr_original.append([0]*M)

# 가능한 모든 궁수 위치의 경우
arrows = list(combinations(range(M),3))
ans = 0

# 가능한 궁수 위치를 순회하며 각각의 제거할 수 있는 적의 수 계산
for arrow in arrows:
    tmp_cnt = 1
    # 입력값 복사
    arr = [x[:] for x in arr_original]
    cnt = 0
    while tmp_cnt:
        target = []
        # 궁수 한명이 제거할 수 있는 적 구하기
        for a in arrow:
            player = [N,a]
            player_dist = 999999
            tmp = []
            
            # 배열 순회
            for i in range(N):
                for j in range(M):
                    if arr[i][j] == 1:
                        # 현재 궁수와 적의 거리
                        dist = distance(N,a,i,j)
						
                        # 거리가 최소이면서 D 이하인 경우
                        if dist<player_dist and dist<=D:
                            player_dist = dist
                            tmp = [i,j]
                        # 만약 거리가 같으면, 더 왼쪽에 있는 적을 제거
                        elif dist==player_dist:
                            if tmp[1]>j:
                                tmp = [i,j]
			
            # 제거할 수 있는 적이 있다면 target 배열에 append
            if tmp:
                target.append(tmp)
		# 결과적으로 target에는 궁수 3명이 제거할 수 있는 적들의 위치가 있음
        # tmp_cnt는 적이 남아있는지 없는지 판단할 변수
        tmp_cnt = 0
        
        # 거꾸로 순회하면서
        for ni in range(N-1,-1,-1):
            for nj in range(M-1,-1,-1):
                # 만약 target에 있는 즉, 제거대상인 적이면
                if [ni,nj] in target:
                    # 제거
                    arr[ni][nj] = 0
                    # 수 세기
                    cnt += 1
				
                # 만약 target에는 없는데 적이라면 위치변경
                if arr[ni][nj] == 1:
                    # 한칸 아래로
                    arr[ni+1][nj] = 1
                    # 원래 위치는 적이 없음 (이동했으므로)
                    arr[ni][nj] = 0
                    # 아직 적이 남아있으므로 tmp_cnt를 1 이상으로 만들어줌
                    tmp_cnt += 1

    if ans<cnt:
        ans = cnt
print(ans)
```



#### ❌ 발생 오류 및 해결

- 동시에 발생해야하는 일이 많아서 초기 방법 실패
  - 적들을 모두 리스트에 담고 그 안에서 거리 조건이 맞으면 순회하면서 pop 메서드를 사용하려 했음
  - but, pop을 하면 계속해서 인덱스가 바뀌는 바람에 엉뚱한 값이 삭제되며 오답 처리됨
