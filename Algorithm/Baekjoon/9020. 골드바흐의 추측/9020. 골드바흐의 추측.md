## 🐌 알고리즘 문제 풀이

### Baekjoon_9020. 골드바흐의 추측



#### 📒문제

> 1보다 큰 자연수 중에서  1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.
>
> 골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.
>
> 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/9020)



#### :pushpin: 입력 및 출력

- 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.
- 각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.

---

> 예시

​	입력		 출력

​	3			  3 5
​	8			  5 5
​	10			5 11
​	16		

----




#### 🚀point

1. 즉, 합이 입력값이 되는 두 소수를 구하는 것

1. 단, 두 소수의 차이가 가장 적어야한다.

   == 입력값//2 부터 찾는 것이 가장 빠르다.
   


#### 🔎풀이 계획

1. 초기 계획
   1. 모든 입력값을 받은 후 최댓값까지의 소수를 구한다.
   1. 이후 각 입력값에 맞는 합을 찾아본다.
      1. 소수값들을 순회하면서 (입력값-첫번째 소수값)이 있는지 체크하는 식으로 구한다.
      1. 있으면 두 소수의 차를 만들어놓고 다른 경우의 수도 찾아본다.
      1. 가장 차가 적은 소수 두개를 출력한다.

1. 검색 후 수정
   1. 입력값//2 결과값을 기준으로 시작한다. ex) 입력값이 30이면 15+15부터 시작
   1. 두 수가 모두 소수인지 체크하고 아니라면, 하나의 수는 -1, 나머지 수는 +1을 한다.
   1. 두 수가 모두 소수인 경우를 찾으면 바로 출력한다.


```python
import sys

# 골드바흐 파티션 출력하는 함수
def gold(target_number):
    # 소수인지 판별하는 함수
    def checking(number):
        for i in range(1, int(number ** 0.5) + 1):
            if i == 1:
                continue
            if number % i == 0:
                return False
        else:
            return True
    # 어차피 입력값은 모두 짝수이기 때문에 2로 나눈 숫자부터 시작해도 문제 없음
    a = int(target_number // 2)
    b = int(target_number // 2)
    while True:
        # 두 수가 모두 소수인 경우를 찾는다
        if checking(a) and checking(b):
            return [a, b]
        # 아닌 경우, a는 -1, b는 +1 해준다
        else:
            a -= 1
            b += 1

T = int(sys.stdin.readline())

for tc in range(T):
    number = int(sys.stdin.readline())
    ans = gold(number)
    print(*ans)
```



#### ❌ 발생 오류 및 해결

- 시간 초과 오류 발생
  - pypy로 진행하면 해결은 되지만, 확실한 방법을 알기 위해 검색 진행
  - 정답들과 내 코드 차이점
    - 처음부터 끝까지 모든 경우의 수를 찾아보려고 했음
    - 소수 리스트를 소수값이 아닌 인덱스를 기준으로 하는 True/False 리스트를 만들어줌
      - 인덱스로 해당 값이 소수인지 아닌지 확인하도록함

- 새로 배운 소수 판별법
  - 2부터 입력값**0.5 까지의 소수들을 순회하면서, 본인을 제외한 해당 소수의 배수들을 모두 False로 처리한다. 
  - 루트까지만 확인하면 되는 이유 
    - 만약, 2부터 49까지의 숫자들 중 소수만 골라내고 싶다고 해보자
    - 2,3,5,7 의 배수들을 모두 제거한다. 그러면 소수인 값만 남는다.
    - why?) 49의 제곱근은 7이다. 따라서, 7 이상은 확인할 필요가 없다.
      - 왜냐하면, 7\*2,7\*3,7\*5 등은 이미 제거되었기 때문.
      - 그러면 7*7만 확인하면 된다(그 이상은 범위가 아니므로)


