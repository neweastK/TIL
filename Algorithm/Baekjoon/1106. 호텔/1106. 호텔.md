## 🐌 알고리즘 문제 풀이

### Baekjoon_1106. 호텔

#### 📒문제

> 세계적인 호텔인 형택 호텔의 사장인 김형택은 이번에 수입을 조금 늘리기 위해서 홍보를 하려고 한다.
>
> 형택이가 홍보를 할 수 있는 도시가 주어지고, 각 도시별로 홍보하는데 드는 비용과, 그 때 몇 명의 호텔 고객이 늘어나는지에 대한 정보가 있다.
>
> 예를 들어, “어떤 도시에서 9원을 들여서 홍보하면 3명의 고객이 늘어난다.”와 같은 정보이다. 이때, 이러한 정보에 나타난 돈에 정수배 만큼을 투자할 수 있다. 즉, 9원을 들여서 3명의 고객, 18원을 들여서 6명의 고객, 27원을 들여서 9명의 고객을 늘어나게 할 수 있지만, 3원을 들여서 홍보해서 1명의 고객, 12원을 들여서 4명의 고객을 늘어나게 할 수는 없다.
>
> 각 도시에는 무한 명의 잠재적인 고객이 있다. 이때, 호텔의 고객을 적어도 C명 늘이기 위해 형택이가 투자해야 하는 돈의 최솟값을 구하는 프로그램을 작성하시오.
> 
> [<문제 출처>](https://www.acmicpc.net/problem/1106)



#### :pushpin: 입력 및 출력

- 첫째 줄에 C와 형택이가 홍보할 수 있는 도시의 개수 N이 주어진다. C는 1,000보다 작거나 같은 자연수이고, N은 20보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각 도시에서 홍보할 때 대는 비용과 그 비용으로 얻을 수 있는 고객의 수가 주어진다. 이 값은 100보다 작거나 같은 자연수이다.

- 첫째 줄에 문제의 정답을 출력한다.


---

> 예시

```
input :
12 2
3 5
1 1

output :
8

input :
10 3
3 1
2 2
1 3

output :
4

input :
10 10
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
10 10

output :
10

input :
100 6
4 9
9 11
3 4
8 7
1 2
9 8

output :
45
```

----




#### 🚀point

1. DP를 활용하여 문제 풀이




#### 🔎풀이

1.  입력값을 모두 받고, dp 배열을 생성한다
    1.  dp 배열은 i번 도시까지 탐색했을 때, 원하는 만큼의 사람 수를 얻기 위한 비용을 나타냄

1.  dp[1] 값. 즉, 첫번째 도시는 다른 도시값에 영향을 받지 않으므로 초기 설정 필요
    1.  원하는 수를 얻기 위해 필요한 투자 수를 구하고 투자 비용에 해당 값을 곱해서 값 계산

1.  dp 배열의 나머지 값도 채워준다
    1.  기본적으로 (현재 도시를 탐색한다 vs 안한다) 중 비용이 더 낮은 것을 선택한다
    1.  현재 도시를 탐색하지 않는다는 것은 이전 도시까지 탐색했을 때의 비용을 그대로 받는다는 것
    1.  현재 도시를 탐색하는 것은 dp[i]\[j-현재 도시로부터 얻을 수 있는 사람] 값에 현재 도시 탐색 비용을 더한 값을 의미
    1.  2,3 중 작은 값을 채워주고 다음 값도 채워준다

1.  최종적으로 dp[N]\[C] 값을 출력한다




#### 💻코드

```python
C,N = map(int,input().split())
arr = [list(map(int,input().split())) for _ in range(N)]

# dp 배열 생성
# dp[i][j]는 i번 도시까지 탐색했을 때, j 이상의 사람을 얻고 싶다면 얼마의 비용이 필요한가를 의미
dp = [[0]*(C+1) for _ in range(N+1)]

# dp[1] 값 설정
first_value = arr[0]
for k in range(1,C+1):
    # 첫 도시는 오직 자신의 가치와 비용으로만 계산
    dp[1][k] = ((k-1)//first_value[1]+1)*first_value[0]


# dp 배열 값 채우기
for i in range(2,N+1):
    for j in range(1,C+1):
        cost,income = arr[i-1]
		# 현재 도시를 탐색한다는 가정을 할 경우, 자신의 효용을 뺀 만큼의 인덱스 탐색이 필요함
        # but, 그 경우가 안될 수 있으므로 조건문으로 분기 처리
        if j-income<0:
            # 현재 도시를 탐색하지 않거나, 자신의 가치와 비용으로 계산
            dp[i][j] = min(dp[i-1][j],((j-1)//income+1)*cost)
        # 현재 도시를 탐색하지 않는 경우, 현재 도시를 탐색하는 경우 중 비용이 덜 드는 것으로 선택
        else:
            dp[i][j] = min(dp[i-1][j],dp[i][j-income]+cost)

print(dp[N][C])
```



#### ❌ 발생 오류 및 해결

- 너무 어렵게 생각한 것 같다

- 다른 문제풀이법

  ```python
  C, N = map(int, input().split())
  arr = [list(map(int, input().split())) for _ in range(N)]
  dp = [1e9] * (C + 101)
  dp[0] = 0
  
  for cost, num in arr:
      for i in range(num, C + 100):
          dp[i] = min(dp[i], dp[i - num] + cost)
  print(min(dp[C:]))
  ```

  
