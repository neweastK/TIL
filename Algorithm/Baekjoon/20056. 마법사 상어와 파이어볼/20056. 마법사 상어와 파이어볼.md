## 🐌 알고리즘 문제 풀이

### Baekjoon_20056. 마법사 상어와 파이어볼

#### 📒문제

> [어른 상어](https://www.acmicpc.net/problem/19237)가 마법사가 되었고, 파이어볼을 배웠다.
>
> 마법사 상어가 크기가 N×N인 격자에 파이어볼 M개를 발사했다. 가장 처음에 파이어볼은 각자 위치에서 이동을 대기하고 있다. i번 파이어볼의 위치는 (ri, ci), 질량은 mi이고, 방향은 di, 속력은 si이다. 위치 (r, c)는 r행 c열을 의미한다.
>
> 격자의 행과 열은 1번부터 N번까지 번호가 매겨져 있고, 1번 행은 N번과 연결되어 있고, 1번 열은 N번 열과 연결되어 있다.
>
> 파이어볼의 방향은 어떤 칸과 인접한 8개의 칸의 방향을 의미하며, 정수로는 다음과 같다.
>
> ​				7  	0      1
> ​				6   기준   2
> ​				5  	4	  3 
>
> 마법사 상어가 모든 파이어볼에게 이동을 명령하면 다음이 일들이 일어난다.
>
> 1. 모든 파이어볼이 자신의 방향 di로 속력 si칸 만큼 이동한다.
>    - 이동하는 중에는 같은 칸에 여러 개의 파이어볼이 있을 수도 있다.
> 2. 이동이 모두 끝난 뒤, 2개 이상의 파이어볼이 있는 칸에서는 다음과 같은 일이 일어난다.
>    1. 같은 칸에 있는 파이어볼은 모두 하나로 합쳐진다.
>    2. 파이어볼은 4개의 파이어볼로 나누어진다.
>    3. 나누어진 파이어볼의 질량, 속력, 방향은 다음과 같다.
>       1. 질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋이다.
>       2. 속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋이다.
>       3. 합쳐지는 파이어볼의 방향이 모두 홀수이거나 모두 짝수이면, 방향은 0, 2, 4, 6이 되고, 그렇지 않으면 1, 3, 5, 7이 된다.
>    4. 질량이 0인 파이어볼은 소멸되어 없어진다.
>
> 마법사 상어가 이동을 K번 명령한 후, 남아있는 파이어볼 질량의 합을 구해보자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/20056)



#### :pushpin: 입력 및 출력

- 첫째 줄에 N, M, K가 주어진다.

  둘째 줄부터 M개의 줄에 파이어볼의 정보가 한 줄에 하나씩 주어진다. 파이어볼의 정보는 다섯 정수 ri, ci, mi, si, di로 이루어져 있다.

  서로 다른 두 파이어볼의 위치가 같은 경우는 입력으로 주어지지 않는다.

- 마법사 상어가 이동을 K번 명령한 후, 남아있는 파이어볼 질량의 합을 출력한다.




---

> 예시

```
input :
4 2 1
1 1 5 2 2
1 4 7 1 6

output :
8

input :
4 2 2
1 1 5 2 2
1 4 7 1 6

output :
8

input :
4 2 3
1 1 5 2 2
1 4 7 1 6

output :
0

input :
7 5 3
1 3 5 2 4
2 3 5 2 6
5 2 9 1 7
6 2 1 3 5
4 4 2 4 2

output :
9
```

----




#### 🚀point

1. 구현 문제
   1. 문제 속에 명시된 조건들을 얼마나 정확히 판단하는가의 문제






#### 🔎풀이

1.  중요 조건 확인
    1.  1번행과 N번행, 1번열과 N번열은 이어져있다
        1.  N이상으로 이동시 처리 방법에 대한 명시
        1.  N 이상 인덱스로 이동시 1로 돌아온다는 뜻

    1.  파이어볼이 한 위치에 여러개면 합친 후에 나눠야함
        1.  질량은 모두 합한 뒤 5로 나눈 **몫**
        1.  속도는 모두 합한 뒤 개수로 나눔
        1.  방향은 모두 짝수이거나 모두 홀수면 0,2,4,6 아니면 1,3,5,7

1.  필요한 정보 확인
    1.  이동을 위한 델타 배열 (0번부터 7번까지)
    1.  이동시켰을 때, 해당 위치의 정보(몇개의 파이어볼, 질량의 합, 속도의 합, 파이어볼의 방향들)
    1.  이동시킬 파이어볼 목록

1.  K번 이동이므로 한번 이동할 때의 로직을 구현  후 K번 반복한다
    1.  파이어볼의 이동 결과를 기록할 visited 배열 생성
        1.  각 위치는 4개의 값을 가짐
        1.  해당 위치에 있는 파이어볼의 개수, 파이어볼 질량들의 합, 파이어볼 속도들의 합, 방향들

    1.  파이어볼은 queue를 활용해 하나씩 이동시킴
    1.  먼저 새로운 위치를 찾아줌
        1.  파이어볼의 방향을 참고하여 델타 활용
        1.  이때, visited배열의 길이가 N이지만, 위치는 1부터 시작하므로 1씩 빼줘야함

    1.  새로운 위치로의 이동 처리
        1.  visited 배열에 새로운 값 갱신
        1.  해당 위치의 파이어볼 개수에 1 더해주기
        1.  해당 위치의 파이어볼 질량합과 속도합에 각각 더해주기
        1.  방향들을 나타내는 배열에 방향값 추가해주기

    1.  모든 파이어볼에 위 작업 반복
    1.  파이어볼을 다 이동시켰으면 파이어볼을 4개로 나눠야함
        1.  특정 위치에 파이어볼이 1개뿐인 경우 합할 필요가 없으므로 그대로 fireballs 배열에 추가
        1.  파이어볼이 2개 이상인 경우 4개로 나눠주기
            1.  합해놓은 질량값은 5로 나눠서 각 질량값 구하기
            1.  속도값은 개수로 나눠서 속도값 구하기
            1.  방향은 모두 같은 조건(짝수 or 홀수)인지 확인한 후 0,2,4,6 혹은 1,3,5,7 할당

        1.  4개로 나눠주는데 이 때, 방향은 모두 다른 값을 가지므로 반복문 활용
            1.  질량값과 속도값은 모두 같고, 방향만 달리해서 fireballs 배열에 넣어주기
            1.  K번 이동후 남은 파이어볼들이 최종적으로 배열에 담겨있음

1.  K번 반복 후 남아있는 파이어볼들의 질량값 합해서 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline
from collections import deque

N,M,K = map(int,input().split())
dx = [-1,-1,0,1,1,1,0,-1]
dy = [0,1,1,1,0,-1,-1,-1]

fireballs = deque([list(map(int,input().split())) for _ in range(M)])

for _ in range(K):
    visited = [[[0,0,0,[]] for _ in range(N)] for _ in range(N)]
    while fireballs:
        r,c,m,s,d = fireballs.popleft()
        # 1. 새로운 위치 찾기
        nr = ((r-1)+s*dx[d])%N
        nc = ((c-1)+s*dy[d])%N

        # 2. 이동처리(새로운 위치 확인)
        visited[nr][nc][0] += 1
        visited[nr][nc][1] += m
        visited[nr][nc][2] += s
        visited[nr][nc][3].append(d)

    # fireball 나누기
    for i in range(N):
        for j in range(N):
            now = visited[i][j]
            
            # 해당 위치에 파이어볼이 하나만 있는 경우
            if now[0] == 1:
                fireballs.append([i+1,j+1,now[1],now[2],now[3][0]])

            # 해당 위치에 파이어볼이 2개 이상있는 경우 합쳐서 다시 나눠야함
            elif now[0] > 1:
                # 나눠진 파이어볼의 질량
                nm = now[1]//5
                # 만약 질량이 0이면 4개로 나눌 필요 없음
                if nm == 0:
                    continue
                #새로운 속도
                ns = now[2]//now[0]
                # 새로운 방향을 정하기 위한 임시배열
                tmp = [0]*now[0]
                nd = [0,2,4,6]
                # 전부다 짝수이거나 홀수인지 판단
                for d in range(now[0]):
                    tmp[d] = now[3][d]%2
                    if d>=1:
                        # 하나라도 다르면
                        if tmp[d-1] != tmp[d]:
                            nd = [1,3,5,7]
                            break
                # 4개로 나누기
                for new in range(4):
                    fireballs.append([i+1,j+1,nm,ns,nd[new]])


res = sum(list(map(lambda x:x[2],fireballs)))
print(res)
```



#### ❌ 발생 오류 및 해결

- 질량값이 0일때 조건을 따로 주지 않아서 오답 처리
  - 0인 값을 안 없애주면 개수는 올라가버리기 때문에 질량값들이 나눠짐 (속도값도 마찬가지)
  - 문제에도 제거하라고 나와있음
