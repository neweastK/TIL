## 🐌 알고리즘 문제 풀이

### Baekjoon_4195. 친구 네트워크

#### 📒문제

> 민혁이는 소셜 네트워크 사이트에서 친구를 만드는 것을 좋아하는 친구이다. 우표를 모으는 취미가 있듯이, 민혁이는 소셜 네트워크 사이트에서 친구를 모으는 것이 취미이다.
>
> 어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.
> 
>    친구 네트워크란 친구 관계만으로 이동할 수 있는 사이를 말한다.
>    
>    [<문제 출처>](https://www.acmicpc.net/problem/4195)



#### :pushpin: 입력 및 출력

- 첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스의 첫째 줄에는 친구 관계의 수 F가 주어지며, 이 값은 100,000을 넘지 않는다. 다음 F개의 줄에는 친구 관계가 생긴 순서대로 주어진다. 친구 관계는 두 사용자의 아이디로 이루어져 있으며, 알파벳 대문자 또는 소문자로만 이루어진 길이 20 이하의 문자열이다.

- 친구 관계가 생길 때마다, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.


---

> 예시

```
input :
2
3
Fred Barney
Barney Betty
Betty Wilma
3
Fred Barney
Betty Wilma
Barney Betty

output :
2
3
4
2
2
4
```

----




#### 🚀point

1. union-find를 통해 친구 간의 연결관계를 나타낸다
1. 노드 번호라는 개념이 없기 때문에 각 사람별 고유 번호를 부여한다
1. 몇명과 연결되어 있는지 어떻게 알 것인가?!
   - 특히, 1번부터 4번이 있다 했을 때, 1번-2번 / 3번 - 4번 / 2번 - 3번 순으로 연결 정보가 주어진다면 그 때는?
   - => 연결되어 있는 친구의 수를 나타내는 number 배열을 생성하여 사용한다



#### 🔎풀이

1.  find 함수와 union 함수를 정의한다.
    1.  이때, union 함수에서는 연결된 친구의 수를 추가해주는 로직도 구현한다.
    1.  해당 친구가 표시하고 있던 수를 합해지는 기준점이 되는 수에 더해준다.

1.  노드 (친구) 정보는 번호가 아닌 이름으로 되어있기 때문에 번호로 표현할 수 있도록 객체를 만들어준다
    1.  각 친구의 조상 노드와 연결되어있는 친구 수를 표시할 parent, number 배열을 생성해준다.
    1.  N의 최댓값은 100,000 이고, 2명씩 나타내기 때문에 최댓값은 200,000이 된다.
    1.  parent는 자기 자신으로 number은 초기에 연결된 친구는 본인 한명이므로 1로 설정해준다.

1.  N만큼 순회하면서, 입력값을 받고 입력값에 속한 두 친구가 아직 등록이 안되어있다면 person 객체에 등록을 해줘서 노드 번호를 부여한다.
    1.  노드 번호를 부여한 후, 서로의 연결여부를 확인한다.
    1.  연결이 되어있으면 둘 중 한명이 몇명과 연결되어 있는지 출력한다.
    1.  연결이 안되어있다면 연결 한 후, 더 작은 값을 받은 다음에 해당 값의 친구 연결 수를 확인한다.




#### 💻코드

```python
import sys
input = sys.stdin.readline

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
        return parent[x]
    return x

def union(a,b):
    a = find(a)
    b = find(b)

    if a>b:
        parent[a] = b
        # point!! 친구가 몇명인지 값 부여
        number[b] += number[a]
        return b
    else:
        parent[b] = a
        # point!! 친구가 몇명인지 값 부여
        number[a] += number[b]
        return a

T = int(input())

for _ in range(T):
    N = int(input())
    person = {}
    idx = 0
    
    parent = [0] * 200000
    for i in range(200000):
        parent[i] = i

    number = [1] * 200000

    for _ in range(N):
        a,b = input().split()
        if a not in person.keys():
            person[a] = idx
            idx+=1
        if b not in person.keys():
            person[b] = idx
            idx+=1

        if find(person[a]) != find(person[b]):
            res = union(person[a],person[b])
        else :
            res = find(person[b])
        print(number[res])
```



#### ❌ 발생 오류 및 해결

- 몇명의 친구와 연결되어 있는지 확인할 방법을 떠올리지 못해 블로그 참고

  - 새로운 배열을 만들어버림

  

