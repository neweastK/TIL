## 🐌 알고리즘 문제 풀이

### Baekjoon_11725. 트리의 부모 찾기

#### 📒문제

> 루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/11725)



#### :pushpin: 입력 및 출력

- 첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.

- 첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.

---

> 예시

```
input :
7
1 6
6 3
3 5
4 1
2 4
4 7
output :
4
6
1
3
1
4

input :
12
1 2
1 3
2 4
3 5
3 6
4 7
4 8
5 9
5 10
6 11
6 12
output :
1
1
2
3
3
4
4
5
5
6
6
```

----


#### 🚀point

1.  dfs를 활용하되 부모노드를 기록할 배열 생성

#### 🔎풀이

1. 노드간 연결관계를 정의한다.
   
1. dfs 탐색을 하면서 자식노드들을 만나면 해당 자식노드의 부모노드를 바로바로 기록한 후에 stack에 자식노드를 추가한다.
   

#### 💻코드

```python
N = int(input())
maps = [[]*(N+1) for _ in range(N+1)]

# 노드간 연결관계 정의
for _ in range(N-1):
    a,b = map(int,input().split())
    maps[a].append(b)
    maps[b].append(a)
    
# 부모 노드를 정의할 배열 생성
connections = [[] for _ in range(N+1)]

# 방문 여부 확인용 배열
visited = [False]*(N+1)

# 1이 루트 노드이므로 1부터 탐색 시작
stack = [1]
visited[1] = True

# 1번 노드부터 자식노드 찾기
while stack :
    i = stack.pop()
    # i번 노드의 자식노드들 탐색
    for m in maps[i]:
        # 방문 했다면. 즉, 이미 부모 노드가 파악됐다면 넘어가고 아니면 부모노드 찾기
        if visited[m] == False :
            # 방문처리
            visited[m] = True
            # m번 노드의 부모노드는 i
            connections[m] = i
            # m의 자식노드를 탐색하기 위해 m append
            stack.append(m)

for connection in connections[2:]:
    print(connection)
```



#### ❌ 발생 오류 및 해결

- stack 구조를 활용한 dfs에 대한 이해도 부족
  - for문을 break할 필요가 없었는데 계속 break하려해서 오류 발생
  - break를 하지 않아도 되는 이유
    - stack은 뒤에서부터 출력되기 때문에, 앞에 상위 노드가 많이 들어가있어도 결국 지금 탐색하고 있는 노드의 자식노드들을 가장 먼저 탐색함
