## 🐌 알고리즘 문제 풀이

### Baekjoon_11053. 가장 긴 증가하는 부분 수열

#### 📒문제

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/11053)



#### :pushpin: 입력 및 출력

- 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

- 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.





---

> 예시

```
input :
6
10 20 10 30 20 50

output :
4
```

----




#### 🚀point

1. dp로 LIS를 구하는 방법과 이분탐색으로 구하는 방법이 있음



#### 🔎풀이

1.  이분탐색으로 풀었을 때
    
1.  주어진 입력값들을 모두 받는다
    
1.  LIS의 길이를 구하기 위한 빈 배열을 생성하고 입력된 배열의 가장 첫번째 값을 넣는다
    
1.  원본 배열을 순회하면서 생성된 빈 배열의 맨 마지막값과 원본 배열 값을 비교한다
    1.  만약, 원본 배열값이 더 크다면 생성한 빈 배열에 append 한다

    1.  만약, 원본 배열값이 더 작다면 원본 배열값이 들어갈 위치를 찾는다
        1.  이때, 시간을 줄이기 위해 이분탐색을 사용한다
    
        1.  만약, 원본 배열값이 mid 값보다 크다면, mid보다 앞에 있어야하므로 end 값을 바꿔준다
    
        1.  만약, 원본 배열값이 mid 값보다 작다면, mid 보다 뒤에 있어야하므로 start 값을 바꿔준다
    
    1.  끝까지 순회해서 원본 배열값이 들어갈 수 있는 위치를 찾는다
    
1.  생성한 빈 배열 중 반환된 위치에 원본배열값을 넣는다
    
1.  최종적으로 완성된 배열의 길이를 구한다
    
1.  해당 길이가 LIS의 길이가 된다
    



#### 💻코드

```python
def bin_search(start, end, target):
    while start <= end:
        mid = (start + end) // 2
        if res[mid] > target:
            end = mid - 1
        elif res[mid] == target:
            return mid
        else:
            start = mid + 1
    return start

N = int(input())
arr = list(map(int, input().split()))
res = [arr[0]]

for a in arr:
    if a > res[-1]:
        res.append(a)
    else:
        tmp = bin_search(0, len(res), a)
        res[tmp] = a

print(len(res))
```



#### ❌ 발생 오류 및 해결

- 
