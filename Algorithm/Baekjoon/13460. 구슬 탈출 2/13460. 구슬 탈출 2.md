## 🐌 알고리즘 문제 풀이

### Baekjoon_13460. 구슬 탈출 2

#### 📒문제

> 스타트링크에서 판매하는 어린이용 장난감 중에서 가장 인기가 많은 제품은 구슬 탈출이다. 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다.
>
> 보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다. 가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다. 빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다. 게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다.
>
> 이때, 구슬을 손으로 건드릴 수는 없고, 중력을 이용해서 이리 저리 굴려야 한다. 왼쪽으로 기울이기, 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다.
>
> 각각의 동작에서 공은 동시에 움직인다. 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다. 빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다. 빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다. 또, 빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다. 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다.
>
> 보드의 상태가 주어졌을 때, 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/13460)



#### :pushpin: 입력 및 출력

- 첫 번째 줄에는 보드의 세로, 가로 크기를 의미하는 두 정수 N, M (3 ≤ N, M ≤ 10)이 주어진다. 다음 N개의 줄에 보드의 모양을 나타내는 길이 M의 문자열이 주어진다. 이 문자열은 '`.`', '`#`', '`O`', '`R`', '`B`' 로 이루어져 있다. '`.`'은 빈 칸을 의미하고, '`#`'은 공이 이동할 수 없는 장애물 또는 벽을 의미하며, '`O`'는 구멍의 위치를 의미한다. '`R`'은 빨간 구슬의 위치, '`B`'는 파란 구슬의 위치이다.

  입력되는 모든 보드의 가장자리에는 모두 '`#`'이 있다. 구멍의 개수는 한 개 이며, 빨간 구슬과 파란 구슬은 항상 1개가 주어진다.

- 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 출력한다. 만약, 10번 이하로 움직여서 빨간 구슬을 구멍을 통해 빼낼 수 없으면 -1을 출력한다.


---

> 예시

```
input :
5 5
#####
#..B#
#.#.#
#RO.#
#####

output :
1

input :
7 7
#######
#...RB#
#.#####
#.....#
#####.#
#O....#
#######

output :
5

input :
7 7
#######
#..R#B#
#.#####
#.....#
#####.#
#O....#
#######

output :
5

input :
10 10
##########
#R#...##B#
#...#.##.#
#####.##.#
#......#.#
#.######.#
#.#....#.#
#.#.#.#..#
#...#.O#.#
##########

output :
-1
```

----




#### 🚀point

1. DFS를 활용하여 보드를 기울이는 모든 경우의 수를 탐색한다
2. 최대한 탐색을 적게 할 수 있도록 조건을 설정한다
   1. 같은 방향으로 연속해서 이동하는 것은 의미 X (ex. 왼쪽-왼쪽 or 오른쪽-오른쪽)
   2. 왔다갔다 하는 것도 의미 X (ex. 왼쪽-오른쪽-왼쪽 => 왼쪽 과 결과가 같음)
   3. 특정 방향으로 기울였을 때, 구슬들에 움직임이 없다면 그 이후의 과정은 필요 X
      1. 움직임이 없는 방향으로 보드를 기울이면 최소 횟수라는 문제 조건에 안맞음

3. 어떤 구슬을 먼저 움직일 것인지도 중요
   1. 만약, 같은 열이나 행에 있을 경우, 움직임의 순서가 매우 중요해짐
   2. 따라서, 방향에 따른 순서 조건을 따로 지정





#### 🔎풀이

1.  입력값을 받고, 보드를 나타내는 배열을 생성한다
1.  구슬의 위치와 색상을 나타내는 2차원 배열 선언
    1.  2차원의 각 배열은 [구슬 색상, 행 위치, 열 위치]를 나타낸다

    1.  구슬 색상이 1인 경우에는 파랑, 0이면 빨강
    
1.  초기 구슬 위치를 갱신하기 위해 보드 배열을 순회하면서 구슬을 찾는다
1.  재귀로 모든 경로를 찾는 dfs 함수를 선언한다
    1.  매개변수는 (방향, 방문배열, 반복 횟수, 빨강 구슬이 구멍에 들어갔는지 여부, 파랑 구슬이 구멍에 들어갔는지 여부, 구슬 위치 정보) 를 받는다

    1.  중단 조건을 설정한다
        1.  빨강 구슬이 들어가고, 파랑 구슬은 아직 남아있는 경우
            1.  몇회차인지 k를 통해 확인하고, 가장 최솟값이라면 정답을 나타내는 ans 변수 갱신
    
        1.  파랑구슬이 들어간 경우
            1.  파랑 구슬이 들어간 경우에는 성공 조건에 성립되지 않음
            1.  따라서, 아무 과정 없이 return (함수 종료)
    
        1.  10번 이상 탐색한 경우 중단
    
    1.  입력된 방향에 맞게 보드를 기울이는 로직을 구현한다
        1.  방향에 따라 구슬 배열을 정렬한다
            1.  왼쪽으로 기울이면, 더 왼쪽에 있는 구슬 먼저
    
            1.  오른쪽으로 기울이면, 더 오른쪽에 있는 구슬 먼저
    
            1.  위와 같은 방법으로 위,아래도 지정해준다
    
        1.  구슬을 순회하면서 이동시킨다
            1.  이 때, 구슬이 다 순회하고 나서 원래 위치와 비교했을 때, 아무 변화도 없다면 이 움직임도 의미 없는 것이므로 함수를 종료한다
                1.  이를 위해, 구슬 순회 전에 원래 위치를 나타내는 배열을 복사한다
    
            1.  구슬은 이동하므로 원래 위치는 '.'으로 갱신한다
    
            1.  더 이상 움직일 수 없을 때까지 주어진 방향으로 이동시킨다.
                1.  그러던 도중에 구멍을 만나면 blue_in 혹은 red_in을 갱신시킨다
    
                1.  또한, 이대로 반복문을 중단하면 2-1 로직으로 인해, 함수가 종료되어버린다
                    1.  따라서, 현재 위치를 의미없는 값으로 모두 바꿔준다
    
                1.  최종적으로 더 이상 움직일 수 없게되면 최근 위치로 구슬 정보와 보드 배열을 갱신해준다
    
    1.  이동 후, 위치변화가 있는지 확인한다
        1.  있으면 넘어가고 없으면 return
    
    1.  이제 다음 기울이기로 넘어가기 위해 기울일 방향을 설정한다
        1.  최대한 탐색을 줄이기 위해 현재 방향에 맞게 기울일 방향을 정한다
    
        1.  만약, 현재 좌우로 기울였다면 다음은 상하로만 기울일 수 있다 [point 부분 참조](#🚀point)
    
    1.  그리고 기울일 수 있는 방향만큼 반복하면서 함수를 재귀호출한다
        1.  이때, 반복문 내부에서 구슬 배열이나 보드 배열이 갱신되지 않도록 초기화하는 로직도 같이 넣어준다
    
1.  함수를 실행한 후 최종 결과에 따른 답을 출력한다
    1.  만약, 초기값 그대로라면 -1을 아니라면 해당값을 출력한다.




#### 💻코드

```python
from pprint import pprint
import sys
input = sys.stdin.readline

N,M = map(int,input().split())

arr = [list(input().rstrip()) for _ in range(N)]

def dfs(direction,visited,k,red_in,blue_in,balls):
    global ans
	
    # 순서 중요 (k부터 확인하면 마지막에 확인 못함)
    if red_in == True and blue_in == False:
        if ans>k:
            ans = k
        return

    if k == 10 or blue_in == True:
        return

    # 보드를 기울이는 과정

    # 먼저 이동시킬 구슬 선정
    # 오른쪽으로 기울이기
    if direction == 0:
        balls.sort(key=lambda x:x[2], reverse=True)
    # 왼쪽으로 기울이기
    elif direction == 1:
        balls.sort(key=lambda x:x[2])
    # 아래로 기울이기
    elif direction == 2:
        balls.sort(key=lambda x:x[1], reverse=True)
    else:
        balls.sort(key=lambda x:x[1])
	
    # 기울인 방향에 맞게 구슬 옮겨주기
    now = [x[:] for x in balls[:]]
    for b in range(2):
        color,x,y = balls[b]
        visited[x][y] = '.'
        while True:
            nx = x+delta[direction][0]
            ny = y+delta[direction][1]

            if visited[nx][ny] == '.':
                x,y = nx,ny
            elif visited[nx][ny] == 'O':
                if color == 1:
                    blue_in = True
                    # 구슬들 위치를 바꿔줘야, 함수를 종료시키지 않음
                    balls[b] = [-1,-1,-1]
                else:
                    red_in = True
                    balls[b] = [-1,-1,-1]
                break

            else:
                # 구슬 정보와, 위치 정보(보드 정보) 갱신해주기
                if color==1:
                    visited[x][y] = 'B'
                    balls[b] = [1,x,y]
                else:
                    visited[x][y] = 'R'
                    balls[b] = [0,x,y]
                break

    # 구슬들 위치가 바뀌지 않았다면
    if now == balls:
        return
	
    # 다음 탐색방향 정하기
    if direction<2:
        next_dir = [2,3]
    else:
        next_dir = [0,1]
	
    # 가능한 방향들을 순회하며 dfs 함수 재귀 호출
    for d in next_dir:
        now_visited = [x[:] for x in visited[:]]
        now_balls = [x[:] for x in balls[:]]
        dfs(d,now_visited,k+1,red_in,blue_in,now_balls)

# balls[i][0]이 0이면 red, 1이면 blue
origin_balls = [[0,0,0],[1,0,0]]

# 구슬 위치 잡기
for i in range(N):
    for j in range(M):
        if arr[i][j] == 'B':
            origin_balls[1] = [1,i,j]
        elif arr[i][j] == 'R':
            origin_balls[0] = [0,i,j]

# 오른쪽, 왼쪽, 아래, 위
delta = [(0,1),(0,-1),(1,0),(-1,0)]
INF = int(1e9)
ans = INF

for d in range(4):
    # dfs 함수로 인해 변하게 될 값들을 초기화
    now_balls = [x[:] for x in origin_balls[:]]
    visited = [x[:] for x in arr[:]]
    dfs(d,visited,0,False,False,now_balls)
if ans == INF:
    print(-1)
else:
    print(ans)

```



#### ❌ 발생 오류 및 해결

- 중단 조건에서 k가 10일 때 성공여부를 확인하지 않고 바로 중단해버림

  
