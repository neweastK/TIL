## 🐌 알고리즘 문제 풀이

### Baekjoon_1987. 알파벳

#### 📒문제

> 세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.
>
> 말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.
>
> 좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1987)



#### :pushpin: 입력 및 출력

- 첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.

- 첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.

---

> 예시

```
input :
2 4
CAAB
ADCB

output :
3

input :
3 6
HFDFFB
AJHGDH
DGAGEH

output :
6

input :
5 5
IEFCJ
FHFKC
FFALF
HFGCF
HMCHH

output :
10
```

----




#### 🚀point

1. DFS를 통한 완전 탐색 문제
2. 출발 지점은 고정 (0,0)
3. 시간을 잘 줄이는 것이 핵심



#### 🔎풀이

1.  입력값을 받을 때 알파벳이 아닌 숫자로 받도록 한다
    1.  각 알파벳의 방문 여부를 길이가 26(알파벳 개수)인 배열로 확인하기 위함
    1.  각 인덱스에 방문 여부 기록

1.  dfs 함수 생성
    1.  범위에서 벗어나지 않고 방문한 적이 없다면 해당 위치를 방문처리 해주고 그 위치를 기준으로 dfs 함수 재실행
    1.  함수가 return 된 이후에는 더 이상 갈 수 없다는 뜻이므로 뒤로 가야된다는 뜻
    1.  따라서, 방문 처리했던 것을 다시 미방문 처리

1.  이 때, 방문한 곳이 길이를 인자로 따로 두어서 최종 정답으로 처리



#### 💻코드

```python
import sys
input = sys.stdin.readline

def dfs(c,si,sj):
    global check
    global res

    if c>res :
        res = c

    for d in range(4):
        ni = si+dx[d]
        nj = sj+dy[d]
        if 0<=ni<R and 0<=nj<C and check[arr[ni][nj]] == 0 :
            check[arr[ni][nj]] = 1
            dfs(c+1,ni,nj)
            check[arr[ni][nj]] = 0


R,C = map(int,input().split())
arr = [list(map(lambda x: ord(x)-65,input().rstrip())) for _ in range(R)]

dx = [0,0,1,-1]
dy = [1,-1,0,0]

res = 0
check = [0]*26
check[arr[0][0]] = 1
c = 1
dfs(c,0,0)
print(res)
```



#### ❌ 발생 오류 및 해결

- 시간초과

  - 방문한 알파벳을 visited 배열에 넣고 조건 검사를 할 때 not in 을 통해 방문여부 확인
    - in 연산자가 리스트를 처음부터 끝까지 순회하기 때문에 매우 많은 시간 사용
  - 알파벳을 숫자로 바꾼 후 26개의 빈 배열을 만들고 해당 배열에서 방문여부를 확인
    - 방문 배열의 합으로 정답 처리를 해서 시간 초과 문제 재발생
    - dfs 함수의 인자를 하나 더 만들어서 해당 인자로 정답처리
  
  
