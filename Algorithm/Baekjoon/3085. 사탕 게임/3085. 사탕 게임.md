## 🐌 알고리즘 문제 풀이

### Baekjoon_3085. 사탕 게임

#### 📒문제

> 상근이는 어렸을 적에 "봄보니 (Bomboni)" 게임을 즐겨했다.
>
> 가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.
>
> 사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/3085)



#### :pushpin: 입력 및 출력

- 첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)

  다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.

  사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.

- 첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.


---

> 예시

```
input :
3
CCP
CCP
PPC

output :
3

input :
4
PPPP
CYZY
CCPY
PPCC

output :
4

input :
5
YCPZY
CYZZP
CCPPP
YCYZC
CPPZZ

output :
4
```

----




#### 🚀point

1. 모든 경우 탐색해보기
   1. 단, 시간을 조금 줄이기 위해 조건에 맞을 경우에만 탐색
   1. 인접한 사탕들이 서로 모두 다르다면 위치를 바꿔도 의미가 없음
      1. 따라서, 인접한 사탕들 중 중복값이 있는 경우에만 위치 바꿔주기




#### 🔎풀이

1.  주변에 겹치는 색의 사탕이 있는지 확인하는 함수 check_around 선언
    1.  각 색깔별 개수를 나타내는 객체 생성
    1.  현재 위치의 색깔 개수 갱신해주기
    1.  인접한 사탕들 탐색하면서 색깔 딕셔너리 갱신
    1.  만약, 두 개 이상인 색깔이 있다면 위치를 바꿨을 때 유의미한 값이 나올 수 있으므로 True 값 반환
    1.  두 개 이상 색깔이 없다면 False 반환

1.  연결되어있는 같은 색깔의 사탕 개수를 세는 함수 선언
    1.  위쪽-아래쪽 / 좌-우 의 사탕을 반복 탐색
    1.  같은 색깔일 경우 그 다음 인덱스도 탐색
    1.  but, 다른 색이거나 범위를 벗어나면 탐색 종료
    1.  그때, 가장 긴 사탕 길이 반환

1.  입력값 모두 받기
1.  사탕 중 주변에 겹치는 사탕 색깔이 있다면 인접한 모든 사탕들과 위치 바꿔서 테스트
    1.  위치를 바꾼 후, 2번 함수로 바꿨을 때의 가장 긴 사탕길이 구하기
    1.  4개의 인접한 사탕이 있으므로 4번 반복 후 마지막에 위치를 바꾸지 않았을 때도 테스트

1.  가장 긴 사탕 길이 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline

N = int(input())
arr = [list(input().rstrip()) for _ in range(N)]

# 아래,위,좌,우,제자리
dx = [0,0,-1,1,0]
dy = [1,-1,0,0,0]

# 주변에 중복된 색깔의 사탕이 있는지 확인 (현재 위치 포함)
def check_around(x,y):
    count_obj = {'Y':0,'C':0,'P':0,'Z':0}
    # 현재 위치의 사탕색깔 개수 더해주기
    count_obj[arr[x][y]] += 1
    # 인접한 사탕 탐색
    for d in range(4):
        nx = x+dx[d]
        ny = y+dy[d]

        if 0<=nx<N and 0<=ny<N:
            count_obj[arr[nx][ny]] += 1
            # 만약, 2개 이상인 색깔이 있다면 교체 작업 진행
            if count_obj[arr[nx][ny]] >= 2:
                return True
    return False

# 연결되어있는 사탕 개수 세기
def count_dfs(start):
    cnt = 0
	
    # 한쪽 방향으로만 쭈욱 세기
    for d in range(4):
        sx,sy = start
        # 위로 갈 경우 아래도, 좌로 갈 경우 우측도 한번에 세야함
        # 따라서, 델타 배열이 아래→위→왼쪽→오른쪽이므로 d==0 d==2 일때 개수 초기화
        if d==0 or d==2:
            tmp = 1
        # 다른 색의 구슬이 나올 때까지 깊게 탐색
        while True:
            nx = sx+dx[d]
            ny = sy+dy[d]
		
            if 0<=nx<N and 0<=ny<N and arr[nx][ny] == arr[sx][sy]:
                tmp += 1
                sx,sy = nx,ny
            else:
                # 가장 긴 개수를 return 하도록 cnt값 갱신
                if cnt<tmp:
                    cnt = tmp
                break
    return cnt


max_length = 0
for i in range(N):
    for j in range(N):
        # 인접한 구슬들 중 겹치는 경우에만 탐색
        if check_around(i,j):
            # 바꾸지 않았을 때 가장 긴 경우도 있으므로 델타배열 마지막은 제자리값
            # 따라서, range(4)가 아닌 range(5)로 설정
            for d in range(5):
                nx = i+dx[d]
                ny = j+dy[d]

                if 0<=nx<N and 0<=ny<N:
                    # 인접한 두 사탕의 위치 바꿔주기
                    arr[i][j],arr[nx][ny] = arr[nx][ny], arr[i][j]
                    # 그때의 가장 긴 같은 색 사탕들 길이 구해주기
                    tmp_length = count_dfs((i,j))
                    # 최댓값 찾기
                    if tmp_length>max_length:
                        max_length = tmp_length
                    # 원래대로 사탕 돌려놓기
                    arr[i][j],arr[nx][ny] = arr[nx][ny], arr[i][j]


print(max_length)
```



#### ❌ 발생 오류 및 해결

- 탐색시, 위쪽 혹은 아래쪽 하나만 탐색해서 오답 출력
  - 위-아래 / 좌-우 한번에 탐색해야함
- 자리를 바꾸지 않았을 때 최대가 되는 경우 배제
  - 자리를 바꾸지 않았을 때도 최대가 될 수 있음
