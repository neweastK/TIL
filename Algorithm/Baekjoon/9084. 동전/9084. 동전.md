## 🐌 알고리즘 문제 풀이

### Baekjoon_9084. 동전

#### 📒문제

> 우리나라 화폐단위, 특히 동전에는 1원, 5원, 10원, 50원, 100원, 500원이 있다. 이 동전들로는 정수의 금액을 만들 수 있으며 그 방법도 여러 가지가 있을 수 있다. 예를 들어, 30원을 만들기 위해서는 1원짜리 30개 또는 10원짜리 2개와 5원짜리 2개 등의 방법이 가능하다.
>
> 동전의 종류가 주어질 때에 주어진 금액을 만드는 모든 방법을 세는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/9084)



#### :pushpin: 입력 및 출력

- 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 동전의 가지 수 N(1 ≤ N ≤ 20)이 주어지고 두 번째 줄에는 N가지 동전의 각 금액이 오름차순으로 정렬되어 주어진다. 각 금액은 정수로서 1원부터 10000원까지 있을 수 있으며 공백으로 구분된다. 세 번째 줄에는 주어진 N가지 동전으로 만들어야 할 금액 M(1 ≤ M ≤ 10000)이 주어진다.

  편의를 위해 방법의 수는 231 - 1 보다 작고, 같은 동전이 여러 번 주어지는 경우는 없다.

- 각 테스트 케이스에 대해 입력으로 주어지는 N가지 동전으로 금액 M을 만드는 모든 방법의 수를 한 줄에 하나씩 출력한다.


---

> 예시

```
input :
3
2
1 2
1000
3
1 5 10
100
2
5 7
22

output :
501
121
1
```

----




#### 🚀point

1. DP를 활용하여 문제 풀이




#### 🔎풀이

1.  입력값을 모두 받는다

1.  dp 배열을 생성한다
    1.  dp[i]\[j]는 i 번째 동전까지 사용해서 j 금액을 만들 수 있는 경우의 수

    1.  dp[i]\[j]는 i-1번째 동전까지만 사용했을 때의 경우의 수 (즉, i번째 동전을 쓰지 않고 j금액을 만들 수 있는 경우의 수) + i번째 동전을 사용했을 때의 경우의 수 로 구한다
        1.  i번째 동전을 사용했을 때의 경우의 수는 dp[i]\[j-i번째동전] 값을 의미한다

        1.  만약, 동전이 2원짜리고 j가 4라면, 2원짜리로 2원을 만들 수 있는 경우의 수와 같아진다

        1.  즉, 어떤 금액 x를 2원짜리로 만들 수 있다면, x+2원도 같은 경우의 수로 만들 수 있다 (x원을 만드는 방법에 2원만 붙여주면 되니)

1.  단, 0원을 만드는 방법은 1로 초기화한다
    1.  모든 동전을 내지 않는 방법이 있기 때문

1.  동전보다 작은 금액은 만들 수 없으므로 이전 동전까지의 값으로 대체한다

1.  최종적으로 만들어진 dp 배열에서 dp[N]\[target] 즉, N번째 동전까지 모두 사용했을 때, target원을 만들 수 있는 경우의 수를 구한다





#### 💻코드

```python
T = int(input())
for _ in range(T):
    N = int(input())
    coins = list(map(int,input().split()))
    # 만들고 싶은 금액
    target = int(input())
	
    # dp 배열 생성
    dp = [[0]*(target+1) for _ in range(N+1)]
    # 0원을 만들 수 있는 방법은 한가지! (아무 동전도 내지 않는 것)
    dp[0][0] = 1
	
    # 반복하면서 dp 배열을 채운다
    for i in range(1,N+1):
        # 현재 사용하고 있는 동전의 금액
        coin = coins[i-1]
        # j는 만들 금액을 의미하고, dp[i][j]는 i번째 동전까지로 j를 만들 수 있는 경우의 수를 의미
        for j in range(target+1):
            # j가 동전금액보다 작다면 어차피 만들 수 없으므로 이전 값으로 대체한다
            if j<coin:
                dp[i][j] = dp[i-1][j]
            else:
                # i번째 동전을 사용하지 않은 경우의 수 + i번째 동전을 사용한 경우의 수
                # i번째 동전을 사용했을 때의 경우의 수 == (j-동전금액)원을 만들 수 있는 경우의 수
                dp[i][j] = dp[i-1][j] + dp[i][j-coin]

    print(dp[N][target])
```



#### ❌ 발생 오류 및 해결

- 

  
