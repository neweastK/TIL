## 🐌 알고리즘 문제 풀이

### Baekjoon_17825. 주사위 윷놀이

#### 📒문제

> 주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다.
>
> ![img](https://upload.acmicpc.net/43409ac6-54bf-4a21-b542-e01a8211e59f/-/preview/)
>
> - 처음에는 시작 칸에 말 4개가 있다.
> - 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다.
> - 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다.
> - 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다.
> - 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.
>
> 주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/17852)



#### :pushpin: 입력 및 출력

- 첫째 줄에 주사위에서 나올 수 10개가 순서대로 주어진다.

- 얻을 수 있는 점수의 최댓값을 출력한다.



---

> 예시

```
input :
1 2 3 4 1 2 3 4 1 2

output :
190

input :
1 1 1 1 1 1 1 1 1 1

output :
133

input :
5 1 2 3 4 5 5 3 2 4

output :
214

input :
5 5 5 5 5 5 5 5 5 5

output :
130
```

----




#### 🚀point

1. 재귀함수를 이용한 백트래킹 문제
1. 무엇을 탐색할 것인가?
   - 각 주사위의 결과에 어떤 말을 이동시킬 것인가?

![image-20230302204745479](../../../../../AppData/Roaming/Typora/typora-user-images/image-20230302204745479.png)

1. 방문 및 이동 로직 필요
1. 점수가 겹치는 구간을 따로 처리해줘야함



#### 🔎풀이

1.  윷놀이 판을 배열로 구현한다
    1.  시작점부터 파랑색을 지나지 않았을 때의 도착점까지 경로(from_start)
    1.  파랑색 칸에서 멈췄을 경우 이동하게 될 경로(from_10,from_20,from_30)
    1.  이때, 25부터 도착점까지는 모두 겹치므로 파랑색칸 경로에 모두 추가해준다
        1.  방문처리는 visited 배열로 따로 할 예정

    1.  만들어진 각 경로를 하나의 배열 안에 넣는다
    1.  maps[i]\[j]는 i번 경로에서 j번째 위치

1.  말의 방문 여부를 나타낼 방문 배열 구현
    1.  각 점수에 따라 방문처리를 하도록 한다
        1.  도착한 칸의 점수가 10이면 visited[10]에 방문여부 표시

    1.  이때, 점수가 겹치는 칸이 몇개 있으므로 구분할 수 있도록 2차원 배열로 선언한다
        1.  점수가 최대로 겹치는 경우가 2개 뿐이므로 2차원까지만 선언
        1.  즉, 겹치지 않는 유일한 점수는 visited[0]\[점수] 로만 방문 여부 판단
        1.  중복되는 값이 있는 점수는 visited[0]과 visited[1]로 각각 판단
        1.  이를 위해 중복되는 점수를 따로 선언 (target)

1.  입력값을 받고, 각 말의 정보를 나타낼 배열 선언
    1.  각 말은 [현재 경로, 경로 상의 위치, 현재 점수의 방문 배열 위치]를 나타냄

1.  dfs 함수 선언
    1.  dfs 함수는 주사위를 10번 굴렸을 때, 각 n번째에는 어떤 말을 옮길 것이고 그 때의 점수는 몇점인지 판단하는 함수
    1.  말은 총 4개이고, 각 말을 순회하면서 탐색
        1.  즉, k번째 턴에 i번 말을 옮긴다 를 구현

    1.  현재 턴의 주사위 값을 변수에 할당
    1.  현재위치의 점수를 구한다. (방문처리를 위해)
    1.  만약, 새로 이동할 위치가 현재 경로의 길이를 넘어선다면, 도착칸에 이동했다는 뜻
        1.  도착지에 이동하면 그 말은 더 이상 움직일 수 없으므로 별도의 처리 필요
        1.  현재 경로를 -1로 두고, 경로가 -1인 말은 더 이상 탐색하지 않도록 설정
        1.  도착지에 이동한 것도 말을 옮긴 것이므로 점수를 더하지는 않은 상태에서 k만 1 증가시켜서 dfs 재귀 호출

    1.  범위 안에 있다면, 새로 이동할 수 있는 칸의 점수를 저장
    1.  방문 배열의 인덱스 (0 or 1)를 얻기 위해 목적지의 값이 겹치는지 확인
        1.  겹치는 경우, 현재 경로에 따라 배열 인덱스를 다르게 설정
        1.  현재 경로가 가장 첫번째 경로(from_start)면, 첫번째 경로 상에 있는 값이므로 인덱스는 0
        1.  현재 경로가 첫번째 경로가 아니면, 나머지 경로 상에 있는 값이므로 인덱스는 1
        1.  첫번째 경로를 제외한 나머지 경로 상에서 서로 겹치는 값이 없어서 가능
        1.  즉, 중복된 값의 경우 가장 바깥 쪽 경로와 안쪽 경로를 구분하여 방문 처리!

    1.  방문 여부를 확인한 후, 이동 or 중단
        1.  이동한 후 방문처리 (현재 위치는 미방문, 새로운 위치는 방문)
        1.  이 후, 말의 정보 갱신
            1.  만약 현재 위치가 10 혹은 20이라면, 이제 from_10,from_20 경로로 가야하므로 경로값 갱신
            1.  30의 경우, 중복값이므로 30이면서 현재 경로가 가장 바깥쪽 경로인 경우에만 from_30 경로로 갱신
            1.  이때, route 값. 즉, 탐색해야하는 배열의 인덱스도 같이 담아줌으로써, 추후에 현재 위치의 방문처리를 원활히 할 수 있도록 한다(8-1)
                1.  위 작업이 없으면, 파랑색 칸에서 오류 발생

            1.  그 외 값들은, 현재 경로 그대로 위치만 새로 갱신하여준다

    1.  점수와 k 값을 더해주고 dfs 함수 재귀호출
    1.  호출이 끝나고 다시 원 상태로 돌려줘야함 (방문 및 말 정보 원래대로 돌려놓기)

1.  dfs 함수 호출 및 결과값 출력



#### 💻코드

```python
# 배열을 사용하여 윷놀이 판 구현
from_start = [2*x for x in range(21)] #가장 바깥쪽 경로로 인덱스 0
from_25 = [25,30,35,40]
from_10 = [10,13,16,19]+from_25 # 10부터 40까지 경로로 인덱스 1
from_20 = [20,22,24]+from_25 # 20부터 40까지 경로로 인덱스 2
from_30 = [30,28,27,26]+from_25 # 30부터 40까지 경로로 인덱스 3
maps = [from_start,from_10,from_20,from_30]

# 특정 말이 있는지 여부를 확인하기 위한 배열
# visited[0]은 안겹치는,유일값을 가진 칸들을 판단
# visited[1]은 겹치는 값을 가진 칸들을 판단
visited = [[0]*41 for _ in range(2)]

# 겹치는 점수를 확인할 수 있도록 따로 선언
target = [16,22,24,26,28,30]

dice = list(map(int,input().split()))

# 각 말의 정보
# 현재 경로, 경로 상의 위치, 방문 처리한 인덱스
players = [[0,0,0],[0,0,0],[0,0,0],[0,0,0]]
res = []

def dfs(k,scores):
    # 10번의 말 이동을 했으면
    if k==10:
        # 결과값 할당
        res.append(scores)
        return
	
    # k번 차례에 굴린 주사위 값
    dice_num = dice[k]
    
    # 4개의 말을 각각 이동시키기
    for i in range(4):
        # 현재 경로, 경로 상 위치, 방문 처리한 인덱스
        now_route, idx, visited_idx = players[i]
        # 현재 위치의 점수
        now_value = maps[now_route][idx]
		# 이미 도착한 말은 넘어가기
        if now_route == -1:
            continue
        # 범위를 벗어나는 경우
        if idx+dice_num >= len(maps[now_route]):
            # 다음번부터는 그냥 넘어가도록 설정
            players[i] = -1,0,0
            # 도착점으로 이동 예정이므로 현재 위치는 방문배열에서 0 처리
            # 이때, visited_idx 활용
            visited[visited_idx][now_value] = 0
            
            dfs(k+1,scores)
            
            # 재귀호출 후 다시 원상복구
            visited[visited_idx][now_value] = 1
            players[i] = now_route, idx, visited_idx
		
        # 범위 안에 있는 경우
        else:
            # 목적지의 점수
            new = maps[now_route][idx+dice_num]
            route = 0

            # 값이 겹치면서, 기본 루트(from_start)상의 값이 아니면 route는 1
            if new in target:
                # 현재 경로가 from_start면 새로운 경로도 from_start(중간에 경로를 바꿀 수는 없기 때문)
                # 현재 경로가 from_start가 아니면 새로운 경로도 from_start가 아님
                # 따라서, 현재 경로가 from_start면 방문처리를 visited[0]에 아니면 visited[1]에 할 수 있도록 설정
                if now_route != 0:
                    route = 1
			
            # route에 따라, 이동할 수 있는지 여부 확인
            is_visited = visited[route][new]
            
            # 이동할 수 있다면
            if is_visited==0:
                # 현재 위치는 0으로 새로운 위치는 1로 갱신
                # route값은 계속 갱신되기 때문에 이전에 방문했다는 처리를 할 때 저장한 visited_idx로 현재 위치값 갱신
                visited[visited_idx][now_value] = 0
                visited[route][new] = 1
				
                # 새로운 위치가 파랑색 칸인 경우
                if new == 10:
                    players[i] = 1,0,route
                elif new == 20:
                    players[i] = 2,0,route
                # 30은 중복값이므로, 파랑색 칸일 때만 적용
                # 파랑색 칸은 from_start에만 있음
                elif new == 30 and now_route==0:
                    if now_route == 0:
                        players[i] = 3,0,route
                # 파랑색 칸이 아니면 위치만 갱신
                else:
                    players[i] = now_route,idx+dice_num,route

                dfs(k+1,scores+new)
				
                # 재귀호출 후 원상복구
                visited[visited_idx][now_value] = 1
                visited[route][new] = 0
                players[i] =  now_route, idx, visited_idx

            else:
                continue

                
dfs(0,0)
# 쌓인 점수 중 최대값 출력
print(max(res))
```



#### ❌ 발생 오류 및 해결

- 
