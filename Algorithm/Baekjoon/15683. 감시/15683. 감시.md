## 🐌 알고리즘 문제 풀이

### Baekjoon_15683. 감시

#### 📒문제

> 스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.
>
> | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/1.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/2.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/3.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/4.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/5.png) |
> | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 1번                                                          | 2번                                                          | 3번                                                          | 4번                                                          | 5번                                                          |
>
> 1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.
>
> CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.
>
> CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.
>
> ```
> 0 0 0 0 0 0
> 0 0 0 0 0 0
> 0 0 1 0 6 0
> 0 0 0 0 0 0
> ```
>
> 지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '`#`'로 나타내면 아래와 같다.
>
> | `0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 # 6 0 0 0 0 0 0 0` | `0 0 0 0 0 0 0 0 0 0 0 0 # # 1 0 6 0 0 0 0 0 0 0` | `0 0 # 0 0 0 0 0 # 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0` | `0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 # 0 0 0` |
> | ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- |
> | →                                                 | ←                                                 | ↑                                                 | ↓                                                 |
>
> CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.
>
> ```
> 0 0 0 0 0 0
> 0 2 0 0 0 0
> 0 0 0 0 6 0
> 0 6 0 0 2 0
> 0 0 0 0 0 0
> 0 0 0 0 0 5
> ```
>
> 위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.
>
> | `0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5` | `0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5` | `0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5` | `0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5` |
> | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔                             | 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕                             | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔                             | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕                             |
>
> CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.
>
> ```
> 0 0 2 0 3
> 0 6 0 0 0
> 0 0 6 6 0
> 0 0 0 0 0
> ```
>
> 위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.
>
> ```
> # # 2 # 3
> 0 6 # 0 #
> 0 0 6 6 #
> 0 0 0 0 #
> ```
>
> 사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/15683)



#### :pushpin: 입력 및 출력

- 첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)

  둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다. 

  CCTV의 최대 개수는 8개를 넘지 않는다.

- 첫째 줄에 사각 지대의 최소 크기를 출력한다.


---

> 예시

```
input :
4 6
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0

output :
20

input :
6 6
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5

output :
15

input :
6 6
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0
0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1

output :
6

input :
1 7
0 1 2 3 4 5 6

output :
0

input :
3 7
4 0 0 0 0 0 0
0 0 0 2 0 0 0
0 0 0 0 0 0 4

output:
0
```

----




#### 🚀point

1. dfs로 모든 cctv를 회전시키는 경우의 수 완전 탐색
2. 각 cctv별 가능한 탐색 경우가 다름
   1. 1번은 1,3,4번의 회전 경우의 수가 있고, 2번은 2개(상-하, 좌-우), 5번은 단 하나의 경우만 있음
   2. 각각을 다르게 순회해 탐색 범위 줄이기 (전부 다 4번 회전하지 않도록)




#### 🔎풀이

1.  입력값을 모두 받는다
1.  탐색을 위한 delta와 각 cctv별 회전할 수 있는 경우를 담은 딕셔너리를 생성한다
    1.  각 카메라 번호를 키값으로 하는 객체는 cctv가 한번에 감시할 수 있는 방향들이 담겨있다
    1.  예를 들어 2번 카메라는 상-하(delta의 1,3번째)와 좌-우(delta의 2,4번째)로 탐색 가능
    1.  따라서, 2를 키값으로 하고 [(1,3),(2,4)]를 값으로 가짐

1.  입력값으로 주어진 지도를 순회하며 cctv정보 확인
    1.  cctv의 번호와 각 위치를 배열에 담아서 따로 저장
    1.  그 후, 감시 가능한 구역을 뜻하는 9로 값 변경
    1.  벽을 만난 경우, 벽의 개수 카운팅
        1.  벽은 감시 가능한 구역으로 치기 때문에 나중에 사각지대 개수에서 빼줘야함

1.  dfs 함수 정의
    1.  매개변수는 몇번째 cctv인지를 나타내는 k와 방문배열 maps, cctv정보들이 담긴 cctvs 배열, 감시 가능 구역의 개수인 res가 있다
    1.  종료 조건은 cctv 개수만큼 탐색한 경우
        1.  사각지대 개수를 구한 후, 현재 사각지대 개수보다 적으면 갱신
        1.  사각지대 개수 = 전체 범위 - 관찰 가능한 구역 - 벽 개수

    1.  한번의 dfs는 하나의 cctv를 어떻게 회전시킬 것인가를 결정하는 역할
        1.  다음 재귀 함수가 끝나고 방문배열 초기화를 할 필요 없도록 방문배열 복사
        1.  지금 카메라로 감시 가능한 구역의 개수를 나타내는 tmp_res 변수 생성
            1.  초기값은 1, 카메라의 위치도 감시 가능하므로
            1.  방문처리는 3-2에서 해줌

        1.  딕셔너리를 활용하여 각 경우의 수 탐색
        1.  이미 다른 카메라가 감시한 적이 없다면 (tmp_arr[i]\[j] != 9) 감시 가능한 구역의 개수 추가 후 방문처리
        1.  벽이 있거나, 범위를 벗어난 경우 해당 방향 탐색 종료

    1.  해당 cctv를 회전 시킨 후 탐색 가능한 범위의 개수를 다 셌다면, 해당 정보를 다음 dfs에 넘기면서 재귀호출

1.  최종적으로 남은 사각지대 개수 출력




#### 💻코드

```python
import sys
input = sys.stdin.readline

N,M = map(int,input().split())
arr = [list(map(int,input().split())) for _ in range(N)]
delta = [(0,1),(1,0),(0,-1),(-1,0)]

# cctv별로 한번에 관찰할 수 있는 경우의 수
# 튜플 내 번호는 탐색할 방향을 의미 (delta값 참조)
rotate_cctv={
    1:[(0,),(1,),(2,),(3,)],
    2:[(0,2),(1,3)],
    3:[(0,3),(1,0),(2,1),(3,2)],
    4:[(0,3,2),(1,0,3),(2,1,0),(3,2,1)],
    5:[(0,1,2,3)]
}

# 모든 cctv의 정보를 담을 배열
# (cctv번호, 행 위치, 열 위치)
cctvs = []
# 벽의 개수 (벽은 사각지대 개수를 셀 때 제외)
wall_cnt = 0

# 배열 반복하며 cctv정보 확인
for i in range(N):
    for j in range(M):
        num = arr[i][j]
        # cctv면 정보 넣어주고, 방문처리
        if num!=0 and num!=6:
            cctvs.append((num,i,j))
            arr[i][j] = 9
        # 벽이면 벽 개수 세주기
        elif num == 6:
            wall_cnt += 1

cctv_cnt = len(cctvs)
ans = 99999

# 각 cctv별 회전할 수 있는 모든 경우의 수 확인하기
# k는 몇번째 cctv인지, maps는 지금까지의 방문배열, 
# cctvs는 cctv 정보, res는 지금까지 확인한 관찰 가능한 구역의 개수
def dfs(k,maps,cctvs,res):
    global ans
	# 만약, cctv 개수만큼 확인했다면
    if cctv_cnt==k:
        # 사각지대의 개수가 이전에 확인한 경우보다 적을 경우에만 갱신
        # 사각지대 개수 = 전체 범위에서 관찰할 수 있는 구역 개수와 벽의 개수를 빼주면 됨
        if ans > (N*M-res-wall_cnt):
            ans = N*M-res-wall_cnt
        return
	
    # 아닌 경우, 다음 cctv의 회전 진행
    
    # 현재 cctv 정보
    c_num,ox,oy = cctvs[k]

    # 해당 cctv가 한번에 확인할 수 있는 방향 목록 순회
    for rs in rotate_cctv[c_num]:
        ##### 하나의 경우의 수 #########
        
        # 배열 복사
        tmp_arr = [x[:] for x in maps[:]]

        # cctv의 원래 위치도 감시 가능하므로 개수 세주기
        # 방문처리는 맨 처음에 이미 했음
        tmp_res = 1
      	# 2,3,4번 cctv처럼 여러 방향을 탐색할 경우
        # 반복문으로 각 방향 탐색
        for r in rs:
            # 원래 위치로 돌아오기
            x,y = ox,oy
            while True:
                nx = x+delta[r][0]
                ny = y+delta[r][1]

                if 0<=nx<N and 0<=ny<M and tmp_arr[nx][ny] != 6:
                    x,y = nx,ny
                    # 이미 다른 cctv에서 관찰한 경우 continue
                    if tmp_arr[nx][ny] == 9:
                        continue
                    # 방문처리 및 감시 가능 구역 개수에 1 추가
                    tmp_arr[nx][ny] = 9
                    tmp_res+=1
                else:
                   	# 벽이 있거나 범위를 벗어나면 해당 방향 탐색 중지
                    break
        dfs(k+1,tmp_arr,cctvs,res+tmp_res)

dfs(0,arr,cctvs,0)
print(ans)
```



#### ❌ 발생 오류 및 해결

- 

  
