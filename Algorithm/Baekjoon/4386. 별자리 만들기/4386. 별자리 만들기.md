## 🐌 알고리즘 문제 풀이

### Baekjoon_4386. 별자리 만들기

#### 📒문제

> 도현이는 우주의 신이다. 이제 도현이는 아무렇게나 널브러져 있는 n개의 별들을 이어서 별자리를 하나 만들 것이다. 별자리의 조건은 다음과 같다.
>
> - 별자리를 이루는 선은 서로 다른 두 별을 일직선으로 이은 형태이다.
> - 모든 별들은 별자리 위의 선을 통해 서로 직/간접적으로 이어져 있어야 한다.
>    
>    별들이 2차원 평면 위에 놓여 있다. 선을 하나 이을 때마다 두 별 사이의 거리만큼의 비용이 든다고 할 때, 별자리를 만드는 최소 비용을 구하시오.
>    
>    [<문제 출처>](https://www.acmicpc.net/problem/4386)



#### :pushpin: 입력 및 출력

- 첫째 줄에 별의 개수 n이 주어진다. (1 ≤ n ≤ 100)

  둘째 줄부터 n개의 줄에 걸쳐 각 별의 x, y좌표가 실수 형태로 주어지며, 최대 소수점 둘째자리까지 주어진다. 좌표는 1000을 넘지 않는 양의 실수이다.

- 첫째 줄에 정답을 출력한다. 절대/상대 오차는 10-2까지 허용한다.


---

> 예시

```
input :
3
1.0 1.0
2.0 2.0
2.0 4.0

output :
3.41
```

----




#### 🚀point

1. 최소 신장 트리를 구할 수 있는가?

#### 🔎풀이

1.  노드들의 위치만 주어지기 때문에, 모든 노드들이 서로 연결되어있다고 가정하에 간선과 가중치를 뽑는다
2.  주어진 노드의 개수를 활용하여 각 노드별로 서로 연결될 수 있는 모든 경우의 수를 뽑는다
    1.  이 때, 모든 경우의 수는 itertools의 combinations를 활용한다

3.  모든 경우의 수를 순회하면서 각 노드별 거리를 구한다.
    1.  거리는 math 라이브러리를 활용한다
    2.  x좌표의 변화량과 y좌표의 변화량 각각의 제곱을 더한 값이, 두 노드 사이의 거리의 제곱값이 된다.

4.  그렇게 구해진 거리와 좌표들을 edges 배열에 모두 넣는다
5.  edges를 거리에 따라 정렬한 후, 순회하면서 서로 연결한다 (union 함수)
6.  만약 이미 연결되어 있다면, 이전에 더 낮은 거리로 연결이 완료되었으므로 연결하지 않고 넘어간다.
7.  연결할 때는 거리값을 계속해서 더해준다
8.  최종적으로 나온 거리값이 최단 거리가 되므로 정답을 출력한다.

#### 💻코드

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
        return parent[x]
    return x

def union(a,b):
    a = find(a)
    b = find(b)

    if a<b:
        parent[b] = a
    else:
        parent[a] = b

N = int(input())
maps = []
edges = []
parent = [0]*N

for i in range(N):
    maps.append(list(map(float,input().split())))
    parent[i] = i

all_edge = list(combinations(range(N),2))
for edge in all_edge:
    a,b = edge
    distance = math.sqrt((maps[a][0]-maps[b][0])**2 + (maps[a][1]-maps[b][1])**2)
    edges.append((distance,a,b))

edges.sort()
res = 0
for edge in edges:
    cost,a,b = edge
    if find(a) != find(b):
        union(a,b)
        res += cost

print(res)
```



#### ❌ 발생 오류 및 해결

- 
