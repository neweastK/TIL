## 🐌 알고리즘 문제 풀이

### Baekjoon_11404.  플로이드

#### 📒문제

> n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.
>
> 모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/11404)



#### :pushpin: 입력 및 출력

- 첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.

  시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.

- n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.


---

> 예시

```
input :
5
14
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
3 5 10
3 1 8
1 4 2
5 1 7
3 4 2
5 2 4

output :
0 2 3 1 4
12 0 15 2 5
8 5 0 1 1
10 7 13 0 3
7 4 10 6 0
```

----




#### 🚀point

1. 플로이드-워셜 활용



#### 🔎풀이

1.  초기값이 INF(== 1e9)인 N+1 크기의 배열을 생성한다
    1.  배열\[i][j]는 i에서 j까지 가는데 드는 비용을 뜻함
    1.  배열을 순회하면서 자기 자신까지의 거리는 0으로 초기화한다

1.  입력값을 받아 배열에 비용을 표시한다
    1.  단, 이때, 동일한 루트의 다른 노선이 있을 수도 있다고 문제에 명시되어있음
    1.  따라서, 이미 다른 루트가 있을 경우, 비용이 더 작은 값을 배열에 넣어준다
    1.  다른 노선이 없으면 그대로 넣어준다

1.  배열을 순회하면서 중간에 특정 노드를 거쳐갈 때의 비용을 계산한다
    1.  만약, 중간에 거쳐가는 것이 더 비용이 작으면 해당 값으로 갱신해준다
    1.  i에서 j로 가는 비용 vs i에서 k를 거쳐 j로 가는 비용
    1.  만약, 비용이 갱신되면 i에서 j로 가는 비용은 사실상 i에서 k를 거쳐 j로 가는 비용인 것
    1.  이 이후 다른 노드에서 계산할 때도 위 갱신된 값이 적용됨

1.  배열의 모든 값의 갱신이 끝나면 해당 배열을 한 행씩 출력한다



#### 💻코드

```python
import sys

input = sys.stdin.readline
N = int(input())
M = int(input())

INF = int(1e9)
arr = [[INF]*(N+1) for _ in range(N+1)]

# 자기 자신으로 가는 비용은 0으로 갱신
for i in range(1,N+1):
    for j in range(1,N+1):
        if i==j:
            arr[i][j] = 0

# 입력값을 받으면서 배열 갱신
for _ in range(M):
    a,b,c = map(int,input().split())
    # 이미 다른 비용이 있다면, 더 작은 값으로 갱신
    if arr[a][b] != INF:
        arr[a][b] = min(arr[a][b],c)
    else:
        arr[a][b] = c

# k는 거쳐갈 노드        
for k in range(1,N+1):
    for i in range(1,N+1):
        for j in range(1,N+1):
            # 특정 노드를 거쳐가는 비용 vs 현재 비용
            arr[i][j] = min(arr[i][j], arr[i][k]+arr[k][j])

for i in range(1,N+1):
    for j in range(1,N+1):
        # INF라는 것은 초기값 그대로이므로 이동할 수 없다는 뜻
        if arr[i][j] == INF:
            arr[i][j] = 0
    print(*arr[i][1:])
```



#### ❌ 발생 오류 및 해결

- 
