## 🐌 알고리즘 문제 풀이

### SWEA_4008. 숫자 만들기

#### 📒문제

> 선표는 게임을 통해 사칙 연산을 공부하고 있다.
>
> N개의 숫자가 적혀 있는 게임 판이 있고, +, -, x, / 의 연산자 카드를 숫자 사이에 끼워 넣어 다양한 결과 값을 구해보기로 했다.
>
> 수식을 계산할 때 **연산자의 우선 순위는 고려하지 않고 왼쪽에서 오른쪽으로 차례대로 계산**한다.
>
> 예를 들어 1, 2, 3 이 적힌 게임 판에 +와 x를 넣어 1 + 2 * 3을 만들면 1 + 2를 먼저 계산하고 그 뒤에 * 를 계산한다.
> 
>즉 1+2*3의 결과는 9이다.
> 
>주어진 연산자 카드를 사용하여 수식을 계산했을 때 그 결과가 최대가 되는 수식과 최소가 되는 수식을 찾고, 두 값의 차이를 출력하시오.
> 
> [<문제 출처>](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeRZV6kBUDFAVH)

#### :pushpin: 입력 및 출력

- 입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,

  그 다음 줄부터 T 개의 테스트 케이스가 주어진다.

  각 테스트 케이스의 첫 번째 줄에는 숫자의 개수 N 이 주어진다.

  다음 줄에는 '+', '-', '*', '/' 순서대로 연산자 카드의 개수가 공백을 사이에 두고 주어진다.

  다음 줄에는 수식에 들어가는 N 개의 숫자가 순서대로 공백을 사이에 두고 주어진다.

- 테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.

  각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )

  정답은 연산자 카드를 사용하여 만들 수 있는 수식으로 얻은 결과값 중 최댓값과 최솟값의 차이이다.

---

> 예시

입력						 출력 

5							  24	

2 1 0 1

3 5 3 7 9

----




#### 🚀point

1. 수식을 완성할 때 각 연산자 카드를 모두 사용해야 한다.

1. 숫자와 숫자 사이에는 연산자가 1 개만 들어가야 한다.

1. 완성된 수식을 계산할 때 연산자의 우선 순위는 고려하지 않고, 왼쪽에서 오른쪽으로 차례대로 계산한다.

1. 나눗셈을 계산 할 때 소수점 이하는 버린다.

1. 연산자 카드 개수의 총 합은 항상 N - 1 이다.

1. **입력으로 주어지는 숫자의 순서는 변경할 수 없다.**

   


#### 🔎풀이

1. 식을 문자열로 받기 때문에 eval 필요

1. 연산자 각각이 들어갈 모든 위치를 도출하기 위해 itertools의 순열 기능 사용

   


#### 💻코드

```python
# import sys
# sys.stdin = open("input.txt")

from itertools import permutations
from pprint import pprint


# T = int(input())

# for tc in range(T) :
N = int(input())
operators = list(map(int,input().split()))
nums = list(map(int,input().split()))
oper_lst = ["+"]*operators[0] + ["-"]*operators[1] + ["*"]*operators[2] + ["/"]*operators[3]


# for idx,operator in enumerate(operators) :
#     for j in range(operator) :
#         oper_lst.append(operator_index.get(idx))

opers = set(permutations(oper_lst)) # 순열 모음 리스트
pprint(opers)
print(len(opers))
res = []

res_min = 9999999999
res_max = -9999999999
for oper in opers :
    tmp = nums[0]
    for i in range(1,len(nums)) :
        if oper[i-1] == "+":
            tmp += nums[i]
        elif oper[i-1] == "-":
            tmp -= nums[i]
        elif oper[i-1] == "*":
            tmp *= nums[i]
        else:
            tmp = int(tmp / nums[i])
    if tmp < res_min :
        res_min = tmp
    elif tmp >= res_max :
        res_max = tmp

result = res_max - res_min
print(f"# {result}")
```



#### ❌ 발생 오류 및 해결

- 음수와의 나눗셈의 경우 연산자 `//` 를 적용할 경우 버림이 아닌, 내림을 하게됨
  - 해결법 : 연산 결과에 소수점이 있는 경우는 오로지 나누는 경우 뿐. 그때는 int로 감싸줘서 정수로 만들어줌으로써 해결 (나눗셈 연산자도 `//`에서 `/`로 변경)

- 시간 문제 발생 (너무 오래걸려 테스트 통과 불가)
- 아... eval은 허용하지 않는 함수이다.
- 
