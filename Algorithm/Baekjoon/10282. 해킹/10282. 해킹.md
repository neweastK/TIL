## 🐌 알고리즘 문제 풀이

### Baekjoon_10282. 해킹

#### 📒문제

> 최흉최악의 해커 yum3이 네트워크 시설의 한 컴퓨터를 해킹했다! 이제 서로에 의존하는 컴퓨터들은 점차 하나둘 전염되기 시작한다. 어떤 컴퓨터 a가 다른 컴퓨터 b에 의존한다면, b가 감염되면 그로부터 일정 시간 뒤 a도 감염되고 만다. 이때 b가 a를 의존하지 않는다면, a가 감염되더라도 b는 안전하다.
>
> 최흉최악의 해커 yum3이 해킹한 컴퓨터 번호와 각 의존성이 주어질 때, 해킹당한 컴퓨터까지 포함하여 총 몇 대의 컴퓨터가 감염되며 그에 걸리는 시간이 얼마인지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/10282)



#### :pushpin: 입력 및 출력

- 첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 개수는 최대 100개이다. 각 테스트 케이스는 다음과 같이 이루어져 있다.

  - 첫째 줄에 컴퓨터 개수 n, 의존성 개수 d, 해킹당한 컴퓨터의 번호 c가 주어진다(1 ≤ n ≤ 10,000, 1 ≤ d ≤ 100,000, 1 ≤ c ≤ n).
  - 이어서 d개의 줄에 각 의존성을 나타내는 정수 a, b, s가 주어진다(1 ≤ a, b ≤ n, a ≠ b, 0 ≤ s ≤ 1,000). 이는 컴퓨터 a가 컴퓨터 b를 의존하며, 컴퓨터 b가 감염되면 s초 후 컴퓨터 a도 감염됨을 뜻한다.

  각 테스트 케이스에서 같은 의존성 (a, b)가 두 번 이상 존재하지 않는다.

- 각 테스트 케이스마다 한 줄에 걸쳐 총 감염되는 컴퓨터 수, 마지막 컴퓨터가 감염되기까지 걸리는 시간을 공백으로 구분지어 출력한다.


---

> 예시

```
input :
2
3 2 2
2 1 5
3 2 5
3 3 1
2 1 2
3 1 8
3 2 4

output :
2 5
3 6
```

----




#### 🚀point

1. a,b,s가 주어질 때 b에서 a로 가는 시간 s 라고 생각하면서 graph 배열을 구성한다.

1. 최종 결과에서 무한대면 감염되지 않았다는 뜻

   


#### 🔎풀이

1.  point에서 짚은 a,b,s를 적절하게 할당한다.
1.  감염이 시작된 c 가 다익스트라의 출발점이 된다.
1.  다익스트라 함수를 돌리고, 최종적으로 작성된 distance 배열을 한번더 정리한다.
    1.  무한대가 아닌 값들만 추출한다.
    1.  무한대 == 감염되지 않은 컴퓨터

1.  감염된 컴퓨터만 남은 배열에서 len을 통해 개수를 출력하고, 그 중 가장 오래 걸린 시간을 출력한다.
    1.  감염은 동시에 되기 때문에 가장 오래 걸린 시간이 정답이 된다.


#### 💻코드

```python
import sys
import heapq
input = sys.stdin.readline

# 다익스트라 로직
def dijkstra(start):
    queue = []
    heapq.heappush(queue,(0,start))
    distance[start] = 0

    while queue :
        dist, target = heapq.heappop(queue)
        if dist > distance[target]:
            continue

        else:
            for i in graph[target]:
                cost = dist+i[0]
                if cost < distance[i[1]]:
                    distance[i[1]] = cost
                    heapq.heappush(queue,(cost,i[1]))

T = int(input())
for _ in range(T):
    n,d,c = map(int,input().split())
    graph = [[] for _ in range(n+1)]
    for _ in range(d):
        a,b,s = map(int,input().split())
        # b에서 a로 가는데 걸리는 시간 s
        graph[b].append((s,a))

    distance = [int(1e9)]*(n+1)
    dijkstra(c)
    # 초기값을 제외한 값들로만 즉, 방문한 컴퓨터만 추출하기 위한 리스트 생성
    res = [x for x in distance if x < 1e9]
    print(len(res),max(res))
```



#### ❌ 발생 오류 및 해결

- 

  
