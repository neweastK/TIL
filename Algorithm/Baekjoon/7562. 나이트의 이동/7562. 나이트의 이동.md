## 🐌 알고리즘 문제 풀이

### Baekjoon_7562. 나이트의 이동

#### 📒문제

> 체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?
>
> ![img](https://www.acmicpc.net/upload/images/knight.png)
>
> [<문제 출처>](https://www.acmicpc.net/problem/7562)



#### :pushpin: 입력 및 출력

- 입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.

- 각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.

- 각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.



---

> 예시

```
input :
3
8
0 0
7 0
100
0 0
30 50
10
1 1
1 1

output :
5
28
0
```

----




#### 🚀point

1. bfs로 계산하되 새로운 위치로 이동할 델타를 적절히 지정해준다.

   

#### 🔎풀이

1. 방문 처리 및 순회 횟수를 기록할 visited 배열을 생성한다.

1. 8방향용 델타 배열을 만든다.

1. 방문한 적이 없고 범위내에 속할 경우 이전 위치의 순회 횟수 +1을 visitied 배열에 기록한다.

1. 목적지에 도착할 경우 해당 위치의 순회 횟수를 출력한다.



#### 💻코드

```python
import sys
from collections import deque
input = sys.stdin.readline

def bfs(x,y):
    # visited[x][y] = 1
    queue = deque([(x,y)])

    while queue :
        i,j = queue.popleft()
        if [i,j] == target :
            return visited[i][j]
		
        # 나이트는 8방향으로 이동할 수 있으므로 8번 반복한다
        for d in range(8):
            ni = i + di[d]
            nj = j + dj[d]

            if 0<=ni<I and 0<=nj<I and visited[ni][nj]==0:
                # 이전 방문처리 때 기록한 이동 수에 1을 더한다.
                visited[ni][nj] = visited[i][j]+1
                queue.append((ni,nj))

# 나이트의 이동에 맞게 델타를 설정한다.
di = [-2,-2,-1,-1,1,1,2,2]
dj = [1,-1,2,-2,2,-2,1,-1]

T = int(input())

for _ in range(T):
    I = int(input())
    sx,sy = map(int,input().split())
    target = list(map(int,input().split()))
    visited = [[0]*I for _ in range(I)]
    print(bfs(sx,sy))
```



#### ❌ 발생 오류 및 해결

- 
