## ğŸŒ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´

### Baekjoon_1753. ìµœë‹¨ê²½ë¡œ

#### ğŸ“’ë¬¸ì œ

> ë°©í–¥ê·¸ë˜í”„ê°€ ì£¼ì–´ì§€ë©´ ì£¼ì–´ì§„ ì‹œì‘ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤. ë‹¨, ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ëŠ” 10 ì´í•˜ì˜ ìì—°ìˆ˜ì´ë‹¤.
>
> [<ë¬¸ì œ ì¶œì²˜>](https://www.acmicpc.net/problem/1753)



#### :pushpin: ì…ë ¥ ë° ì¶œë ¥

- ì²«ì§¸ ì¤„ì— ì •ì ì˜ ê°œìˆ˜ Vì™€ ê°„ì„ ì˜ ê°œìˆ˜ Eê°€ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ V â‰¤ 20,000, 1 â‰¤ E â‰¤ 300,000) ëª¨ë“  ì •ì ì—ëŠ” 1ë¶€í„° Vê¹Œì§€ ë²ˆí˜¸ê°€ ë§¤ê²¨ì ¸ ìˆë‹¤ê³  ê°€ì •í•œë‹¤. ë‘˜ì§¸ ì¤„ì—ëŠ” ì‹œì‘ ì •ì ì˜ ë²ˆí˜¸ K(1 â‰¤ K â‰¤ V)ê°€ ì£¼ì–´ì§„ë‹¤. ì…‹ì§¸ ì¤„ë¶€í„° Eê°œì˜ ì¤„ì— ê±¸ì³ ê° ê°„ì„ ì„ ë‚˜íƒ€ë‚´ëŠ” ì„¸ ê°œì˜ ì •ìˆ˜ (u, v, w)ê°€ ìˆœì„œëŒ€ë¡œ ì£¼ì–´ì§„ë‹¤. ì´ëŠ” uì—ì„œ vë¡œ ê°€ëŠ” ê°€ì¤‘ì¹˜ wì¸ ê°„ì„ ì´ ì¡´ì¬í•œë‹¤ëŠ” ëœ»ì´ë‹¤. uì™€ vëŠ” ì„œë¡œ ë‹¤ë¥´ë©° wëŠ” 10 ì´í•˜ì˜ ìì—°ìˆ˜ì´ë‹¤. ì„œë¡œ ë‹¤ë¥¸ ë‘ ì •ì  ì‚¬ì´ì— ì—¬ëŸ¬ ê°œì˜ ê°„ì„ ì´ ì¡´ì¬í•  ìˆ˜ë„ ìˆìŒì— ìœ ì˜í•œë‹¤.

- ì²«ì§¸ ì¤„ë¶€í„° Vê°œì˜ ì¤„ì— ê±¸ì³, ië²ˆì§¸ ì¤„ì— ië²ˆ ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œì˜ ê²½ë¡œê°’ì„ ì¶œë ¥í•œë‹¤. ì‹œì‘ì  ìì‹ ì€ 0ìœ¼ë¡œ ì¶œë ¥í•˜ê³ , ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ëŠ” INFë¥¼ ì¶œë ¥í•˜ë©´ ëœë‹¤.

---

> ì˜ˆì‹œ

```txt
input :
5 6
1
5 1 1
1 2 2
1 3 3
2 3 4
2 4 5
3 4 6

output :
0
2
3
7
INF
```

----




#### ğŸš€point

1. ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ í™œìš©í•˜ì—¬ ê° ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ê³  K ë…¿ê¹Œì§€ì˜ ê±°ë¦¬ë§Œ ì¶œë ¥í•œë‹¤.



#### ğŸ”í’€ì´ ê³„íš

1. ë‹¤ìµìŠ¤íŠ¸ë¼ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•´ë†“ëŠ”ë‹¤.
1. ìµœì¢… ê²°ê³¼ (distance ë¦¬ìŠ¤íŠ¸)ì—ì„œ ë§Œì•½ ë¬´í•œëŒ€ë¼ë©´ INF ë¬¸ìì—´ì„ ì¶œë ¥í•˜ê³  ì•„ë‹Œ ê²½ìš° ê±°ë¦¬ë¥¼ ì¶œë ¥í•œë‹¤.



#### ğŸ’»ì½”ë“œ

```python
import heapq
import sys

def dijkstra(start):
    queue = []
    # në²ˆ ë…¸ë“œì—ì„œ në²ˆ ë…¸ë“œê¹Œì§€ëŠ” ê±°ë¦¬ê°€ 0
    distance[start] = 0
   	# ì´ˆê¸°ê°’ ì¶”ê°€í•´ì£¼ê¸°
    heapq.heappush(queue,(0,start))
    while queue :
        dist, target = heapq.heappop(queue)

        if distance[target] < dist :
            continue
        # target ë²ˆí˜¸ ë…¸ë“œë¥¼ ê±°ì³ì„œ ê° ë…¸ë“œê¹Œì§€ ê°€ëŠ” ê±°ë¦¬ ì¸¡ì •
        for i in graph[target] :
            cost = dist + i[0]
            # ê·¸ ê±°ë¦¬ê°€ í˜„ì¬ ìµœë‹¨ê±°ë¦¬ë¼ê³  ê¸°ë¡ë˜ì–´ìˆëŠ” ê±°ë¦¬ë³´ë‹¤ ì§§ë‹¤ë©´ ê°±ì‹ 
            if distance[i[1]] > cost :
                distance[i[1]] = cost
                # ê°±ì‹ í•´ì¤¬ìœ¼ë¯€ë¡œ queueì— ì¶”ê°€
                heapq.heappush(queue,(cost,i[1]))

input = sys.stdin.readline
V,E = map(int,input().split())
K = int(input())
INF = int(1e9)
graph = [[] for _ in range(V+1)]

for _ in range(E):
    u,v,w = map(int,input().split())
    # uë²ˆ ë…¸ë“œì—ì„œ vë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ëŠ” w
    graph[u].append((w,v))

# ì¶œë°œì§€ë¡œë¶€í„° ê° ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬
distance = [INF]*(V+1)
dijkstra(K)

for v in range(1,V+1) :
    res = distance[v]
    if res == INF :
        print('INF')
    else :
        print(res)
```



#### âŒ ë°œìƒ ì˜¤ë¥˜ ë° í•´ê²°

- ë…¸ë“œ ê°„ì˜ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ë‚¼ ë•Œ, V*Vì˜ 2ì°¨ì› ë°°ì—´ì„ í™œìš©í–ˆë”ë‹ˆ ë©”ëª¨ë¦¬ ì´ˆê³¼ ë°œìƒ

  - Vì˜ ë²”ìœ„ê°€ 20,000ê¹Œì§€ì´ë¯€ë¡œ ìµœëŒ€ 20,000*20,000 ë°°ì—´ì´ ìƒì„±ë¨
  - (ê±°ë¦¬,ëª©ì ì§€) íŠœí”Œì„ ê°’ìœ¼ë¡œ ê°–ëŠ” ë¦¬ìŠ¤íŠ¸ë¡œ ëŒ€ì²´
  - ì´ˆê¸°ì— ë…¸ë“œ ê°„ì— ê°„ì„ ì´ ì—¬ëŸ¬ê°œ ìˆì„ ìˆ˜ ìˆë‹¤ëŠ” ë¬¸ì œì˜ ì¡°ê±´ ë•Œë¬¸ì— ë¬´ì¡°ê±´ 2ì°¨ì› ë°°ì—´ì„ ì‚¬ìš©í•´ì•¼í•œë‹¤ê³  ì°©ê°í•¨
    - ì–´ì°¨í”¼, ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œ ëŒë¦¬ë©´ ê²°êµ­ ì œì¼ ì§§ì€ ê°„ì„ ì„ íƒí•˜ë¯€ë¡œ ì‚¬ì „ì— ì •ë¦¬í•´ì¤„ í•„ìš”ê°€ ì—†ìŒ

- ì˜¤ë¥˜ ì½”ë“œ

  ```python
  import heapq
  import sys
  
  def dijkstra(start):
      queue = [(0,start)]
  
      distance[start] = 0
  
      while queue :
          dist, target = heapq.heappop(queue)
  
          for i in range(1,V):
              cost = dist + graph[target][i]
              if distance[i] > cost :
                  distance[i] = cost
                  heapq.heappush(queue,(cost,i))
  
  input = sys.stdin.readline
  V,E = map(int,input().split())
  K = int(input())
  INF = int(1e9)
  graph = [[INF]*(V+1) for _ in range(V+1)]
  from pprint import pprint
  for _ in range(E):
      u,v,w = map(int,input().split())
      if graph[u][v] > w :
          graph[u][v] = w
  
  for i in range(1,V+1):
      graph[i][i] = 0
  distance = [INF]*(V+1)
  dijkstra(K)
  
  for v in range(1,V+1) :
      res = distance[v]
      if res == INF :
          print('INF')
      else :
          print(res)
  ```

  

