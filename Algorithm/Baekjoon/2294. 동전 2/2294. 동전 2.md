## 🐌 알고리즘 문제 풀이

### Baekjoon_2294. 동전 2

#### 📒문제

> n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.
>
> 사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2294)



#### :pushpin: 입력 및 출력

- 첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다.

- 첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.


---

> 예시

```
input :
3 15
1
5
12

output :
3
```

----




#### 🚀point

1. DP를 활용하여 문제 풀이

- bfs로도 풀이 가능




#### 🔎풀이

1.  dp 배열을 생성한다
    1.  dp[i]는 i원을 만들기 위해 필요한 동전의 최소 개수

    1.  K원을 만드는 것이 목적이므로 배열의 길이는 K+1로 한다

    1.  dp배열은 동전의 개수가 낮은 수치로 채워나가기 때문에 초기값은 INF로 설정

    1.  dp[0] 즉, 0원을 만들 때 필요한 동전의 개수는 0개이므로 0으로 초기화

1.  동전의 개수만큼 반복한다
    1.  입력값(동전)을 받아준다

    1.  dp[i]는 dp[i-동전]+1과 dp[i] 중 작은 값으로 갱신한다
        1.  만약, 지금 받은 동전이 5원일 때, 8원 만드는데 필요한 동전의 개수는 두가지다

        1.  지금 5원을 사용하는 경우와 아닌 경우

        1.  5원을 사용한다면 3원 만들 때의 최소개수에 1을 더해준(5원짜리 동전) 값이고, 사용하지 않는다면 기존에 최소 개수로 여겨지던 값(5원을 받기전까지 최소개수)이다

        1.  둘 중 더 작은 값으로 dp 배열을 채워간다

1.  최종 값이 INF라면 만들 수 없는 경우이므로 -1을 아닌 경우 필요한 최소 동전 개수를 출력한다.




#### 💻코드

```python
import sys
input = sys.stdin.readline

N,K = map(int,input().split())
INF = int(1e9)
dp = [INF]*(K+1)
dp[0] = 0
for _ in range(N):
    num = int(input())
    for i in range(num,K+1):
        dp[i] = min(dp[i],dp[i-num]+1)

answer = dp[-1]
if answer == INF:
    print(-1)
else:
    print(answer)
```



#### ❌ 발생 오류 및 해결

- bfs로 풀이 가능

  - 1,5,12원이 있을 때, queue에 각 동전을 넣고 만들 수 있는 경우의 수를 모두 탐색한다
  - 1+1, 1+5, 1+12 를 먼저 확인하고, 5+1,5+5,5+12 확인. 그 다음 12+1,12+5 ... 계속 탐색
    - 탐색했을 때, 목표하는 값보다 작거나 같으면 그 때의 몇번째 순회인지 값을 입력한다
    - 이미 값이 입력되어있는 경우는 넘어간다 (이미 최소의 개수이므로)
    - 입력 후에 queue에 값을 갱신하여 다시 탐색한다 (그러면, 2+1,2+5,2+12,6+1,6+5...  처럼 탐색할 것)
    - 값이 목표하는 값보다 커진 경우에는 아무것도 하지 않고 넘어간다
  - 최종적으로 k원일 때 순회값을 출력한다

  
