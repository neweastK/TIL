## 🐌 알고리즘 문제 풀이

### Baekjoon_21608. 상어 초등학교

#### 📒문제

> 상어 초등학교에는 교실이 하나 있고, 교실은 N×N 크기의 격자로 나타낼 수 있다. 학교에 다니는 학생의 수는 N2명이다. 오늘은 모든 학생의 자리를 정하는 날이다. 학생은 1번부터 N2번까지 번호가 매겨져 있고, (r, c)는 r행 c열을 의미한다. 교실의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이다.
>
> 선생님은 학생의 순서를 정했고, 각 학생이 좋아하는 학생 4명도 모두 조사했다. 이제 다음과 같은 규칙을 이용해 정해진 순서대로 학생의 자리를 정하려고 한다. 한 칸에는 학생 한 명의 자리만 있을 수 있고, |r1 - r2| + |c1 - c2| = 1을 만족하는 두 칸이 (r1, c1)과 (r2, c2)를 인접하다고 한다.
>
> 1. 비어있는 칸 중에서 좋아하는 학생이 인접한 칸에 가장 많은 칸으로 자리를 정한다.
> 2. 1을 만족하는 칸이 여러 개이면, 인접한 칸 중에서 비어있는 칸이 가장 많은 칸으로 자리를 정한다.
> 3. 2를 만족하는 칸도 여러 개인 경우에는 행의 번호가 가장 작은 칸으로, 그러한 칸도 여러 개이면 열의 번호가 가장 작은 칸으로 자리를 정한다.
>
> 예를 들어, N = 3이고, 학생 N2명의 순서와 각 학생이 좋아하는 학생이 다음과 같은 경우를 생각해보자.
>
> | 학생의 번호 | 좋아하는 학생의 번호 |
> | :---------- | :------------------- |
> | 4           | 2, 5, 1, 7           |
> | 3           | 1, 9, 4, 5           |
> | 9           | 8, 1, 2, 3           |
> | 8           | 1, 9, 3, 4           |
> | 7           | 2, 3, 4, 8           |
> | 1           | 9, 2, 5, 7           |
> | 6           | 5, 2, 3, 4           |
> | 5           | 1, 9, 2, 8           |
> | 2           | 9, 3, 1, 4           |
>
> 가장 먼저, 4번 학생의 자리를 정해야 한다. 현재 교실의 모든 칸은 빈 칸이다. 2번 조건에 의해 인접한 칸 중에서 비어있는 칸이 가장 많은 칸인 (2, 2)이 4번 학생의 자리가 된다.
>
> |      |      |      |
> | ---- | ---- | ---- |
> |      | 4    |      |
> |      |      |      |
>
> 다음 학생은 3번이다. 1번 조건을 만족하는 칸은 (1, 2), (2, 1), (2, 3), (3, 2) 이다. 이 칸은 모두 비어있는 인접한 칸이 2개이다. 따라서, 3번 조건에 의해 (1, 2)가 3번 학생의 자리가 된다.
>
> |      | 3    |      |
> | ---- | ---- | ---- |
> |      | 4    |      |
> |      |      |      |
>
> 다음은 9번 학생이다. 9번 학생이 좋아하는 학생의 번호는 8, 1, 2, 3이고, 이 중에 3은 자리에 앉아있다. 좋아하는 학생이 가장 많이 인접한 칸은 (1, 1), (1, 3)이다. 두 칸 모두 비어있는 인접한 칸이 1개이고, 행의 번호도 1이다. 따라서, 3번 조건에 의해 (1, 1)이 9번 학생의 자리가 된다.
>
> | 9    | 3    |      |
> | ---- | ---- | ---- |
> |      | 4    |      |
> |      |      |      |
>
> 이번에 자리를 정할 학생은 8번 학생이다. (2, 1)이 8번 학생이 좋아하는 학생과 가장 많이 인접한 칸이기 때문에, 여기가 그 학생의 자리이다.
>
> | 9    | 3    |      |
> | ---- | ---- | ---- |
> | 8    | 4    |      |
> |      |      |      |
>
> 7번 학생의 자리를 정해보자. 1번 조건을 만족하는 칸은 (1, 3), (2, 3), (3, 1), (3, 2)로 총 4개가 있고, 비어있는 칸과 가장 많이 인접한 칸은 (2, 3), (3, 2)이다. 행의 번호가 작은 (2, 3)이 7번 학생의 자리가 된다.
>
> | 9    | 3    |      |
> | ---- | ---- | ---- |
> | 8    | 4    | 7    |
> |      |      |      |
>
> 이런식으로 학생의 자리를 모두 정하면 다음과 같다.
>
> | 9    | 3    | 2    |
> | ---- | ---- | ---- |
> | 8    | 4    | 7    |
> | 5    | 6    | 1    |
>
> 이제 학생의 만족도를 구해야 한다. 학생의 만족도는 자리 배치가 모두 끝난 후에 구할 수 있다. 학생의 만족도를 구하려면 그 학생과 인접한 칸에 앉은 좋아하는 학생의 수를 구해야 한다. 그 값이 0이면 학생의 만족도는 0, 1이면 1, 2이면 10, 3이면 100, 4이면 1000이다.
>
> 학생의 만족도의 총 합을 구해보자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/21608)



#### :pushpin: 입력 및 출력

- 첫째 줄에 N이 주어진다. 둘째 줄부터 N2개의 줄에 학생의 번호와 그 학생이 좋아하는 학생 4명의 번호가 한 줄에 하나씩 선생님이 자리를 정할 순서대로 주어진다.

  학생의 번호는 중복되지 않으며, 어떤 학생이 좋아하는 학생 4명은 모두 다른 학생으로 이루어져 있다. 입력으로 주어지는 학생의 번호, 좋아하는 학생의 번호는 N2보다 작거나 같은 자연수이다. 어떤 학생이 자기 자신을 좋아하는 경우는 없다.

- 첫째 줄에 학생의 만족도의 총 합을 출력한다.




---

> 예시

```
input :
3
4 2 5 1 7
3 1 9 4 5
9 8 1 2 3
8 1 9 3 4
7 2 3 4 8
1 9 2 5 7
6 5 2 3 4
5 1 9 2 8
2 9 3 1 4

output :
185
```

----




#### 🚀point

1. 탐색을 통해 주변 0의 개수와, 선호하는 친구의 수를 도출한다



#### 🔎풀이

1.  특정 위치 인근 0의 개수와 누가 있는지를 확인할 수 있는 함수 생성
    1.  친구의 수가 아닌 친구 목록 반환

1.  입력값을 받고 학생 정보는 딕셔너리로 변환
1.  자리 배치도 생성 (arr)
1.  학생 정보를 순회하면서 각 학생의 자리를 선정
    1. 조건1을 위한 인근 위치한 선호 친구 수, 인근 0의 수, 최종 위치를 담을 변수 생성
    2. 3번 조건을 위한 임시 위치 생성 
    3. 자리 배치도를 순회하면서 어느 위치를 해당 학생의 자리로 정할지 결정
       1. 만약 앉아있는 학생이 없는 자리라면 그 자리에 대한 정보 추출
       2. 인근 0의 개수, 친구 목록을 구하고 친구 목록을 활용해 선호하는 친구의 수를 구함
       3. 이후, 각 조건별로 분기처리
          - 친구 수가 최대치라면 해당 위치를 학생의 자리로 선정
          - 친구수가 같다면, 0의 수로 선정
          - 0의 수도 같다면 행과 열의 인덱스 번호로 선정
       4. 최종적으로 해당 학생의 위치를 자리 배치도에서 갱신
1.  자리 배치도를 순회하면서 해당 학생 인근에 있는 친구들 목록 반환
1.  해당 친구가 선호하는 친구인지 아닌지 판단 후, 선호하는 친구의 수 확인
1.  선호하는 친구의 수를 활용하여 만족도 계산
1.  만족도 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline

N = int(input())
students = [list(map(int,input().split())) for _ in range(N**2)]
arr = [[0]*N for _ in range(N)]

dx = [0,0,1,-1]
dy = [1,-1,0,0]

# 특정 위치의 인근 0의 개수와 친구 정보 확인
def set_position(i,j):
    zero_cnt = 0
    friends = []
    for d in range(4):
        ni = i+dx[d]
        nj = j+dy[d]

        if 0<=ni<N and 0<=nj<N:
            if arr[ni][nj] == 0:
                zero_cnt+=1
            else:
                friends.append(arr[ni][nj])
    return zero_cnt,friends

# 주어진 입력값을 딕셔너리 형태로 변경
student_info = {}
for student in students:
    student_info[student[0]] = student[1:]

# 학생들을 순회하면서 위치 지정하기
for num,likes in student_info.items():
	# 가장 많은 좋아하는 친구의 수
    most_friends = 0
    # 가장 많은 0의 개수
    most_zero = 0
    # 3번 조건을 위한 i,j의 임시값
    last = (99999,99999)
    # 최종 위치
    target = (0,0)
    
    # 앉을 수 있는 자리 순회
    # 이를 통해서, 해당 학생의 자리를 선정
    for i in range(N):
        for j in range(N):
            # 앉아있는 학생이 없다면
            if arr[i][j] == 0:
                # 해당 자리 인근의 0의 개수와 선호하는 친구 목록확인
                zero_cnt,friends = set_position(i,j)
                # 친구 수는 set(현재 학생이 좋아하는 친구)-(set(현재 학생이 좋아하는 친구)-set(현재 위치 인근에 위치한 선호 친구)) 으로 구한다
                friends_cnt = len(set(likes)-(set(likes)-set(friends)))
                
                # 만약, 선호하는 친구의 수가 지금까지 최대치라면 최대 친구 값 갱신
                if most_friends < friends_cnt:
                    most_friends = friends_cnt
                    # 친구 수가 같을 때, 0의 수도 알아야하므로 갱신
                    most_zero = zero_cnt
                    # 최종 자리 선정
                    target = (i,j,friends)
                    
                # 만약 친구수가 다른 자리와 똑같다면?
                elif most_friends == friends_cnt:
                    # 0의 개수 기준으로 판단
                    if most_zero < zero_cnt:
                        # 0이 더 많다면 0의 최대 개수 갱신
                        most_zero = zero_cnt
                        # 자리 선정
                        target = (i,j,friends)
                    # 만약 0의 개수도 똑같다면?
                    elif most_zero == zero_cnt:
                        # 행이 가장 작은 것 선택
                        if last[0] > i:
                            target = (i,j,friends)
						# 행의 위치도 같다면 열이 가장 작은 것으로 선택
                        elif last[0] == i and last[1] > j:
                            target = (i,j,friends)

	# 자리 배치도에 학생 넣어주기
    arr[target[0]][target[1]] = num


answer = 0
# 만족도 구하기
for i in range(N):
    for j in range(N):
        # 선호하는 친구 목록 추출
        near_friends = set_position(i,j)[1]
        # 만족도를 구하기 위한 인근 선호하는 친구의 수 계산
        satisfaction = len(set(student_info[arr[i][j]]) - (set(student_info[arr[i][j]]) - set(near_friends)))
        # 만약 만족도가 없는 경우도 있으므로 0 이상일 경우에만 조건 선정
        if satisfaction > 0 :
            answer+=10**(satisfaction-1)
print(answer)
```



#### ❌ 발생 오류 및 해결

- 처음에 target 기초값을 튜플 형태로 주지 않아서 인덱스 오류 발생
  - 초기값을 설정할 때, 이 변수를 어떤 타입으로 쓸 건지도 항상 생각하면서 초기값을 설정해야함
- 3번째 조건을 달아주지 않아서 오류 발생
