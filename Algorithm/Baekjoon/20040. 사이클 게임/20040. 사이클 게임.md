## 🐌 알고리즘 문제 풀이

### Baekjoon_20040. 사이클 게임

#### 📒문제

> 사이클 게임은 두 명의 플레이어가 차례대로 돌아가며 진행하는 게임으로, 선 플레이어가 홀수 번째 차례를, 후 플레이어가 짝수 번째 차례를 진행한다. 게임 시작 시 0 부터 *n* − 1 까지 고유한 번호가 부여된 평면 상의 점 *n* 개가 주어지며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 매 차례 마다 플레이어는 두 점을 선택해서 이를 연결하는 선분을 긋는데, 이전에 그린 선분을 다시 그을 수는 없지만 이미 그린 다른 선분과 교차하는 것은 가능하다. 게임을 진행하다가 처음으로 사이클을 완성하는 순간 게임이 종료된다. 사이클 *C*는 플레이어가 그린 선분들의 부분집합으로, 다음 조건을 만족한다.
>
> > *C*에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 한 번씩만 지나서 출발점으로 되돌아올 수 있다.
>
> 문제는 선분을 여러 개 그리다 보면 사이클이 완성 되었는지의 여부를 판단하기 어려워 이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것이다. 이 문제를 해결하기 위해서 게임의 진행 상황이 주어지면 몇 번째 차례에서 사이클이 완성되었는지, 혹은 아직 게임이 진행 중인지를 판단하는 프로그램을 작성하려 한다.
>
> 입력으로 점의 개수 *n*과 *m* 번째 차례까지의 게임 진행 상황이 주어지면 사이클이 완성 되었는지를 판단하고, 완성되었다면 몇 번째 차례에서 처음으로 사이클이 완성된 것인지를 출력하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/20040)



#### :pushpin: 입력 및 출력

- 입력은 표준입력을 사용한다. 입력의 첫 번째 줄에는 점의 개수를 나타내는 정수 3 ≤ *n* ≤ 500,000 과 진행된 차례의 수를 나타내는 정수 3 ≤ *m* ≤ 1,000,000 이 주어진다. 게임에서 사용하는 *n*개의 점에는 0 부터 *n* − 1 까지 고유한 번호가 부여되어 있으며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 이어지는 *m* 개의 입력 줄에는 각각 *i*번째 차례에 해당 플레이어가 선택한 두 점의 번호가 주어진다 (1 ≤ *i* ≤ *m*).

- 출력은 표준출력을 사용한다. 입력으로 주어진 케이스에 대해, *m* 번째 차례까지 게임을 진행한 상황에서 이미 게임이 종료되었다면 사이클이 처음으로 만들어진 차례의 번호를 양의 정수로 출력하고, *m* 번의 차례를 모두 처리한 이후에도 종료되지 않았다면 0을 출력한다.



---

> 예

```
input :
6 5
0 1
1 2
2 3
5 4
0 4

output :
0

input :
6 5
0 1
1 2
1 3
0 3
4 5

output :
4
```

----




#### 🚀point

1. union-find 활용
1. union을 작업을 수행할 때 이미 같은 집합인지를 확인해서 푼다



#### 🔎풀이

1.  입력값을 받고 본인의 집합을 표시할 parent 배열 생성
    1.  반복문으로 자기 자신을 가르킬 수 있도록 초기값 설정

1.  find 함수와 union 함수 정의
    1.  이때, union에서 입력된 두 노드가 이미 같은 집합이라면, 이전에 이미 연결되었다는 뜻이므로 이번 연결을 통해 사이클이 만들어지게됨
    1.  문제에서는 같은 선분을 그을 수 없기 때문에 위와 같은 로직이 실현 가능함
    1.  따라서, 그 때는 true값을 반환

1.  만약 union 함수를 호출했을 때, True 값을 반환한다면, 사이클이 만들어졌다는 것을 의미
1.  반복문을 끝까지 순회해도 사이클이 만들어지지 않으면 0 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
        return parent[x]
    return x

def union(a,b):
    a = find(a)
    b = find(b)

    if a>b:
        parent[a] = b
    elif a<b:
        parent[b] = a
    # 만약, a와 b가 이미 같은 집합이라면?
    else:
        return True

N,M = map(int,input().split())

parent = [0]*N
for i in range(N):
    parent[i] = i

for j in range(M):
    a,b = map(int,input().split())
    tmp = union(a,b)
    # 이미 같은 집합에 선분을 그엇다면 사이클 완성
    if tmp:
        print(j+1)
        break

else:
    print(0)
```



#### ❌ 발생 오류 및 해결

- 
