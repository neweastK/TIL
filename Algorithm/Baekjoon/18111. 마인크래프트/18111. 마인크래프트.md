## 🐌 알고리즘 문제 풀이

### Baekjoon_18111. 마인크래프트

#### 📒문제

> 팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.
>
> 목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.
> 
> lvalue는 세로 *N*, 가로 *M* 크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.
> 
> 1. 좌표 (*i*, *j*)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
> 2. 인벤토리에서 블록 하나를 꺼내어 좌표 (*i*, *j*)의 가장 위에 있는 블록 위에 놓는다.
> 
> 1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.
> 
>단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는 *B*개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.
> 
>[<문제 출처>](https://www.acmicpc.net/problem/18111)



#### :pushpin: 입력 및 출력

- 첫째 줄에 *N, M*, *B*가 주어진다. (1 ≤ *M*, *N* ≤ 500, 0 ≤ *B* ≤ 6.4 × 107)

- 둘째 줄부터 *N*개의 줄에 각각 *M*개의 정수로 땅의 높이가 주어진다. (*i* + 2)번째 줄의 (*j* + 1)번째 수는 좌표 (*i*, *j*)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.

- 첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.


---

> 예시

```
input :
3 4 99
0 0 0 0
0 0 0 0
0 0 0 1

output :
2 0

input :
3 4 1
64 64 64 64
64 64 64 64
64 64 64 63

output :
1 64

input :
3 4 0
64 64 64 64
64 64 64 64
64 64 64 63

output :
22 63
```

----


#### 🚀point

1. 브루트 포스 문제임을 확인했다면, 시간이 오래 걸릴 것 같아도 최대한 꼼꼼한 방법을 사용하자
1. 몇 층이 최적의 층수인지 알 수 없음
   1. ~~따라서, 0부터 가장 높은 숫자까지의 범위로 잡고, 몇층이 최적인지 구하여야함.~~
   
   2. 0부터가 아니고 배열 내 가장 작은 숫자부터 가장 큰 숫자까지의 범위를 지정하여 몇층이 최적인지 구한다.
   

#### 🔎풀이

1. 배열에 속한 모든 숫자들로 이루어진 리스트 생성
1. 그 중 최댓값과 최솟값을 구하여서 탐색 범위로 지정
1. 배열을 순회하면서 탐색 범위의 숫자로 나머지 숫자들을 모두 맞추고, 그때의 시간과 층수를 구한다.
1. 주어진 인벤토리 내에서 가능하다면 res에 추가, 안된다면 패스한다.
1. res 내에서 시간이 최소이고 높이가 최대인 값을 출력한다.



#### 💻코드

```python
import sys
input = sys.stdin.readline

N,M,B = map(int,input().split())
maps = [list(map(int,input().split())) for _ in range(N)]

# 배열에 속한 숫자들
numbers = []
for i in range(N):
    tmp = list(set(maps[i]))
    numbers.extend(tmp)
    
# 그 중 가장 큰 숫자와 가장 작은 숫자
limit_max = max(set(numbers))
limit_min = min(set(numbers))

# 조건에 맞는 숫자들을 모아놓을 리스트
res = []

# 모든 배열의 수를 돌면서 최솟값부터 최댓값까지의 숫자로 맞춰보자
for number in range(limit_min,limit_max+1):
    # B는 다시 사용해야하므로 원래 값으로 재할당받기
    imsi_B = B
    # 특정 숫자로 나머지를 다 맞췄을 때 걸리는 시간
    time = 0
    
    for i in range(N):
        for j in range(M):
            # number에 맞추기 위해 tmp만큼 더해줘야함
            tmp = number - maps[i][j]
            # 만약 특정 number에 맞추기위해 빼줘야한다면
            if tmp<0 :
                # 빼주는 건 2시간이 걸리므로 빼줘야하는 값*2 만큼 더해준다.
                time += abs(tmp)*2
                # 또한, B에 그만큼 추가를 해준다.
                imsi_B += abs(tmp)
            # 만약 특정 number에 맞추기위해 추가를 해줘야한다면
            elif tmp>0 :
                # 시간은 1시간만 더해준다.
                time += tmp
                # 땅을 높여줬기 때문에 인벤토리에서 그만큼 빼준다.
                imsi_B -= tmp
    # 만약 최종 결과에서 인벤토리가 음수라면 실현 불가하므로 패스
    if imsi_B<0:
        continue
    # 만약 imsi_B가 양수라면 실현 가능하므로 시간과 해당 층수를 추가해준다.
    else :
        res.append([time,number])

# 조건에 만족하는 값들 중 최소시간, 최대층의 결과값을 출력한다
res.sort(key=lambda x:(x[0],-x[1]))
print(*res[0])
```



#### ❌ 발생 오류 및 해결

- 첫번째 시도
  - bfs를 구현해서 구역을 나눈 후 각 구역을 서로 다른 구역에 맞춘다
  - 굳이?? 
- 두번째 시도
  - 배열 안에 있는 모든 숫자들로 이루어진 리스트를 만든 뒤 해당 숫자로 나머지 모든 숫자를 맞춰본다.
  - 배열 안에 있지 않은 숫자가 정답이 될 수도 있음
- 세번째 시도
  - 0부터 배열 안에 있는 가장 큰 수까지 모든 숫자에 모든 배열의 숫자를 맞춰본다.
  - range 사용 시 마지막 부분에 +1을 주지 않아서 오답 처리
- 너무 어렵게 생각하지 말자...
