## 🐌 알고리즘 문제 풀이

### Baekjoon_10800. 컬러볼

#### 📒문제

> 지훈이가 최근에 즐기는 컴퓨터 게임이 있다. 이 게임은 여러 플레이어가 참여하며, 각 플레이어는 특정한 색과 크기를 가진 자기 공 하나를 조종하여 게임에 참여한다. 각 플레이어의 목표는 자기 공보다 크기가 작고 색이 다른 공을 사로잡아 그 공의 크기만큼의 점수를 얻는 것이다. 그리고 다른 공을 사로잡은 이후에도 본인의 공의 색과 크기는 변하지 않는다. 다음 예제는 네 개의 공이 있다. 편의상 색은 숫자로 표현한다.
>
> | 공 번호 | 색   | 크기 |
> | :------ | :--- | :--- |
> | 1       | 1    | 10   |
> | 2       | 3    | 15   |
> | 3       | 1    | 3    |
> | 4       | 4    | 8    |
>
> 이 경우, 2번 공은 다른 모든 공을 사로잡을 수 있다. 반면, 1번 공은 크기가 더 큰 2번 공과 색이 같은 3번 공은 잡을 수 없으며, 단지 4번 공만 잡을 수 있다. 
>
> 공들의 색과 크기가 주어졌을 때, 각 플레이어가 사로잡을 수 있는 모든 공들의 크기의 합을 출력하는 프로그램을 작성하시오. 
>
> [<문제 출처>](https://www.acmicpc.net/problem/10800)



#### :pushpin: 입력 및 출력

- 첫 줄에는 공의 개수를 나타내는 자연수 N이 주어진다(1 ≤ N ≤ 200,000). 다음 N개의 줄 중 i번째 줄에는 i번째 공의 색을 나타내는 자연수 Ci와 그 크기를 나타내는 자연수 Si가 주어진다(1 ≤ Ci ≤ N, 1 ≤ Si ≤ 2,000). 서로 같은 크기 혹은 같은 색의 공들이 있을 수 있다.

- N개의 줄을 출력한다. N개의 줄 중 i번째 줄에는 i번째 공을 가진 플레이어가 잡을 수 있는 모든 공들의 크기 합을 출력한다.


---

> 예

```
input :
4
1 10
3 15
1 3
4 8

output :
8
21
0
3

input :
3
2 3
2 5
2 4

output :
0
0
0
```

----




#### 🚀point

1. 시간초과를 줄일 수 있는 방법 찾기

1. 누적합을 어떻게 갱신해나갈 것인가?

   1. 기본적으로 누적합에서 자신을 포함한 자신과 같은 사이즈들을 모두 뺀다
   1. 그 후, 자신과 동일한 색상의 사이즈들을 모두 뺀다
   1. 그러면, 자신이 흡수할 수 있는 볼들의 사이즈만 남는다
   1. 즉, 누적합-자신-사이즈가같은볼-컬러가같은볼 이 출력값이 되는 것

   

#### 🔎풀이

1.  각종 변수를 선언한다
    1.  모든 공의 사이즈 합을 담을 total 변수를 생성한다

    1.  동일한 사이즈의 공 개수를 기록할 size_cnt 변수 생성

    1.  동일한 컬러의 총 사이즈 합을 기록할 color_cnt 변수 생성

    1.  입력으로 주어지는 공들의 정보를 담을 nums 배열을 생성

1.  입력값을 받으면서 위 변수 값들을 갱신해준다
    1.  size_cnt[size]에 1을 더해준다
        1.  x 사이즈의 개수를 뜻하는 것
    1.  color_cnt[color]에 사이즈를 더해준다
        1.  x 컬러의 사이즈 합을 나타내는 것

    1.  nums 배열에 볼 정보를 넣어주고, 이때, 사이즈를 기준으로 내림차순하기 위해 음수처리해준다
        1.  마지막 정답을 표시하기 위해 입력값의 순서를 기억할 인덱스도 넣어준다
1.  nums 배열을 사이즈 기준으로 내림차순 정렬한다
1.  nums 배열을 모두 순회할 때까지 반복한다 (while문)
    1.  가장 큰 볼부터 탐색을 시작한다
    1.  size_cnt를 통해 동일한 사이즈의 볼이 몇개인지 확인한다
    1.  사이즈가 동일한 볼이 2개 이상일 경우
        1.  누적합에 (사이즈*사이즈가 동일한 볼의 개수) 만큼 빼준다
        1.  그 후, color 배열에서 자신의 컬러에서 자신의 사이즈만큼 빼준다
        1.  1,2번 과정을 동일한 볼의 개수만큼 반복하고 다시 반복하면서 출력할 값을 정해준다
            1.  출력할 값은 (누적합-동일한 컬러의 사이즈들)로 계산한다
        1.  j 값을 사이즈가 동일한 볼의 개수만큼 더해서 갱신해준다
    1.  1개일 경우 
        1.  누적합에서 자신의 사이즈를 빼준다
        1.  색깔 배열 내 자신의 컬러에서 자신의 사이즈만큼 빼준다
        1.  누적합에서 동일한 컬러의 사이즈들을 뺀 값을 출력값으로 정한다
1.  출력값들을 출력한다



#### 💻코드

```python
import sys
input = sys.stdin.readline

N = int(input())
nums = []
total = 0
size_cnt = [0]*2001
color_cnt = [0]*200001

for i in range(N):
    color, size = map(int,input().split())
    # 누적합에 더해주기
    total+=size
    # 같은 사이즈 개수 세기
    size_cnt[size]+=1
    color_cnt[color] += size
    nums.append([-size,color,i])

ans = [0]*N
nums.sort()
j=0
while j<len(nums):
    size,color,idx = nums[j]
    s_cnt = size_cnt[-size]
    if s_cnt >1 :
        total += size*s_cnt
        # 색상 배열에서 자신의 값들을 모두 빼주고 출력값을 정해야함
        # 그래야 total-color_cnt 가 정상적으로 작동함
        for l in range(s_cnt):
            tmp_size,tmp_color,tmp_idx = nums[j+l]
            # 사이즈가 동일한 경우 누적합에서 이미 빼줬기 때문에, 나중에 컬러에서 뺄 때를 대비해서 지금 미리 빼놓는 것
            # 중복으로 마이너스 되지 않도록
            color_cnt[tmp_color] += size
        for a in range(s_cnt):
            tmp_size,tmp_color,tmp_idx = nums[j+a]
            ans[tmp_idx] = total - color_cnt[tmp_color]
        j+=s_cnt
    else:
        total += size
        color_cnt[color] += size
        ans[idx] = total-color_cnt[color]
        j+=1

for k in range(N):
    print(ans[k])
```



#### ❌ 발생 오류 및 해결

- 
