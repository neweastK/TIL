## 🐌 알고리즘 문제 풀이

### Baekjoon_12865. 평범한 배낭

#### 📒문제

> 이 문제는 아주 평범한 배낭에 관한 문제이다.
>
> 한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.
>
> 준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/12865)



#### :pushpin: 입력 및 출력

- 첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

  입력으로 주어지는 모든 수는 정수이다.
  
- 한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.


---

> 예시

```
input :
4 7
6 13
4 8
3 6
5 12

output :
14
```

----




#### 🚀point

1. 유명한 냅색(Knapsack) 알고리즘이라고 한다.
   - [참고 사이트](https://huiyu.tistory.com/entry/DP-01-Knapsack%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C)
1. DP 배열을 만들어서 각 물건을 넣을 때마다 최대 가치를 구한다.
1. **N번 반복할 때 N-1까지만 확인하고 그 전은 확인할 필요가 없도록 구현해야한다!**




#### 🔎풀이

1. K*N 배열을 생성한다.
   1. N번째 물건을 넣을 때마다 가방 무게별로 얻을 수 있는 최대 가치를 기록한다.

1. 최대 가치를 구하는 방법 : 아래 3가지 중 가장 높은 가치의 것을 고른다.
   1. 이전 물건을 그대로 사용하는 경우 (지금 물건을 빼는 경우 _ 무게가 초과되어서)
   1. 현재 물건만 넣는 경우
   1. 현재 물건을 넣어도 무게가 남을 때, 남은 무게만큼의 다른 물건을 추가로 넣는 경우(이전에 넣었던 물건 중 고려)

1. DP 배열을 모두 순회한 후 마지막 행에서 가장 큰 값을 구한다.



#### 💻코드

```python
import sys
input = sys.stdin.readline

N,K = map(int,input().split())

dp = [[0]*(K+1) for _ in range(N+1)]

for i in range(1,N+1):
    W,V = map(int,input().split())
    for j in range(1,K+1):
        # 만약 남은 가방의 무게보다 물건의 무게가 크다면?
        if W>j :
            # 이전 행의 물건을 그대로 넣어놓는다.
            dp[i][j] = dp[i-1][j]
        # 남은 가방의 무게보다 물건의 무게가 가볍다면?
        else :
            # 해당 물건을 넣어도 가방에 무게가 남는다면
            if j-W>0 :
                # 지금 물건을 넣기 전까지의 상황에서, 
                # 남는 무게에서의 최대 가치를 현재 물건의 가치와 더해준다.
                # 그리고 이전 물건으로 가방을 채우는게 나은지, 아니면 갱신해야하는지 비교한다.
                dp[i][j] = max(V+dp[i-1][j-W], dp[i-1][j])
            else :
                # 만약 물건을 넣었을 때 가방에 무게가 남지 않는다면
                # 지금 물건의 가치와 이전 물건의 가치만을 비교한다.
                dp[i][j] = max(V, dp[i-1][j])

print(max(dp[-1]))
```



#### ❌ 발생 오류 및 해결

- 
