## 🐌 알고리즘 문제 풀이

### Baekjoon_19622. 회의실 배정 3

#### 📒문제

> 서준이는 아빠로부터 N개의 회의와 하나의 회의실을 선물로 받았다. 각 회의는 시작 시간, 끝나는 시간, 회의 인원이 주어지고 한 회의실에서 동시에 두 개 이상의 회의가 진행될 수 없다. 단, 회의는 한번 시작되면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작 시간은 끝나는 시간보다 항상 작다. N개의 회의를 회의실에 효율적으로 배정할 경우 회의를 진행할 수 있는 최대 인원을 구하자.
>
> - 제한
>   - 1 ≤ N ≤ 100,000
>   - 임의의 회의 K(1≤ K ≤ N)는 회의 K − 1과 회의 K + 1과는 회의 시간이 겹치고 다른 회의들과는 회의 시간이 겹치지 않는다.
>   - 모든 회의의 시작 시간과 끝나는 시간은 231 − 1보다 작거나 같은 자연수 또는 0이다.
>   - 모든 회의의 시작 시간과 끝나는 시간은 서로 다르다.
>   - 회의 인원은 1,000보다 작거나 같은 자연수 이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/19622)



#### :pushpin: 입력 및 출력

- 첫째 줄에 회의의 수 N이 주어진다. 둘째 줄부터 N + 1 줄까지 공백을 사이에 두고 회의의 시작시간, 끝나는 시간, 회의 인원이 주어진다.

- 첫째 줄에 회의실에서 회의를 진행할 수 있는 최대 인원을 출력한다.


---

> 예시

```
input :
6
10 40 80
30 60 60
50 80 70
70 100 100
90 120 40
110 140 50

output :
230
```

----




#### 🚀point

1. DP를 활용하여 문제 풀이




#### 🔎풀이

1.  입력값 N을 받고, N 만큼의 배열을 생성
    1.  해당 배열은 n개의 회의를 받았을 때 받을 수 있는 최대 인원을 의미

1.  dp 배열을 하나씩 채워간다
    1.  현재 회의를 받았을 때 받을 수 있는 최대 인원은, 현재 회의의 인원+지금까지의 최대 인원
        1.  단, 직전 회의와는 반드시 회의시간이 겹치므로, 직전 회의가 아닌 2번째 전과 3번째 전 회의를 비교해야함
    
        1.  왜냐하면, 두번째 전 회의도 마찬가지로 직전 회의 즉, 3번째 전 회의값을 포함하지 못함
    
        1.  따라서, 두번째 전 회의와 세번째 전 회의를 모두 확인해줘야함
    
        1.  네번째 전, 다섯번째 전 회의는 확인 안해도 되는가?
            1.  어차피, 그 이후부터는 값이 적용되어있음
    
            1.  네번째 전 회의는, 2번째 전 회의에서 고려를 하게됨
    
    1.  dp 배열은 회의에 대한 입력값을 하나씩 받을 때마다 채워나간다
    
1.  채워진 dp배열에서 최댓값을 구한다



#### 💻코드

```python
import sys
input = sys.stdin.readline

N = int(input())
# dp[i]는 i번째 회의까지 배정받았을 때 최대 인원
dp = [0]*N

for i in range(N):
    s,e,people = map(int,input().split())
    
    # 초기에는 그냥 할당
    if i<2:
        dp[i] = people
	# 3번째 회의부터는 두번째 전 회의와 3번째 전 회의 중 큰 값에 현재 회의 인원 더해주기
    # 왜냐하면, 바로 직전이나 직후 회의는 회의시간이 무조건 겹치기 때문
    else:
        dp[i] = max(dp[i-2],dp[i-3])+people
# dp 에는 각 회의까지 받았을 때의 최대 인원이 나오게됨
# 따라서, dp배열에서 가장 큰 값이 가장 많이 받을 수 있는 인원
ans = max(dp)
print(ans)
```



#### ❌ 발생 오류 및 해결

- dp배열의 마지막 원소가 당연히 가장 크다고 생각하고 dp[-1] 출력해서 오류 발생

  
