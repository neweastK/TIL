## 🐌 알고리즘 문제 풀이

### Baekjoon_14890. 경사로

#### 📒문제

> 크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다. 
>
> 오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다. 
>
> 다음과 같은 N=6인 경우 지도를 살펴보자.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/1.png)
>
> 이때, 길은 총 2N개가 있으며, 아래와 같다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/2.png)
>
> 길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.
>
> - 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
> - 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
> - 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
>
> 아래와 같은 경우에는 경사로를 놓을 수 없다.
>
> - 경사로를 놓은 곳에 또 경사로를 놓는 경우
> - 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
> - 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
> - 경사로를 놓다가 범위를 벗어나는 경우
>
> L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/3.png)
>
> 경사로를 놓을 수 없는 경우는 아래와 같다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14890/4.png)
>
> 위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.
>
> 가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.
>
> ![img](https://upload.acmicpc.net/255e47cf-0988-4b7f-b81c-2742f010a4c5/-/preview/)
>
> 지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1939)



#### :pushpin: 입력 및 출력

- 첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.

- 첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.


---

> 예시

```
input :
6 2
3 3 3 3 3 3
2 3 3 3 3 3
2 2 2 3 2 3
1 1 1 2 2 2
1 1 1 3 3 1
1 1 2 3 3 2

output :
3

input :
6 2
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2

output :
7

input :
6 3
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2

output :
3

input :
6 1
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2

output :
11
```

----




#### 🚀point

1. 각 칸 옆에 있는 숫자와 차이를 이용해 구현
   1. 차이가 1이거나 -1이면 각각 오른쪽과 왼쪽 L개의 칸을 확인한다
   2. 0이면 다음 칸을 확인한다
   3. |2| 이상이면 해당 줄에서는 길을 만들 수가 없다




#### 🔎풀이

1.  입력값을 모두 받는다

1.  행 기준으로 각 칸의 높이 차이를 기록할 arr_row와 열 기준으로 각 칸의 높이 차이를 기록할 arr_col을 생성

1.  각 칸을 순회하면서 arr_row와 arr_col을 채워준다
    1.  무조건 오른쪽 칸을 기준으로 높이 차 계산

    1.  마지막 칸은 비교할 칸이 없음
        1.  나중을 위해 계산에 영향을 미치지 않는 값으로 넣어놓기

1.  각 행열을 돌면서 길을 만들 수 있는지 확인하기
    1.  칸의 차이가 1일 때, 현재 칸이 더 높다는 뜻이므로 오른쪽 칸에 경사로 설치해야함
        1.  오른쪽 L개의 칸이 모두 같은 높이인지 확인
        1.  그리고 이미 경사로가 놓이지는 않았는지 확인
        1.  L개의 같은 높이면서 경사로가 없다면 경사로 설치
            1.  경사로 설치했다는 방문 처리

    1.  칸의 차이가 -1일 때, 현재 칸이 더 낮다는 뜻이므로 왼쪽 칸에 경사로 설치
        1.  왼쪽 L-1개 칸이 모두 같은 높이인지 확인 (현재 위치 제외하고 카운트)
        1.  방문 배열 확인 후 경사로 설치

    1.  경사로를 설치 할 수 없다는 것은 길을 만들 수 없다는 것이므로 바로 중단
    1.  만약, 각 길에서 중단되지 않고 끝까지 반복 수행을 완료했다면 길이 만들어졌다는 뜻이므로 개수 1추가

1.  4번의 과정을 arr_row와 arr_col 한번씩 수행

1.  최종 길을 만들 수 있는 개수 출력




#### 💻코드

```python
import sys
input = sys.stdin.readline

N,L = map(int,input().split())
arr = [list(map(int,input().split())) for _ in range(N)]

# 행 기준과 열 기준으로 카운트 하기 위해 분리
arr_row = [[0]*N for _ in range(N)]
arr_col = [[0]*N for _ in range(N)]

# 행 기준으로 각 칸과 오른쪽 칸의 높이 차 기록
for i in range(N):
    arr_row[i][-1] = 9999
    for j in range(N-1):
        arr_row[i][j] = arr[i][j] - arr[i][j+1]
# 열 기준으로 각 칸과 아랫쪽 칸의 높이 차 기록
for j in range(N):
    arr_col[j][-1] = 9999
    for i in range(N-1):
        arr_col[j][i] = arr[i][j] - arr[i+1][j]

# 몇개의 길을 만들 수 있는지 확인
# array는 높이 차이가 기록된 배열, visited는 이미 경사로를 설치했는지 기록할 배열
def check(array,visited):
    # 길의 개수
    cnt = 0
    for i in range(N):
        for j in range(N):
            val = array[i][j]
            # 만약 옆 칸과의 차이가 0이거나 맨 마지막 칸이면
            # 경사로 필요 없으므로 다음 칸 확인
            if val == 0 or val==9999:
                continue
            # 만약 옆 칸과의 차이가 1이면 현재 칸이 더 높다는 뜻
            elif val == 1:
                # 오른쪽 L개의 칸에 경사로 설치해야함
                # 오른쪽 L개 칸이 모두 높이가 같고 설치된 경사로가 아직 없다면
                if array[i][j+1:j+L].count(0) == L-1 and visited[i][j+1:j+L+1].count(1) == 0:
                    # 설치 후 방문처리
                    visited[i][j+1:j+L+1] = [1]*L
                    continue
                # 조건에 안맞으면 해당 길은 어차피 못 만듦
                # 시간을 줄이기 위해 중단
                else:
                    break
            # 옆 칸과의 차이가 -1이면 현재 칸이 더 낮다는 뜻
            elif val == -1:
                # 현재 칸과 왼쪽 L-1개의 칸에 경사로를 설치해야함
                # 조건은 위와 마찬가지
                if array[i][j-(L-1):j].count(0) == L-1 and visited[i][j-(L-1):j+1].count(1) == 0:
                    # 방문 처리
                    visited[i][j-(L-1):j+1] = [1]*L
                    continue
                else:
                    break
            # 차이의 절댓값이 1보다 크면 어차피 경사로 설치 못하므로 다음 길 확인
            else:
                break
        # 무사히 반복문을 수행했다면 길 하나가 만들어진 것
        else:
            cnt += 1
    return cnt

# 행 기준과 열 기준으로 한번씩 확인
res = check(arr_row,[[0]*N for _ in range(N)])+check(arr_col,[[0]*N for _ in range(N)])
# 최종 결과 출력
print(res)
```



#### ❌ 발생 오류 및 해결

- zip 메서드로 2차원 배열 회전하는 연습 해봤으면 좋았을 것 같다 (아쉬움)

  
