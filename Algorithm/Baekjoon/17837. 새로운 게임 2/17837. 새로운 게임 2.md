## 🐌 알고리즘 문제 풀이

### Baekjoon_17837. 새로운 게임 2

#### 📒문제

> 재현이는 주변을 살펴보던 중 체스판과 말을 이용해서 새로운 게임을 만들기로 했다. 새로운 게임은 크기가 N×N인 체스판에서 진행되고, 사용하는 말의 개수는 K개이다. 말은 원판모양이고, 하나의 말 위에 다른 말을 올릴 수 있다. 체스판의 각 칸은 흰색, 빨간색, 파란색 중 하나로 색칠되어있다.
>
> 게임은 체스판 위에 말 K개를 놓고 시작한다. 말은 1번부터 K번까지 번호가 매겨져 있고, 이동 방향도 미리 정해져 있다. 이동 방향은 위, 아래, 왼쪽, 오른쪽 4가지 중 하나이다.
>
> 턴 한 번은 1번 말부터 K번 말까지 순서대로 이동시키는 것이다. 한 말이 이동할 때 위에 올려져 있는 말도 함께 이동한다. 말의 이동 방향에 있는 칸에 따라서 말의 이동이 다르며 아래와 같다. 턴이 진행되던 중에 말이 4개 이상 쌓이는 순간 게임이 종료된다.
>
> - A번 말이 이동하려는 칸이
>   - 흰색인 경우에는 그 칸으로 이동한다. 이동하려는 칸에 말이 이미 있는 경우에는 가장 위에 A번 말을 올려놓는다.
>     - A번 말의 위에 다른 말이 있는 경우에는 A번 말과 위에 있는 모든 말이 이동한다.
>     - 예를 들어, A, B, C로 쌓여있고, 이동하려는 칸에 D, E가 있는 경우에는 A번 말이 이동한 후에는 D, E, A, B, C가 된다.
>   - 빨간색인 경우에는 이동한 후에 A번 말과 그 위에 있는 모든 말의 쌓여있는 순서를 반대로 바꾼다.
>     - A, B, C가 이동하고, 이동하려는 칸에 말이 없는 경우에는 C, B, A가 된다.
>     - A, D, F, G가 이동하고, 이동하려는 칸에 말이 E, C, B로 있는 경우에는 E, C, B, G, F, D, A가 된다.
>   - 파란색인 경우에는 A번 말의 이동 방향을 반대로 하고 한 칸 이동한다. 방향을 반대로 바꾼 후에 이동하려는 칸이 파란색인 경우에는 이동하지 않고 가만히 있는다.
>   - 체스판을 벗어나는 경우에는 파란색과 같은 경우이다.
>
> 다음은 크기가 4×4인 체스판 위에 말이 4개 있는 경우이다.
>
> ![img](https://upload.acmicpc.net/0aec7e3d-e8f5-428a-bebc-6a0fd514b387/-/preview/)
>
> 첫 번째 턴은 다음과 같이 진행된다.
>
> | ![img](https://upload.acmicpc.net/46796304-b486-4420-9d2c-ea49e2d5665b/-/preview/) | ![img](https://upload.acmicpc.net/04643ced-fdfd-46f5-a07e-374704dbb1c5/-/preview/) | ![img](https://upload.acmicpc.net/46f4bfab-841b-41c8-842e-56027816f846/-/preview/) | ![img](https://upload.acmicpc.net/fcccf76c-9431-4ff5-8a05-7dbd2feff142/-/preview/) |
> | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
>
> 두 번째 턴은 다음과 같이 진행된다.
>
> | ![img](https://upload.acmicpc.net/36568153-8c2a-4fe9-b45f-72036c97f5aa/-/preview/) | ![img](https://upload.acmicpc.net/babead43-4acc-425d-917a-54dcc6f45414/-/preview/) | ![img](https://upload.acmicpc.net/1edd5ed8-0f4c-4c6d-b304-3b7642f42c6f/-/preview/) | ![img](https://upload.acmicpc.net/028a5dd2-5524-4475-8439-9e7794e28ee4/-/preview/) |
> | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
>
> 체스판의 크기와 말의 위치, 이동 방향이 모두 주어졌을 때, 게임이 종료되는 턴의 번호를 구해보자.
>
> [<문제 출처>](https://www.acmicpc.net/problem/17837)



#### :pushpin: 입력 및 출력

- 첫째 줄에 체스판의 크기 N, 말의 개수 K가 주어진다. 둘째 줄부터 N개의 줄에 체스판의 정보가 주어진다. 체스판의 정보는 정수로 이루어져 있고, 각 정수는 칸의 색을 의미한다. 0은 흰색, 1은 빨간색, 2는 파란색이다.

  다음 K개의 줄에 말의 정보가 1번 말부터 순서대로 주어진다. 말의 정보는 세 개의 정수로 이루어져 있고, 순서대로 행, 열의 번호, 이동 방향이다. 행과 열의 번호는 1부터 시작하고, 이동 방향은 4보다 작거나 같은 자연수이고 1부터 순서대로 →, ←, ↑, ↓의 의미를 갖는다.

  같은 칸에 말이 두 개 이상 있는 경우는 입력으로 주어지지 않는다.

- 게임이 종료되는 턴의 번호를 출력한다. 그 값이 1,000보다 크거나 절대로 게임이 종료되지 않는 경우에는 -1을 출력한다.



---

> 예시

```
input :
4 4
0 0 2 0
0 0 1 0
0 0 1 2
0 2 0 0
2 1 1
3 2 3
2 2 1
4 1 2

output :
-1

input :
4 4
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
1 1 1
1 2 1
1 3 1
1 4 1

output :
1

input :
4 4
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
1 1 1
1 2 1
1 3 1
2 4 3

output :
1

input :
6 10
0 1 2 0 1 1
1 2 0 1 1 0
2 1 0 1 1 0
1 0 1 1 0 2
2 0 1 2 0 1
0 2 1 0 2 1
1 1 1
2 2 2
3 3 4
4 4 1
5 5 3
6 6 2
1 6 3
6 1 2
2 4 3
4 2 1

output :
7
```

----




#### 🚀point

1. 말이 겹쳐져있는(쌓여있는) 것을 어떻게 구현할 것인가?
   1. 3차원 배열 활용






#### 🔎풀이

1.  말의 정보를 담을 두 개의 변수 선언
    1.  nodes 배열은 즉시 갱신하지 않아도 되는 값
    1.  node_loc 객체는 어떤 이동이든 즉시 갱신해야되는 값

1.  입력값을 받으면서 각 변수에 맞는 정보를 할당
    1.  nodes 배열에는 말 번호, 말의 방향, 파랑(혹은 바깥 범위) 반복 여부
    1.  node_loc 객체에는 행 위치, 열 위치, 층

1.  arr 배열은 게임판에 각 칸의 상태를 나타내는 배열
1.  arr_node는 각 말이 어떤 게임판에 위치하고 있는지 나타내는 3차원 배열
    1.  겹쳐있는 경우, 위 층으로 보낸다
    1.  초기에는 겹쳐있는 경우가 없으므로 입력값 그대로 0층에 해당 말 번호를 입력한다

1.  delta는 각 방향에 맞게 이동하는 이동 방향
1.  node를 순회하는데 이때, deque를 이용한다
    1.  만약, 파랑이나 범위 밖으로 이동한 경우 해당 말을 바로 다시 확인해야하기 때문
    1.  단순 for문을 사용하면 즉시 그 말을 다시 체크할 수 없음

1.  popleft로 하나의 말 정보를 반환
    1.  해당 말의 정보를 토대로 새로 이동할 위치를 확인한다
    1.  해당 위치가 어떤 색인지 확인한다
        1.  흰색인 경우
            1.  새로 이동할 칸에 다른 말이 있는지 확인 후, 현재 말이 위치할 수 있는 층을 구한다
            1.  해당 층으로 이동한 후, 즉시 node_loc 객체의 값을 갱신해준다 (층과 행열 위치)
            1.  현재 말 위에 있었던 말들도 이동시켜준다
            1.  현재 말의 새로운 층 수에 1씩 더해주면서 이동시킨다
            1.  이동시킨 말의 원래 위치는 0으로 초기화한다
            1.  이동하면서 층수가 4층이면 조건을 만족하므로 종료한다

        1.  빨강색인 경우
            1.  새로 이동할 칸에 다른 말이 있는지 확인 후, 현재 말이 위치할 수 있는 층을 구한다
            1.  해당 층으로 이동할 때, 역순으로 이동해야하므로 현재 말 위에 몇개의 말이 있었는지 확인한다
            1.  새로 이동할 칸의 제일 낮은 층에는 원래 있었던 곳의 제일 높은 곳에 위치한 말이 이동한다. 
            1.  이동 후 즉시 갱신해줘야하는 행,열,층 값을 갱신해준다
            1.  만약 제일 높은 층이 4층이라면 종료한다

        1.  파랑이거나 범위를 벗어난 경우
            1.  우선, node 배열에 있던 blue_check를 확인한다
            1.  해당 값이 1이면 이미 이전에 파랑을 갔다 왔다는 것
                1.  이 경우, 그대로 nodes에 append 해준다

            1.  해당 값이 0이면 처음 파랑에 위치한 것이므로 방향을 변경해준다
                1.  방향 변경 후, appendleft를 이용해 다시 넣어준다
                1.  방향 변경 후 바로 이동이 가능하도록 하기 위함

1.  하나의 말 이동이 완벽히 끝나는 경우 turn 변수에 1을 더해준다
1.  종료 조건에 맞게 되면 turn을 말의 개수로 나눠서 총 몇차례의 턴이 필요했는지 구한다
1.  turn을 말의 개수로 나눈 값이 1000을 넘으면 -1을 출력하고 종료한다.



#### 💻코드

```python
from collections import deque
import sys
input = sys.stdin.readline

N,K = map(int,input().split())
# N개의 행렬정보
arr = [list(map(int,input().split())) for _ in range(N)]

# nodes에는 같이 이동할 때 갱신하지 않아도 되는 값
nodes = deque([])
# node_loc에는 같이 이동할 경우 바로 갱신되어야하는 값
node_loc = {}

# k개의 노드 정보 (현재위치, 방향)
for k in range(K):
    n,m,direction = map(int,input().split())
    # 노드 번호, 방향, 파랑
    nodes.append([k+1,direction,0])
    # 행 위치, 열 위치, 층
    node_loc[k+1] = [n-1,m-1,0]

# 3차원 행렬
arr_node = [[[0]*N for _ in range(N)] for _ in range(N)]
delta = [(0,0),(0,1),(0,-1),(-1,0),(1,0)]

# 현재 노드들의 위치를 맵 상에 나타내기
# 처음부터 같은 위치인 경우 없음
for node in nodes:
    arr_node[0][node_loc[node[0]][0]][node_loc[node[0]][1]] = node[0]

turn = K
while nodes:
    # 턴 수가 1000을 넘기면 -1 출력
    if turn//K>1000:
        print(-1)
        break

    node = nodes.popleft()
    key = node[0]
    direction = node[1]
    blue_chcek = node[2]

    x,y = node_loc[key][0],node_loc[key][1]
    floor = node_loc[key][2]

    # 이동하려는 위치
    nx,ny = x+delta[direction][0],y+delta[direction][1]

    # 이동하려는 위치가 범위 안에 속하는가
    if 0<=nx<N and 0<=ny<N:
        # 새로운 위치가 흰색이라면
        if arr[nx][ny] == 0:
            # 이미 있는 말 위에다가 쌓아주기
            # i층에 자리를 잡게됨
            for i in range(N):
                # 만약 i층에 말이 없다면
                if arr_node[i][nx][ny] == 0:
                    # 해당 층이 현재 이동하려는 말의 위치
                    arr_node[i][nx][ny] = key
                    # 이동했으므로, 말의 위치와 층을 갱신해줌
                    node_loc[key][0],node_loc[key][1],node_loc[key][2] = nx,ny,i
                    # 원래 위치는 0으로 초기화
                    arr_node[floor][x][y] = 0
                    # 만약, 층이 4층(인덱스로는 3)이면 종료
                    if i == 3:
                        print(turn//K)
                        quit()
                    break
            # 말 위에 있던 애들 같이 옮기기
            # 첫 말의 위치인 i층 위에서부터 쌓아주기
            l = 1
            # 현재 말의 원래 위치인 floor 다음 층부터 옮겨주기
            for j in range(floor+1,N):
                # 0이 아니라는 것은 말이 있다는 뜻
                if arr_node[j][x][y] != 0:
                    # i층 위에 올려주기
                    arr_node[i+l][nx][ny] = arr_node[j][x][y]
                    # 위치와 층수 바로 갱신해주기
                    node_loc[arr_node[j][x][y]][0],node_loc[arr_node[j][x][y]][1],node_loc[arr_node[j][x][y]][2] = nx,ny,i+l
                    # 원래 위치 초기화
                    arr_node[j][x][y] = 0

                    # 만약 층 수가 4층이면 종료
                    if i+l == 3:
                        print(turn//K)
                        quit()
                    l+=1

            # 바뀐값으로 다시 넣어주기
            nodes.append([key,direction,0])
            # 한 말의 차례 끝!
            turn+=1
            continue

        # 새로운 위치가 빨강이라면
        if arr[nx][ny] == 1:
            top = floor
            # 현재 말 위에 있는 제일 높은 위치
            for loc in range(N-1,floor-1,-1):
                if arr_node[loc][x][y] != 0:
                    # 현재 말 위 제일 높은 위치 loc
                    # 위에 아무것도 없으면 현재 말의 위치가 제일 높은 위치로 저장
                    top = loc
                    break


            # 새로 이동할 위치에 맞는 층 찾기
            for i in range(N):
                if arr_node[i][nx][ny] == 0:
                    # 빨강칸이므로 역순으로 배치
                    if top>=floor:
                        # i층 즉, 새로운 위치의 제일 낮은 층은 이전 위치에서 제일 높은 위치에 있던 말이 차지
                        arr_node[i][nx][ny] = arr_node[top][x][y]
                        # 위치값과 층수 갱신
                        node_loc[arr_node[top][x][y]][0],node_loc[arr_node[top][x][y]][1],node_loc[arr_node[top][x][y]][2] = nx,ny,i
                        # 원래 위치 초기화
                        arr_node[top][x][y] = 0
                        # 다음 층을 위해 top 값 갱신
                        top-=1

                        # 만약 새로운 위치가 4라면 종료
                        if i == 3:
                            print(turn//K)
                            quit()
                    else:
                        break

            # 현재 움직인 말을 이제 맨 뒤로 넣어주기
            nodes.append([key,direction,0])
            # 현재 움직인 말을 다 옮겼으니 끝!
            turn+=1
            continue

    # 만약 파랑색이거나, 범위를 벗어난 경우
    # 파랑을 이미 갔다 온건지 아닌지 판단할 blue_check
    # 이번에 처음 파랑이거나 범위를 벗어났다면
    # 방향 변경해주기
    if blue_chcek == 0:
        if direction == 1:
            direction = 2
        elif direction == 2:
            direction = 1
        elif direction == 3:
            direction = 4
        else:
            direction = 3

        # 그리고 다시 그 새로운 위치로 이동해야하므로 appendleft 사용
        # 이미 파랑을 한번 다녀온 상태이므로 blue_check는 1로 변경
        nodes.appendleft([key,direction,1])
    else:
        # 만약 두번째 파랑이거나 범위를 벗어났다면, 그 위치 그대로 아무것도 안함
        # blue_check를 0으로, 그리고 현재 위치 갱신X
        nodes.append([key,direction,0])
        # 이번 말은 끝
        turn+=1
```



#### ❌ 발생 오류 및 해결

- for문 역순회시 마지막에 -1 안 넣은 실수
- 게임의 종료 시점은 한 칸에 말 4개가 있는 경우인데, 모든 말이 있어야되는 것으로 착각
  - 종료 조건을 잘못 설정
