## 🐌 알고리즘 문제 풀이

### Baekjoon_2585. 경비행기

#### 📒문제

> 경비행기 독수리호가 출발지 S에서 목적지 T로 가능한 빠른 속도로 안전하게 이동하고자 한다. 이때, 경비행기의 연료통의 크기를 정하는 것이 중요한 문제가 된다. 큰 연료통을 장착하면 중간에 내려서 급유를 받는 횟수가 적은 장점이 있지만 연료통의 무게로 인하여 속도가 느려지고, 안정성에도 문제가 있을 수 있다. 한편 작은 연료통을 장착하면 비행기의 속도가 빨라지는 장점이 있지만 중간에 내려서 급유를 받아야 하는 횟수가 많아지는 단점이 있다. 문제는 중간에 내려서 급유를 받는 횟수가 k이하 일 때 연료통의 최소용량을 구하는 것이다. 아래 예를 보자.
>
> ![img](https://upload.acmicpc.net/74546cce-0762-4546-b2b9-aee04a54f1f2/-/preview/)
>
> 위 그림은 S, T와 7개의 중간 비행장의 위치를 나타내고 있는 그림이다. 위 예제에서 중간급유를 위한 착륙 허용 최대횟수 k=2라면 S-a-b-T로 가는 항로가 S-p-q-T로 가는 항로 보다 연료통이 작게 된다. 왜냐하면, S-p-q-T항로에서 q-T의 길이가 매우 길어서 이 구간을 위해서 상당히 큰 연료통이 필요하기 때문이다. 문제는 이와 같이 중간에 최대 K번 내려서 갈 수 있을 때 최소 연료통의 크기가 얼마인지를 결정하여 출력하면 된다. 참고사항은 다음과 같다.
>
> 1. 모든 비행기는 두 지점 사이를 반드시 직선으로 날아간다. 거리의 단위는 ㎞이고 연료의 단위는 ℓ(리터)이다. 1ℓ당 비행거리는 10㎞이고 연료주입은 ℓ단위로 한다.
> 2. 두 위치간의 거리는 평면상의 거리이다. 예를 들면, 두 점 g=(2,1)와 h=(37,43)간의 거리 d(g,h)는 ((2−37)^2+(1−43)^2)^0.5 = 54.671... 이고 50＜d(g,h) ≤ 60이므로 필요한 연료는 6ℓ가 된다.
> 3. 출발지 S의 좌표는 항상 (0,0)이고 목적지 T의 좌표는 (10000,10000)으로 모든 입력 데이터에서 고정되어 있다.
> 4. 출발지와 목적지를 제외한 비행장의 수 n은 3 ≤ n ≤ 1000이고 그 좌표 값 (x,y)의 범위는 0＜x,y＜10000의 정수이다. 그리고 최대 허용 중간급유 횟수 k는 0 ≤ k ≤ 1000이다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2585)



#### :pushpin: 입력 및 출력

- 첫 줄에는 n과 k가 하나의 공백을 사이에 두고 주어진다. 그 다음 n개의 줄에는 각 비행장 (급유지)의 정수좌표가 x y 형식으로 주어진다.

- S에서 T까지 k번 이하로 중간급유 하여 갈 수 있는 항로에서의 최소 연료통 용량에 해당되는 정수를 출력한다.



---

> 예시

```
input :
10 1
10 1000
20 1000
30 1000
40 1000
5000 5000
1000 60
1000 70
1000 80
1000 90
7000 7000

output:
708
```

----




#### 🚀point

1. ~~다익스트라로 도착지까지 가는 최단거리를 구한 후 몇 개의 노드를 거쳐가는지 계산~~
1. BFS로 각 노드에서 다른 노드까지의 거리를 기준으로 거쳐가는 노드 계산
   1. 중간 노드에 들리면 무조건 연료 충전!!
      1. 해도 되고 안해도 되고가 아닌 무조건 충전

   1. 이분탐색에서 탐색하는 값은 연료통의 용량이다!
      1. 이는, 기름의 맥시멈을 뜻하기도 함
      1. 만약, 연료통 용량이 10L이고 A노드에서 B노드로 갔을 때 5L를 썼다면, B노드에서 연료보급 했을 때 15L가 아닌 10L가 된다
         1. 연료가 남아있어도 최대 10L까지밖에 안된다는 뜻




#### 🔎풀이

1.  입력값을 받고 두 노드간의 거리를 계산해주는 함수를 정의한다
1.  받은 입력값을 활용하여 각 노드간의 거리를 나타내는 maps 배열을 생성한다
    1.  maps[i]\[j]는 i에서 j까지의 거리를 의미

1.  출발점과 연료통 용량이 주어졌을 때, 거쳐가는 노드 개수를 보여줄 bfs 함수를 정의한다
    1.  방문배열(visited)는 해당 노드까지 오는데 거쳐간 노드 개수의 최솟값을 의미한다
    1.  즉, visited[i]는 i 노드까지 오는데 거쳐간 노드 개수를 의미
    1.  각 노드에서 다른 노드까지 가는데 거리가 연료통용량*10 보다 작고, 방문한 적이 없다면 방문해도 된다는 것
        1.  연료통용량*10은 기름 1리터당 10km를 갈 수 있기 때문에 해당 기름양으로 갈 수 있는 거리를 의미

    1.  최종적으로는 방문배열을 반환한다

1.  연료통 용량 값은 이분탐색으로 찾는다
    1.  용량값을 bfs함수에 넣어주고 나오는 방문배열을 확인한다
    1.  방문배열의 마지막값 즉, 마지막 노드까지 가는데 거쳐온 노드의 개수를 확인한다
    1.  만약 K보다 작다면 가능하다는 뜻이므로 기름통 용량을 더 줄여본다
    1.  K보다 크다면, 불가능이므로 기름통 용량을 더 늘린다

1.  결과값을 출력한다



#### 💻코드

```python
from collections import deque
import math
N, K = map(int,input().split())

# 거리를 계산하는 함수
def measure_distance(x1,y1,x2,y2):
    return math.ceil(((x2-x1)**2 + (y2-y1)**2)**0.5)

#각 좌표의 위치
arr = [[0,0]]+[list(map(int,input().split())) for _ in range(N)]+[[10000,10000]]

# 각 노드간의 거리 표시
maps = [[0]*(N+2) for _ in range(N+2)]
for i in range(N+2):
    for j in range(N+2):
        maps[i][j] = measure_distance(arr[i][0],arr[i][1],arr[j][0],arr[j][1])

        
def bfs(start,oil):
    visited = [-1]*(N+2)
    queue = deque([start])
    visited[start] = 0

    while queue:
        now = queue.popleft()

        for d in range(N+2):
            # now노드에서 d노드까지 거리가 지금 연료통의 양으로 갈 수 있는지 판단
            if maps[now][d] <= oil*10 and visited[d] == -1:
                # 갈 수 있다면 이전 노드에서 +1 
                visited[d] = visited[now]+1
                queue.append(d)
    return visited


start = 1
end = measure_distance(0,0,10000,10000)
ans = 0
# 이분탐색으로 연료통값 찾기
while start<=end:
    mid = (start+end)//2
    res = bfs(0,mid)[-1]
    # 아예 마지막에 방문할 수 없는 경우
    if res == -1:
        start = mid+1
        
    # 조건에 부합하는 경우 더 작은 값을 찾아보기
    elif res <= K+1:
        ans = mid
        end = mid-1
    
    # K보다 많은 보급횟수라면 기름양 더 늘리기
    else:
        start = mid+1
print(ans)
```



#### ❌ 발생 오류 및 해결

- 처음에 다익스트라로 시도했으나 실패
  - 반례
    - 만약, 1번 노드 - 2번 노드의 거리는 700, 2번 노드 - 3번 노드는 100, 1번 노드 - 3번 노드가 1000인 경우
    - 다익스트라는 무조건 1번 노드 - 2번 노드 - 3번 노드 로 거쳐가게 함
    - 이 경우, 기름통이 1000L라면, 1번 - 3번으로 이동이 가능함에도, 1번-2번-3번으로 이동하게 해서, K값에 따라 정답처리가 달라짐
    - 즉, 기름양이 1000이고 K가 1이면 갈 수 없다고 판단 (1-3으로 이동할 수 있음에도 불가하다고 판단)
  - 즉, 토탈 비용의 최솟값이 아닌 각 구간별 거리의 최솟값을 구해야하므로 다익스트라로는 풀 수 없다는 것
