## 🐌 알고리즘 문제 풀이

### Baekjoon_1922. 네트워크 연결

#### 📒문제

> 도현이는 컴퓨터와 컴퓨터를 모두 연결하는 네트워크를 구축하려 한다. 하지만 아쉽게도 허브가 있지 않아 컴퓨터와 컴퓨터를 직접 연결하여야 한다. 그런데 모두가 자료를 공유하기 위해서는 모든 컴퓨터가 연결이 되어 있어야 한다. (a와 b가 연결이 되어 있다는 말은 a에서 b로의 경로가 존재한다는 것을 의미한다. a에서 b를 연결하는 선이 있고, b와 c를 연결하는 선이 있으면 a와 c는 연결이 되어 있다.)
>
> 그런데 이왕이면 컴퓨터를 연결하는 비용을 최소로 하여야 컴퓨터를 연결하는 비용 외에 다른 곳에 돈을 더 쓸 수 있을 것이다. 이제 각 컴퓨터를 연결하는데 필요한 비용이 주어졌을 때 모든 컴퓨터를 연결하는데 필요한 최소비용을 출력하라. 모든 컴퓨터를 연결할 수 없는 경우는 없다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/1922)



#### :pushpin: 입력 및 출력

- 첫째 줄에 컴퓨터의 수 N (1 ≤ N ≤ 1000)가 주어진다.

  둘째 줄에는 연결할 수 있는 선의 수 M (1 ≤ M ≤ 100,000)가 주어진다.

  셋째 줄부터 M+2번째 줄까지 총 M개의 줄에 각 컴퓨터를 연결하는데 드는 비용이 주어진다. 이 비용의 정보는 세 개의 정수로 주어지는데, 만약에 a b c 가 주어져 있다고 하면 a컴퓨터와 b컴퓨터를 연결하는데 비용이 c (1 ≤ c ≤ 10,000) 만큼 든다는 것을 의미한다. a와 b는 같을 수도 있다.

- 모든 컴퓨터를 연결하는데 필요한 최소비용을 첫째 줄에 출력한다.


---

> 예시

```
input :
6
9
1 2 5
1 3 4
2 3 2
2 4 7
3 4 6
3 5 11
4 5 3
4 6 8
5 6 8

output :
23
```

----




#### 🚀point

1. 최소 신장 트리 (MST) 알고리즘 사용




#### 🔎풀이

1.  N,과 M을 입력 받고 컴퓨터간 연결 정보를 edgs 배열에 삽입한다
    1.  이때, 비용 기준으로 정렬시키도록 cost를 맨 앞에 위치시킨다

1.  각 컴퓨터가 속한 집단을 알기 위해 parents 배열을 생성한다
    1.  parents[n]은 n번 컴퓨터가 어느 집단에 속해있는지 나타낸다
    1.  초기값은 각자 자기 자신을 가리키도록 한다

1.  각자가 속한 집단을 확인할 find_parent 함수와, 두 컴퓨터를 연결시킬 union 함수를 정의한다

1.  연결 정보가 담긴 edges 배열을 정렬시킨다

1.  반복 하면서 각 연결 정보를 확인한다
    1.  만약, a와 b가 아직 연결되지 않았다면(find_parent) 연결시키고(union) 그 때 드는 비용을 더해준다

1.  모든 연결 정보를 순회 완료했다면 최종적으로 든 비용을 출력한다




#### 💻코드

```python
import sys
input = sys.stdin.readline

# x번 컴퓨터가 속한 집단을 알려주는 함수
# 두 컴퓨터가 같은 집단에 속해있다는 것은 어떻게든 서로 연결되어있다는 것
def find_parent(x):
    if parents[x]!=x:
        parents[x] = find_parent(parents[x])
        return parents[x]
    return x

# a,b 컴퓨터를 같은 집단으로 연결시켜주는 함수
def union(a,b):
    a = find_parent(a)
    b = find_parent(b)

    if a>b:
        parents[a] = b
    else:
        parents[b] = a

N = int(input())
M = int(input())

# 초기설정은 자기 자신을 가르키도록
parents = [0]*(N+1)
for i in range(1,N+1):
    parents[i] = i

edges = []
# edges 배열에 모두 넣어준다.
for _ in range(M):
    a,b,cost = map(int,input().split())
    # 이때, cost를 맨 앞에 둬서, 비용 기준으로 정렬할 수 있도록 한다
    edges.append((cost,a,b))

# 최종 결과를 담을 변수
total_cost = 0
# edges 배열을 정렬시킨다
edges.sort()

# 비용이 가장 적게드는 연결정보부터 탐색하기 시작
for edge in edges:
    cost,a,b = edge
	
    # 만약 두 컴퓨터가 이미 연결되어있다면 다음 연결정보 탐색
    if find_parent(a) == find_parent(b):
        continue
    # 아직 연결되어있지 않다면 연결
    else:
        union(a,b)
        total_cost+=cost
print(total_cost)

```



#### ❌ 발생 오류 및 해결

- 

  
