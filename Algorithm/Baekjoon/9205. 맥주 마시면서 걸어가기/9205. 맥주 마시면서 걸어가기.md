## 🐌 알고리즘 문제 풀이

### Baekjoon_9205. 맥주 마시면서 걸어가기

#### 📒문제

> 송도에 사는 상근이와 친구들은 송도에서 열리는 펜타포트 락 페스티벌에 가려고 한다. 올해는 맥주를 마시면서 걸어가기로 했다. 출발은 상근이네 집에서 하고, 맥주 한 박스를 들고 출발한다. 맥주 한 박스에는 맥주가 20개 들어있다. 목이 마르면 안되기 때문에 50미터에 한 병씩 마시려고 한다. 즉, 50미터를 가려면 그 직전에 맥주 한 병을 마셔야 한다.
>
> 상근이의 집에서 페스티벌이 열리는 곳은 매우 먼 거리이다. 따라서, 맥주를 더 구매해야 할 수도 있다. 미리 인터넷으로 조사를 해보니 다행히도 맥주를 파는 편의점이 있다. 편의점에 들렸을 때, 빈 병은 버리고 새 맥주 병을 살 수 있다. 하지만, 박스에 들어있는 맥주는 20병을 넘을 수 없다. 편의점을 나선 직후에도 50미터를 가기 전에 맥주 한 병을 마셔야 한다.
>
> 편의점, 상근이네 집, 펜타포트 락 페스티벌의 좌표가 주어진다. 상근이와 친구들이 행복하게 페스티벌에 도착할 수 있는지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/9205)



#### :pushpin: 입력 및 출력

- 첫째 줄에 테스트 케이스의 개수 t가 주어진다. (t ≤ 50)

  각 테스트 케이스의 첫째 줄에는 맥주를 파는 편의점의 개수 n이 주어진다. (0 ≤ n ≤ 100).

  다음 n+2개 줄에는 상근이네 집, 편의점, 펜타포트 락 페스티벌 좌표가 주어진다. 각 좌표는 두 정수 x와 y로 이루어져 있다. (두 값 모두 미터, -32768 ≤ x, y ≤ 32767)

  송도는 직사각형 모양으로 생긴 도시이다. 두 좌표 사이의 거리는 x 좌표의 차이 + y 좌표의 차이 이다. (맨해튼 거리)

- 각 테스트 케이스에 대해서 상근이와 친구들이 행복하게 페스티벌에 갈 수 있으면 "happy", 중간에 맥주가 바닥나서 더 이동할 수 없으면 "sad"를 출력한다. 


---

> 예시

```
input :
2
2
0 0
1000 0
1000 1000
2000 1000
2
0 0
1000 0
2000 1000
2000 2000

output :
happy
sad
```

----




#### 🚀point

1. 이동이 아닌 경우의 bfs 활용하기
   1. queue에 무엇을 넣어줄 것인가





#### 🔎풀이

1.  입력값을 모두 받는다
    1.  시작점과 도착점은 따로 저장해둔다
    1.  편의점과 도착점은 하나의 배열에 모두 넣어둔다 (시작점 제외)

1.  bfs 함수를 정의한다
    1.  queue에는 좌표만 들어간다
    1.  방문배열을 생성하는데, dfs처럼 각 경로가 각각의 방문배열을 갖는게 아닌 모든 경로에서 공통의 방문배열을 갖는다
        1.  왜냐하면, 도착할 수 있냐 없냐가 중요하지 어떤 경로인지는 중요하지 않음
        1.  즉, 2번 편의점에서 도착점을 갈 수 있다고 할 때, 2번 편의점에 어떻게 가는지는 중요하지 않다는 것
        1.  어떻게든 2번 편의점에 도착했다면 도착점에 갈 수 있음. 더 짧게 간건지 몇번만에 간건지 등 중요하지 않음

    1.  queue에 들어있는 좌표를 하나씩 빼면서 해당 좌표에서 특정 좌표로 갈 수 있는지 확인한다
        1.  우선, 방문 배열에 들어있는 경우 어떻게든 갈 수 있다는 뜻이므로 패스
        1.  방문 배열에 없는 경우 체크
            1.  거리를 측정하고, 50으로 나눈 뒤 올림처리하여 필요한 맥주의 개수를 센다
            1.  맥주 개수가 20개보다 많으면 갈 수 없으므로 패스
            1.  20개보다 적다면, queue와 visited 배열에 넣어준다
                1.  이때, 해당 좌표가 도착점이라면 바로 True를 return해주면서 함수 종료

    1.  모든 좌표를 돌았는데 정답이 없다면 False 반환

1.  bfs 함수 결과에 따라 happy나 sad 출력



#### 💻코드

```python
import sys
input = sys.stdin.readline
from collections import deque
import math

def bfs(start_x,start_y):
    queue = deque([[start_x,start_y]])
    # 모든 경우에서의 방문배열
    # 시작점은 애초에 nodes에 없어서 방문처리 필요 X
    visited = []
    while queue:
        x,y = queue.popleft()
        for node in nodes:
            # 모든 좌표 중 방문한 적 없는 좌표만 확인
            if node not in visited:
                distance = abs(node[0]-x)+abs(node[1]-y)
                beer = math.ceil(distance/50)
                # 필요한 맥주 개수가 20개보다 적거나 같다면
                if beer<=20:
                    # 그중 도착점이라면 함수 종료
                    if node == target:
                        return True
                   	# 아니라면 queue와 visited에 넣어주기
                    queue.append([node[0],node[1]])
                    visited.append([node[0],node[1]])
    return False

T = int(input())
for _ in range(T):
    N = int(input())
    # 시작점
    x,y = map(int,input().split())
    nodes = [list(map(int,input().split())) for _ in range(N+1)]
    target = nodes[-1][:]
    
    if bfs(x,y):
        print("happy")
    else:
        print("sad")
```



#### ❌ 발생 오류 및 해결

- 각 경로별 방문처리를 따로 해줘서 시간초과 발생
