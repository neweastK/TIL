## 🐌 알고리즘 문제 풀이

### Baekjoon_11497. 통나무 건너뛰기

#### 📒문제

> 남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다. 남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11497/1.png)
>
> 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다. 높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다. 배열 [2, 9, 7, 4, 5]의 난이도는 |2-9| = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 |5-9| = 4이다. 이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다.
>
> [<문제 출처>](https://www.acmicpc.net/problem/11497)



#### :pushpin: 입력 및 출력

- 입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다.

  이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 Li가 주어진다. (1 ≤ Li ≤ 100,000)

- 각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오.



---

> 예시

```
input :
3
7
13 10 12 11 10 11 12
5
2 4 5 7 9
8
6 6 6 6 6 6 6 6

output :
1
4
0
```

----




#### 🚀point

1. 하나씩 배열의 값을 보며, 재배치 할 때, 배열의 맨 앞에 삽입해야하는지, 맨 뒤에 삽입해야하는지 결정
1. 맨 앞, 맨 뒤 중 그 바로 옆 수와 차이가 작아야함
1. 이를 쉽게 하기위해 기존 배열을 정렬해야함



#### 🔎풀이

1.  모든 입력값을 받고 배열을 정렬한다
1.  최종 통나무 배열 res를 생성하고, 가장 작은 통나무를 먼저 삽입한다
1.  통나무 하나씩 반환하면서 아래 작업을 반복한다
    1.  통나무를 좌우 한번씩 삽입해준다
    1.  왼쪽에 넣었으면, 다음은 오른쪽, 오른쪽에 넣었으면 다음은 왼쪽
    1.  왜냐하면, 현재 양끝에 있는 통나무들과 차이가 가장 작은 통나무는 맨 앞에 있기 때문
        1.  뒤로 갈 수록, 차이는 더 커지게 될 것
        1.  따라서, 뒤 통나무를 탐색할 필요 없이, 당장있는 통나무를 양쪽에 배치해야함
        1.  왼쪽이냐 오른쪽이냐는 차이가 더 큰 쪽 (뒤 통나무는 차이가 더 클 것이므로)
            1.  but, 이 과정은 필요 없음
            1.  어차피 오른쪽에 먼저 넣었으면 당연히 오른쪽 끝 통나무와의 차이가 더 클 것이고, 왼쪽에 먼저 넣었으면 왼쪽 끝 통나무와의 차이가 클 것이기 때문

    1.  삽입했을 때, 통나무 높이 차이를 구한다

1.  통나무 높이 차의 최댓값을 따로 저장하고 마지막에 출력



#### 💻코드

```python
from collections import deque

T = int(input())

for _ in range(T):
    N = int(input())
    arr = list(map(int,input().split()))
    arr.sort()
    
    # 최종 통나무 배열
    # arr에서 첫번째 값 빼놓기
    res = deque([arr.pop()])
    
    # res 배열 좌우끝에 한번씩 값을 삽입할 예정
    # 지금 방향을 나타내주는 right 변수
    right = True
    
    # 정답을 구하기 위한 옆 나무와의 gap
    max_gap = 0
    while arr:
        # 배치할 통나무
        now = arr.pop()
        
        # 만약 오른쪽이라면 append
        if right :
            res.append(now)
            # 오른쪽에 삽입한 나무와, 그 왼쪽 나무의 높이 차이
            if max_gap < abs(now-res[-2]):
                max_gap = abs(now-res[-2])
        # 왼쪽 차례라면 appendleft
        else:
            res.appendleft(now)
            # 왼쪽에 삽입한 나무와, 그 오른쪽 나무의 높이 차이
            if max_gap < abs(now-res[1]):
                max_gap = abs(now-res[1])
		# 위치 바꿔주기 
        right = not right

    print(max_gap)
```



#### ❌ 발생 오류 및 해결

- 
