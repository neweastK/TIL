## 🐌 알고리즘 문제 풀이

### Baekjoon_2629. 양팔저울

#### 📒문제

> 양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.
>
> 무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.
>
> 구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.
>
> ![img](https://upload.acmicpc.net/ce5b29f5-9e03-473b-97db-ce9fd740fde2/-/preview/)
>
> <그림 1> 구슬이 3g인지 확인하는 방법 (1$\boxed{1}$은 1g인 추, 4$\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)
>
> <그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.
>
> 추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.
>
> ![img](https://upload.acmicpc.net/883fb22a-7516-46e1-937d-2ddc4df94572/-/preview/)
>
> <그림 2> 구슬이 5g인지 확인하는 방법
>
> [<문제 출처>](https://www.acmicpc.net/problem/2629)



#### :pushpin: 입력 및 출력

- 첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.

- 주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.


---

> 예시

```
input :
2
1 4
2
3 2

output :
Y N

input :
4
2 3 3 3
3
1 4 10

output :
Y Y N
```

----




#### 🚀point

1. DP를 활용하여 문제 풀이




#### 🔎풀이

1.  추와 구슬에 관한 정보를 모두 받는다

1.  dp 배열을 생성한다 (구슬 무게의 최댓값인 40000의 길이로 생성)

1.  가장 첫번째 추를 활용해 초기값을 세팅한다

1.  이후, 나머지 DP 배열을 채워준다
    1.  dp[i-1]에서 측정 가능하다고 판단했던 무게에 현재 추의 무게를 더하거나 뺀 값도 측정 가능함
        1.  따라서, 해당 값들도 측정 가능하다고 갱신
        1.  이때, 무게를 빼는 경우 무거운 추에서 가벼운 추를 뺄 수 있도록 할 것

    1.  추가로 현재 추의 무게 단독으로도 측정 가능하기 때문에 해당 무게도 갱신

1.  마지막 배열을 돌면서 입력값으로 주어진 구슬이 무게 측정이 가능한 구슬인지 확인




#### 💻코드

```python
import sys
input = sys.stdin.readline

# 추의 정보
N = int(input())
weights = list(map(int,input().split()))
# 무거운 추부터 내림차순 정렬
weights.sort(reverse=True)

# 구슬의 정보
M = int(input())
marbles = list(map(int,input().split()))

# dp[i][j]는 i번째 추까지 확인했을 때, j무게인지 확인할 수 있는지를 의미
dp = [[0]*40001 for _ in range(N)]
# 초기값 설정
dp[0][weights[0]] = 1

# 나머지 DP 배열 채워주기
for i in range(1,N):
    # 추에 대한 정보 받기
    weight = weights[i]
    # 우선 자기 자신의 무게는 측정 가능하므로 자기 자신을 나타내는 값 갱신
    dp[i][weight] = 1
    
    # 이전 단계에서 가능하다고 판단한 무게들 모두 받아오기
    for j in range(40001):
        if dp[i-1][j] == 1:
			
            # 똑같이 받기
            dp[i][j] = 1
			
            # 해당 무게에서 자기 자신의 무게를 더하거나 뺀 무게도 가능하다고 표기
            if j-weight>=0:
                dp[i][j-weight] = 1
            else:
                dp[i][weight-j] = 1

            if j+weight<=40000:
                dp[i][j+weight] = 1

ans = []
# 구슬을 순회하면서 해당 구슬이 측정 가능한지 판단
for marble in marbles:
    if dp[-1][marble] == 1:
        ans.append("Y")
    else:
        ans.append("N")
print(*ans)
```



#### ❌ 발생 오류 및 해결

- 기존 측정 가능한 무게에서 자기 자신의 값을 뺐을 때, 음수인 경우를 제외함
  - 절댓값으로 구하거나, 무거운 값에서 가벼운 값을 빼도록 했어야함

- 다른 사람 풀이

  - set 활용

    - set을 만들어놓고, set에는 측정 가능한 무게들을 넣어서 저장
    - 매번 해당 set을 순회하면서 set에 현재 추 무게를 더하고 뺸값들도 set에 새로 추가
    - 마지막으로 set에 자기 자신 무게도 추가

    

