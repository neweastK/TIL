## 🐌 알고리즘 문제 풀이

### Baekjoon_2011. 암호코드

#### 📒문제

> 상근이와 선영이가 다른 사람들이 남매간의 대화를 듣는 것을 방지하기 위해서 대화를 서로 암호화 하기로 했다. 그래서 다음과 같은 대화를 했다.
>
> - 상근: 그냥 간단히 암호화 하자. A를 1이라고 하고, B는 2로, 그리고 Z는 26으로 하는거야.
> - 선영: 그럼 안돼. 만약, "BEAN"을 암호화하면 25114가 나오는데, 이걸 다시 글자로 바꾸는 방법은 여러 가지가 있어.
> - 상근: 그렇네. 25114를 다시 영어로 바꾸면, "BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN" 총 6가지가 나오는데, BEAN이 맞는 단어라는건 쉽게 알수 있잖아?
> - 선영: 예가 적절하지 않았네 ㅠㅠ 만약 내가 500자리 글자를 암호화 했다고 해봐. 그 때는 나올 수 있는 해석이 정말 많은데, 그걸 언제 다해봐?
> - 상근: 얼마나 많은데?
> - 선영: 구해보자!
>
> 어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 프로그램을 작성하시오.
>
> [<문제 출처>](https://www.acmicpc.net/problem/2011)



#### :pushpin: 입력 및 출력

- 첫째 줄에 5000자리 이하의 암호가 주어진다. 암호는 숫자로 이루어져 있다.

- 나올 수 있는 해석의 가짓수를 구하시오. 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.

  암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 출력한다.
  



---

> 예시

```
input :
25114
output :
6

input :
1111111111

output :
89

# 질문 검색에서 참고한 반례들
100
답 0

123
답 3

101
답 1

110
답 1

103
답 1

000
답 0

007
답 0

1010
답 1

2220
답 2

2626
답 4

123456789
답 3

9876543210
답 1
```

----




#### 🚀point

1. DP 문제이지만 구현에 더 가까운 느낌
1. 꼼꼼한 예외처리가 필요



#### 🔎풀이

1.  각 자리수에서 해석 가능한 경우의 수를 기록할 dp 배열을 생성한다.
    1.  최대범위가 5000자리 수이므로 길이는 5001개로 지정 (0번째는 제외)

1.  0번째와 1번째 값을 1로 초기화해준다.
1.  기본적으로 적용시킬 점화식을 작성한다.
    1.  이전 자리의 숫자와 이었을 때 26이하 조건에 맞으면 dp[i]는 dp[i-2]+dp[i-1]이다.
    1.  조건에 안맞으면 dp[i] = dp[i-1]
    1.  dp[n]은 n번째 자리까지의 경우의 수를 나타냄 

1.  예외처리할 경우를 모두 작성한다.
    1.  0이 있는 경우
        1.  0이 맨 앞 혹은 연속된다 → 오류
        1.  0이 연속되지 않고 중간에 있는 경우
            1.  앞 숫자와 묶었을 때 26이 넘는다 → 오류
            1.  앞 숫자와 묶었을 때 26을 넘지 않는다 → dp[i] = dp[i-2]

    1.  탐색하는 숫자가 0이 아닌 경우
        1.  앞 숫자가 0이다 → dp[i] = dp[i-1]




#### 💻코드

```python
import sys
input = sys.stdin.readline

N = input().rstrip()

dp = [0]*5001
dp[0] = 1
dp[1] = 1

# 0이 맨 앞이면 무조건 오류
if N[0] == "0" :
    dp[len(N)] = 0
else :
    for i in range(1,len(N)):
        if N[i] == "0" :
            if N[i-1] == "0":
                dp[len(N)] = 0
                break
            else :
                # 앞 숫자와 묶은게 30이상일 경우
                if int(N[i-1]) > 2:
                    dp[len(N)] = 0
                    break
                else :
                    dp[i+1] = dp[i-1]
        else :
            if N[i-1] == "0":
                dp[i+1] = dp[i]
            else:
                if int(N[i-1:i+1]) <= 26:
                    dp[i+1] = dp[i-1]+dp[i]
                else :
                    dp[i+1] = dp[i]
print(dp[len(N)]%1000000)
```



#### ❌ 발생 오류 및 해결

- 0인 경우의 예외처리를 잘못하여 오답 처리
