# 알고리즘 특강

#### 무조건 준비해야되는 알고리즘

1. **재귀호출 기본 (백트래킹)**:
2. **DFS, BFS (그래프 탐색)**  :heavy_check_mark:
3. **Binary Search (Parametric 포함)**
4. **Heap (P.Q)**
5. **Dijkstra(P.Q 만든 것)**  :heavy_check_mark:
6. **플로이드 (암기)**
7. **그리디**
8. **Union-Find ** :heavy_check_mark:
9. **MST** 
10. **Sliding Window**
11. **Hash**
12. **플러드 필**

13. 그 이후
    1. Trie
    2. DP (공부 시간 대비 정답률 즉, 가성비가 좋지 않기 때문에 후순위)
    3. Segment Tree
    4. 부분합, 



#### 코테

- 코테 난이도가 높다 = 서류 뚫기가 쉽다 
- 삼성전자, 하이닉스, 현대자동차, 국민은행, 현대카드, 네이버, 카카오 등의 영업이익은 조 단위
  - but, 스타트업의 경우 1000억대만 돼도 매우 높은 수준이라고 생각하면 됨
- 중수 이상이 될 때, 알고리즘을 잘하는 방법
  - 기출 유형을 분석하며 반복적으로 풀어본다
  - 알고리즘을 하나씩 마스터해간다
  - 고수들의 코드를 리뷰해보며 내것으로 만든다
  - 중수란? 삼성 A형 한문제는 스스로 풀 수 있는 정도
- 그렇다면 초보는?
  - 능숙함을 목표로
    - 쉬운 문제는 보다 능숙하게 풀 수 있어야함
    - 쓸 수 있는 라이브러리의 사용법을 익숙하게 사용할 수 있도록 할 것
    - 파이썬 문법을 구글링하는 일은 없어야함
    - 즉, 쉬운 문제부터 지겹게 풀어라
      - JUNGOL 추천해주심 (Beginner Coder 풀면 될듯? 그것도 어려우면 LCoder_Python 풀것)
      - 완전 기초부터 공부하는 것 X, 능숙도를 올리는 것
  - 목표로 해야하는 수준
    - 너무 반복해서 지겨울 정도로 능숙해질 때 까지
    - 단지, 이해한 것만으로 만족하지 말 것 절대절대 (이건 누구나 금방됨)
    - 중수 이상 되지 않을 때는, 쉬운 문제를 더 우선적으로 많이 풀어야함
    - 추천 공부방법 Daily 과제
      - 매일 쉬운 문제 두 문제씩 (난이도가 쉽던, 어렵던 매일 두 문제씩)
      - 보통 컨디션 : 매일 두 문제
      - 좋은 컨디션 : 많이 풀자
  - 문제 풀다 막히면?
    - 풀이를 보지 말고, 더 쉬운 문제를 풀 것



### DFS(깊이 우선 탐색)

> 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

#### :heavy_check_mark:point!

- 그래프 즉, 노드 간 연결 관계를 표현하는 방법 2가지

  1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
     - n행 m열은 n번 노드와 m번 노드가 연결되어 있는지를 표현하는 것
  2. 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식 
     - 인덱스가 노드의 번호가 됨
     - 노드와 거리를 튜플로 하는 값을 가짐

  - 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적으나 정보를 얻는 시간이 오래 걸림

- 구현 방법에는 두가지가 있음
  1. 재귀함수 이용
  2. stack 이용
- 탐색 시작 노드를 스택에 삽입하며 시작하고, 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리를 한다.
  - 스택이 빈 리스트가 될 때까지 반복


#### :framed_picture:frame code

```python
def dfs(graph, v, visited):
    visited[v] = True
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
            
graph = [ 각 노드의 연결 정보 ]
visited = [False]*N
dfs(graph,시작노드,visited)
```

```python
# 재귀 ver
def recursive_dfs(v, visited=[]):
    visited.append(v)
    for w in graph[v]:
        if w not in visited:
            visited = recursive_dfs(w,visited)
    return visited 
```

```python
# stack ver
def dfs(start_v):
    visited=[]
    stack=[start_v]
    while stack :
        v=stack.pop()
        if v not in visited :
            visited.append(v)
            for w in graph[v]:
                stack.append(w)
    return visited
```



:heavy_exclamation_mark: DFS와 DP를 결합한 경우 (백준 1520번 문제 참고)

- 방문 배열에는 3가지 값 중 하나가 들어간다.
  1. `-`1 : 아직 방문하지 않은 경우
  2. `0` : 방문했으나 목적지에 도착하지 못한 경우
  3. `0이상` : 방문했고, 목적지까지 도착할 수 있는 경우의 수
- 만약, 새로 탐색한 곳의 값이 -1이 아닌 값이라면, 그 위치에서 더 깊이 갈 필요가 없음
  - 이미 가봤기 때문에!
  - 따라서, 지금 위치의 값에서 새로 탐색한 곳의 값을 더해준다면, 지금 위치에서 목적지까지 갈 수 있는 경우의 수를 구하게 되는것!
  - 왜냐하면, 깊이 우선 탐색이기 때문에 이미 가본 위치는 더 이상 탐색할 필요가 없음 (이미 다 탐색을 해봤기 때문에)
- 이 방법으로 시간을 매우 효과적으로 줄일 수 있다.

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)

def dfs(x,y):
    # 목적지일 경우 1 반환
    if x==M-1 and y==N-1 :
        return 1
    
    # 이미 방문한 경우, 그 값을 반환
    # 만약, 목적지로 갈 수 없다면 0일 것
    elif visited[x][y] != -1 :
        return visited[x][y]

    else :
        # 방문 표시
        visited[x][y] = 0
        # 4방향 탐색
        for d in range(4):
            nx = x+dx[d]
            ny = y+dy[d]
            # 만약 새로 이동할 수 있는 곳의 조건을 만족한다면
            if 0<=nx<M and 0<=ny<N and maps[nx][ny] < maps[x][y] :
                # 지금 위치의 값은 다음 위치에서 목적지까지 갈 수 있는 경로의 수를 더한 값
                visited[x][y] += dfs(nx,ny)

        return visited[x][y]

M,N = map(int,input().split())
maps = [list(map(int,input().split())) for _ in range(M)]
visited = [[-1]*N for _ in range(M)]
dx = [0,0,-1,1]
dy = [1,-1,0,0]

print(dfs(0,0))
```





### BFS(너비 우선 탐색)

#### :heavy_check_mark:point!

- queue를 이용한다
  - 선입선출의 자료 구조
- 시간을 줄이기 위해 deque 사용
- 현재 위치에서 조건에 해당하는 모든 위치를 queue에 삽입하고 다시 탐색을 진행한다
  - DFS는 조건에 해당하는 첫번째 위치를 기준으로 다시 탐색 시작
  
  

:heavy_exclamation_mark: 몇번째 순회(탐색)인지 횟수 구하기

- 몇번만에 도착했는지를 알고 싶을 때 어떻게 구할 것인가?

- 구글링해서 찾은 방법

  1. 방문횟수 배열(ex. count)을 새로 만든다.

     - count[nx] = count[x]+1

  2. 위치와 방문횟수를 묶어서 튜플로 만든다.

     - (x, cnt) → queue에 넣어줄 때, (nx, cnt+1) 과 같이 넣어준다.

     

#### :framed_picture:frame code

```python
def BFS():
    # queue 선언 (deque를 사용하기도 함)
    queue = []
    # 방문체크를 위한 배열 생성 (문제에 따라 모양은 달라질 수 있음)
    visited = [ [0]*N for _ in range(M) ] 
    
    # 초기값 설정 (출발 지점 지정 & 방문 체크)
    queue.append([si,sj])
    visited[[si][sj] = 1
    
    while queue :
        # 선입선출인 queue 자료구조를 활용. 따라서, 첫번째 값을 빼줘야함
        ci,cj = queue.pop(0)
        
        for d in range(4):
            ni = ci + dx[d]
            nj = cj + dy[d]
            
            # 조건에 맞는지 체크 (범위를 벗어나는지, 방문했던 적이 있는지, 문제에서 제기한 조건과 맞는지 체크)
            if 0<=ni<N and 0<=nj<M and visited[ni][nj] != 1 and condition :
                queue.append([ni,nj])
                visitied[ni][nj] = 1
```



#### :heavy_plus_sign:deque 사용법

- deque는 queue, stack 모두 구현 가능하다
- 양쪽 끝 모두에서 자료의 삽입과 삭제가 가능

```python
from collections import deque

q1 = deque()
q2 = deque([1,2,3])

## deque 메서드

q1.append(item)
q1.appendleft(item)
q1.pop(item)
q1.popleft(item)
q2.extend(array)
q2.extendleft(array)
q1.remove(item)
q1.clear() # deque의 모든 요소 삭제
q1.rotate(n) # n만큼 회전 (양수 : 시계방향, 음수 : 반시계방향)
q1.reverse() # 제자리에서 반대로 뒤집으며 반환값 없음
q1.insert(i,x) # i위치에 x 삽입
q1.index(x[,start[,stop]]) # x의 위치를 반환
q1.count(x) # x와 같은 값의 개수
```

[공식문서](https://docs.python.org/3/library/collections.html#collections.deque)



### Dijkstra (다익스트라)

#### :heavy_check_mark: point!

- 가장 대표적인 최단 경로 알고리즘
- **특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산**
- 음의 간선이 없을 때 정상적으로 동작
- 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복
- 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾을 수 있음
- 시간 복잡도를 낮추기 위해 우선순위 큐 활용



#### :arrow_forward: 동작 과정

1. 출발 노드 설정
2. 최단 거리 테이블을 초기화
   1. 자기 자신에 대한 노드는 0으로 설정
   2. 초기에는 자기 자신에 대한 노드를 제외한 나머지 노드로 가는 비용을 모두 무한으로 설정
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택 (heapq를 활용)
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5. 위 과정에서 3번, 4번 반복



#### :heavy_plus_sign:우선순위 큐 사용법

- 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
- 힙(Heap) : 우선순위 큐를 구현하기 위해 사용하는 자료구조 
  - 최소힙(Min Heap)과 최대힙(Max Heap)으로 구분 (기본적으로 최소힙으로 동작)
    - 최대힙을 만들고 싶으면 append시 값을 음수로 만들어서 삽입
  - 삽입시간과 삭제시간 모두 O(logN) 만큼의 수행시간 소요

```python
import heapq

heapq.heappush(대상, 삽입할 값)
heapq.heappop(대상) # 가장 작은 원소를 삭제 후 반환
# 삭제 없이 반환을 원한다면 인덱스 사용 
heapq.heapify(대상) # 기존 리스트를 힙으로 변환
# 최대힙 뽑기
nums = [4, 1, 7, 3, 8, 5]
heap = []

for num in nums:
  heapq.heappush(heap, (-num, num))  # (우선 순위, 값)

while heap:
  print(heapq.heappop(heap)[1])  # index 1
```

- 우선순위 큐를 다익스트라에 사용할 때, 거리가 가까워서 값이 갱신된 경우에만 우선순위 큐에 넣어준다.

#### :framed_picture:frame code

```python
import heapq

# n, m == 노드 개수, 간선 개수

# 0번 노드가 없다면 n+1로 설정 (편리성을 위해)
# graph에는 (비용, 목적지)의 튜플이 들어감
# graph[x]에는 x에서 출발하여 v까지 가는데 c만큼 비용이 든다는 정보가 들어있음
graph = [[] for _ in range(n+1)]

# start 노드에서 각 index번 노드까지의 최소 거리
distance = [int(1e9)]*(n+1)

def djikstra(start):
    queue = []
    heapq.heappush(queue,(0,start))
    # start 노드에서 start노드. 즉, 본인까지의 거리는 0
    distance[start] = 0
    
    while queue :
        dist,target = heapq.heappop(queue)
        
        if distance[target] < dist :
            continue
        
        # start노드에서 출발해 target노드를 거쳐 가는 것이 더 짧은지 비교 
        for i in graph[target] :
            cost = dist + i[0]
            if cost < distance[i[1]] :
                distance[i[1]] = cost
                heapq.heappush(queue,(cost,i[0])) 
```

- 왜 굳이 heapq를 써서, 거리가 짧은 것부터 돌리는걸까?
  - 시간복잡도를 줄이기 위함
  - heapq를 쓰지 않으면 노드가 5000개 이상일 경우 시간 초과가 남



### Union-Find(합집합 찾기)

> 서로소 집합(Disjoint-Set) 알고리즘이라고도 부른다.
>
> 여러 개의 노드가 존재할 때 두 개의 노드를 선택해서 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘



#### :heavy_check_mark: point!

- 노드를 합치고(union), 부모를 찾아(find) 서로소 집합을 찾아낸다(disjoint set)

- 초기 배열
  - 인덱스는 몇번 노드인지 나타내고, 값은 부모 노드의 번호를 나타냄
  - 초기값으로는 모두 자기 자신을 부모 노드로 갖도록 한다
- 연결관계가 생겼을 때, 주로 더 작은 값을 부모 노드로 설정해준다.
  - ex) 1번 노드와 2번 노드가 연결되면 부모 노드는 1번
- union find의 핵심은 조상 노드를 찾는 것
  - 그렇게 두개의 노드가 같은 집합에 속하는지 확인하는 것



#### :framed_picture:frame code

```python
# 각 노드의 부모를 가리키는 배열, 초기값은 자기 자신
parent = [0,1,2,3,4]

# 1. 부모 노드를 찾는 함수 (재귀함수)
def find(x):
    if parent[x] != x:
        return find(parent[x])
    else :
        return x
    
# 1-1. 경로 압축으로 시간 복잡도 줄이기
def find_parent(x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x :
        parent[x] = find(parent[x])
        return parent[x]
    else :
        return x

# 2. 두 부모 노드를 합치는 함수 (두 노드를 연결한다)
# 더 작은 번호의 노드를 부모로 삼는다
def union(a,b):
    a = find(a)
    b = find(b)
    if a < b:
        parent[b] = a
    else :
        parent[a] = b
# 여기서 넣어준 값에 find 결과 즉, 최상위 부모로 덮어써도 되는 이유
# - 최종 비교할 때도 find로 비교하면 되기 때문
# - 즉, parent 배열에서 나의 조상 노드를 적어주지 않는 경우도 있음.
# - find 함수로 조상 노드를 찾아가게함

# 3. 같은 집합인지 비교 (A,B가 같은 집합인가?)
if find(A) == find(B):
    print("같음")
else :
    print("다름")
```

