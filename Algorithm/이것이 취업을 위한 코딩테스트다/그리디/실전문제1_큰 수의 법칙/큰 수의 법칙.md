## 🐌 알고리즘 문제 풀이

### 이코테\_그리디_실전문제1. 큰 수의 법칙

#### 📒문제

> 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
> 
> 예를 들어 순서대로 2,4,5,4,6 으로 이루어진 배열이 있을 때, M이 8이고, K가 3이라 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5 인 46이 된다.
>  
>단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 에를 들어 순서대로 3,3,3,4,3으로 이루어진 배열이 있을 때, M이 7이고 K가 2라고 가정하자. 이 경우 두번째 원소에 해당하는 4와 네번째 원소에 해당하는 4를 번갈아 두번씩 더하는 것이가능하다. 결과적으로 4+4+4+4+4+4+4 인 28이 도출된다.
> 
>  배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오
>
> <문제 출처> 이것이 취업을 위한 코딩테스트다 92p

---

> 예시

입력						출력 

5 8 3						46

2 4 5 4 6

----




#### 🚀point

1. 인덱스가 다르면 서로 다른 숫자로 판단한다.

1. 가장 큰 수를 활용해야하며, 모든 숫자를 사용할 필요는 없다.

1. 연속으로만 사용 안하면 되기 때문에 가장 큰 숫자 두개만 필요하다.

   

#### 🔎풀이

1. 가장 큰 값과 두번째로 큰 값을 구한다.
1. M번만큼 더해야하므로 M 만큼 반복한다.
1. 연속으로 더해지는 횟수를 세기 위한 cnt 변수를 추가하고 가장 큰 수를 더할 때마다 cnt에 1을 추가한다.
1. 만약 cnt가 문제에서 주어진 K와 같아지면 두번째로 큰 값을 더해주고 cnt는 0으로 초기화해준다.
1. 숫자를 계속 더해준 res 변수를 출력한다.



#### 💻코드

```python
#가장 큰 수 두개를 구한다.
first = max(nums)
nums.remove(first)
second = max(nums)

res=0 #최종 결과값
cnt=0 #연속으로 더해지는 횟수
for _ in range(M): #M번 더해줘야하므로 M번만큼 반복한다
    if cnt==K : #만약 연속으로 더한 횟수가 K와 같다면 
        res+=second #두번째 수를 더해주고
        cnt=0 #cnt는 0으로 초기화한다
    else : #아직 K번만큼 더해지지 않았다면
        res+=first #첫번째 수를 더해주고
        cnt+=1 #cnt에 1을 더해준다
print(res)

# 반복문 사용 없이 문제 풀기(M이 매우 큰 수일 것을 대비)
# 가장 큰 수 두개는 위와 같이 구함
res=0
set_times = M//(K+1)
others = M&(K+1)
res += (K*first+second)*set_times
res += others*first

print(res)

```



#### ❌ 발생 오류 및 해결

- 

