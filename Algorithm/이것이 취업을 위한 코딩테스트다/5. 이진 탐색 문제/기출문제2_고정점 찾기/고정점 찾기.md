## 🐌 알고리즘 문제 풀이

### 이코테\_이진탐색_기출문제2. 고정점 찾기

#### 📒문제

> 고정점이란, 수열의 원소 중에서 그 값이 인덱스와 동일한 원소를 의미합니다. 예를 들어 수열 a = {-15, -4, 2, 8, 13} 이 있을 때 a[2]=2 이므로, 고정점은 2가 됩니다.
>
> 하나의 수열이 N개의 서로 다른 원소를 포함하고 있으며 ,모든 원소가 오름차순으로 정렬되어 있습니다. 이때, 이 수열에서 고정점이 있다면, 고정점을 출력하는 프로그램을 작성하세요. 고정점은 최대 1개만 존재합니다. 만약 고정점이 없다면 -1을 출력합니다.
>
> 단, 이 문제는 시간 복잡도 O(logN)으로 알고리즘을 설게하지 않으면 '시간초과' 판정을 받습니다.
>
> 
>
> <문제 출처> 이것이 취업을 위한 코딩테스트다 368p



#### :pushpin: 입력 및 출력

##### 입력

- 첫째 줄에 N이 입력됩니다. (1≤N≤1,000,000)

- 둘째 줄에 N개의 원소가 정수 형태로 공백으로 구분되어 입력됩니다.

  (-10^9 ≤ 각 원소의 값 ≤ 10^9)



##### 출력

- 고정점을 출력한다. 고정점이 없다면 -1을 출력합니다.



---

> 예시

1번 입력							  1번 출력 

5										  3

-15  -6  1  3  7 



2번 입력						      2번 출력

7 									     2

-15  -4  2  8  9  13  15



3번 입력						      3번 출력

7 									     -1

-15  -4  3  8  9  13  15

<hr>

#### 🚀point


1. 수열 안에는 같은 숫자가 없다!!
2. 따라서, 탐색 범위를 계속해서 절반으로 줄일 수 있게됨

   1. 만약 index 보다 value가 크다면 더 낮은 인덱스 방향은 탐색할 필요가 없음
   2. 반대도 마찬가지





#### 🔎풀이

1.  이진 탐색을 위해 중간값 확인
1.  중간값이 고정점인지 확인
    1.  중간값의 index보다 중간값이 더 크다면 end를 중간값 이전 index로 지정하여 재탐색
    1.  반대의 경우 중간값 이후 index로 지정하여 재탐색

1.  start가 end를 넘어서는 경우 중지하고 -1 반환




#### 💻코드

```python
def binary_search(arr,start,end) :
    if start > end : # start와 end가 같은 경우에도 한번 더 돌려야함 (start와 end가 겹치는 지점은 확인이 안됐기 때문)
        return -1
    mid = (start+end) // 2
    if arr[mid] == mid : # 고정점 확인
        return mid # 고정점이라면 해당 index 반환
    elif arr[mid] > mid : # index보다 value가 크다면
        return binary_search(arr,start,mid-1) # 해당 index 이전의 배열만 탐색
    else :
        return binary_search(arr,mid+1,end) # 해당 index 이후의 배열만 탐색

N = int(input())
numbers = list(map(int,input().split()))
res = binary_search(numbers, 0, N-1)
print(res)
```



#### ❌ 발생 오류 및 해결

- 이진탐색 함수의 정지 조건을 `start>=end` 로 했을 때 오류가 났다.
  - start와 end가 겹치는 부분은 확인이 되지 않고 종료되기 때문에 해당 부분이 고정점인 경우 오답 출력

