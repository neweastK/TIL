## 🐌 알고리즘 문제 풀이

### 이코테\_그리디_기출문제2. 곱하기 혹은 더하기

#### 📒문제

> 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'X' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요.
>
> 단, +보다 X를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정하빈다.
>
> 예를 들어, 02984라는 문자열이 주어지면, 만들어질 수 있는 가장 큰 수는((((0+2)x9)x8)x4) = 576 입니다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.
>
> <문제 출처> 이것이 취업을 위한 코딩테스트다 312p



#### :pushpin: 입력 및 출력

##### 입력

- 첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다. (1 ≤ S의 길이 ≤ 20)

  

##### 출력

- 첫째 줄에 만들어질 수 있는 가장 큰 수를 출력합니다.

---

> 예시

1번 입력				1번 출력 

02984					576

2번 입력				2번 출력 

567						210

----




#### 🚀point

1. 0과 1이면 더해주는 것이 최선의 방법
2. 0과 1을 제외한 나머지 수는 모두 곱해주는 것이 최선의 방법 
2. 


#### 🔎풀이

1. 문자열을 반복하면서 각각의 숫자를 받고 정수형으로 바꿔준다

1. ~~0 혹은 1일 경우, 그리고 아닌 경우를 기준으로 분기를 나눠준다.~~

1. ~~0과 1일 경우 덧셈, 아닐 경우 곱셈 과정을 진행~~

1. 이전 숫자 그리고 다음 숫자에 따른 조건을 각각 지정해줘야해서 더 복잡해짐

   - 현재 상황에서 최적의 해가 무엇인가? 만을 고려하기 어려워진 상황

   - 더했을 때, 그리고 곱했을 때를 비교해서 더 큰거로 선택한다.
   - 어차피 덧셈과 곱셈의 순서는 입력순이므로 뒤에 곱하기가 나온다 하더라도 결과값이 달라지지 않는다



#### 💻코드

```python
res=int(nums[0])

for num in nums[1:]:
    sum_value = res+int(num) # 더해줬을 때
    times_value = res*int(num) # 곱해줬을 때
    res = sum_value if sum_value>times_value else times_value # 더 큰 값을 res로 넣고 다시 반복
print(res)
```



#### ❌ 발생 오류 및 해결

- 0이 첫번째 숫자로 올 때의 문제
  - 첫번째 숫자 뿐 아니라 뒤에 올 때도 문제 (if 문에서는 이전 값에만 조건을 걸어줬기 때문)
  - 더욱 복잡해질 것을 우려하여 로직 변경
