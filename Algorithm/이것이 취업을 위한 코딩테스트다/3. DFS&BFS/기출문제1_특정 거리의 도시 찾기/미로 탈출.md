## 🐌 알고리즘 문제 풀이

### 이코테\_DFS/BFS_실전문제2. 미로 탈출

#### 📒문제

> 동빈이는 N x M 크기의 직사각형 형태의 미로에 갇혀 있다. 미로에는 여러 마리의 괴물이 있어 이를 피해 탈출해야한다. 동빈이의 위치는 (1,1)이고 미로의 출구는 (N,M)의 위치에 존재하며 한번에 한칸씩 이동할 수 있다. 이때 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있다. 미로는 반드시 탈출할 수 있는 형태로 제시된다. 이때 동빈이가 탈출하기 위해 움직여야하는 최소 칸의 개수를 구하시오. 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산한다.
>
> <문제 출처> 이것이 취업을 위한 코딩테스트다 152p



#### :pushpin: 입력 및 출력

##### 입력

- 첫번째 줄에 두 정수 N,M(4 ≤ N, M ≤ 200)이 주어진다. 

- 다음 N개의 줄에는 각각 M개의 정수(0 혹은 1)로 미로의 정보가 주어진다. 각각의 수들은 공백 없이 붙어서 입력으로 제시된다. 또한 시작 칸과 마지막 칸은 항상 1이다.

  

##### 출력

- 첫째 줄에 최소 이동 칸의 개수를 출력한다.

---

> 예시

입력				출력 

5 6					10
101010
111111
000001
111111
111111

<hr>
#### 🚀point

1. 문제에서 위치를 나타내는 수들은 index와 다르기 때문에 1씩 빼서 생각해야한다!

   ex) 시작 위치 (1,1) = 배열에서의 (0,0)

2. 노드 간의 거리가 같고 최소 이동거리를 구하는 방법 = bfs

   1. 인접한 노드들을 모두 이동한 거리를 나타내는 수로 바꿔준다.
   2. 함수를 한바퀴 돌 때마다 1씩 증가시켜야한다.





#### 🔎풀이

1. 입력값으로 배열부터 만든다

1. 1인 곳만 탐색해가는 bfs를 생성한다.

1. 인접한 구간의 값이 1일 경우 이전 값의 1을 더해준 값을 넣어줌으로써 한번 이동할 때마다 1씩 증가가 되도록 한다.

1. 목표지점에 도달한 경우 그 전의 값을 반환한다.

   1. 맨 처음에 값을 2로 넣었기 때문 (1로 했을 경우 두번째 위치에서 시작점을 다시 탐색하게 되기 때문)

   

#### 💻코드

```python
from collections import deque

# 네방향 탐색을 위한 델타
delta = [(0,1),(0,-1),(1,0),(-1,0)]

def bfs(start):
    queue = deque([start]) # 시작점은 0,0 이다
    arr[start[0]][start[1]] = 2 # 시작점의 값을 2로 넣는다. 1로 넣을 경우 두번째 위치에서 탐색할 때 돌아오게 되기 때문
    while queue :
        now = queue.popleft() # 현재 위치를 queue에서 빼주고 탐색을 시작한다
        for d in delta: 
            nx = now[0]+d[0]
            ny = now[1]+d[1]

            if (nx,ny)== (N-1, M-1) : # 만약 새로운 위치가 목적지라면 탐색하고 있는 기준 위치의 값을 반환하면서 함수를 끝낸다.
                return arr[now[0]][now[1]]
			
            # 새로운 위치가 범위에 속하고, 1이라면 즉, 괴물이 없다면
            if 0<=nx<N and 0<=ny<M and arr[nx][ny] == 1:
                queue.append((nx,ny)) # 이동할 수 있으므로 queue에 넣어준다.
                arr[nx][ny] = arr[now[0]][now[1]]+1 # 이전 값에 1을 더해줌으로써 몇번째 이동중인지 값을 나타내도록 한다.

N,M = map(int,input().split())

arr = [list(map(int,input())) for _ in range(N)]
ans = bfs((0,0))
print(ans)
```



#### ❌ 발생 오류 및 해결

- 
