## 🐌 알고리즘 문제 풀이

### 이코테\_DFS/BFS_실전문제1. 음료수 얼려 먹기

#### 📒문제

> N x M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상,하,좌,우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 다음의 4 x 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다.
>
> <문제 출처> 이것이 취업을 위한 코딩테스트다 149p



#### :pushpin: 입력 및 출력

##### 입력

- 첫번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 ≤ N, M ≤ 1,000)
- 두번째 줄부터 N+1 번째 줄까지 얼음 틀의 형태가 주어진다.
- 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

##### 출력

- 한번에 만들 수 있는 아이스크림의 개수를 출력한다.

---

> 예시

입력				출력 

4 5			  	3
00110
00011
11111
00000

15 14								8
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111

<hr>


#### 🚀point

1. bfs 혹은 dfs를 활용해본다
2. 해당 함수가 한번 돌 때마다 cnt를 1씩 증가시킨다
3. 즉, 'bfs가 몇번 실행됐는가' 가 본 문제에서 원하는 답




#### 🔎풀이

1. 상하좌우를 탐색하기 위한 delta 리스트를 만들어준다
1. 이어져있는 얼음틀을 탐색하기 위한 bfs 함수를 선언한다.
   1. 해당 위치에서 4방향 탐색
   1. 새로운 위치가 이어져있다면 queue에 삽입 + 방문처리
   1. 더 이상 이어져있지 않다면 종료

1. 더 이상 bfs 탐색을 시작할 수 없다면 종료 및 cnt 반환



#### 💻코드

```python
from collections import deque

delta = [(0,1),(0,-1),(1,0),(-1,0)] #네방향 탐색을 위한 델타

def bfs(start):
    queue = deque([start]) #시작점을 deque에 넣어준다
    while queue : #queue가 빈 리스트가 될 때까지
        now = queue.popleft() #현재 위치를 뽑아주고
        for d in delta : #네방향 탐색을 실시한다
            nx = now[0]+d[0]
            ny = now[1]+d[1]
			
            #새로 탐색한 곳이 범위 안에 있고, 아직 미방문한 구멍이 뚫려있는 얼음틀이라면
            if 0<=nx<N and 0<=ny<M and ice_form[nx][ny] == 0 :
                queue.append((nx,ny)) #queue에 넣어준다 (다음에 그 위치를 기준으로 또 탐색하기위해)
                ice_form[nx][ny] = 1 #방문처리를 해준다

N,M = map(int,input().split())
ice_form = [list(map(int,input())) for _ in range(N)]
cnt=0
for i in range(N):
    for j in range(M):
        if ice_form[i][j] == 0 : #구멍이 뚫려있을 때만 bfs 함수를 돌린다
            bfs((i,j)) 
            cnt +=1 #bfs 함수가 끝나면 cnt를 1씩 증가시킨다.

print(cnt)
```



#### ❌ 발생 오류 및 해결

- deque 선언에서 계속 오류가 났다. 인자를 리스트로 감싸주는 것을 모르고 있었어서 x,y 좌표가 동시에 전달되지 않았다.
