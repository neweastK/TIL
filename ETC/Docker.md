# Docker

> 컨테이너 기반 가상화 도구
>
> - 어플리케이션을 패키징 할 수 있는 Tool
>   - 컨테이너라는 하나의 작은 소프트웨어 유닛 안에 어플리케이션과 필요한 시스템 툴, 디펜던시를 모두 하나로 묶어서 다른 서버, 다른PC 그 어떤 곳에도 쉽게 배포하고 안정적으로 구동할 수 있게 도와주는 Tool
>   - 어플리케이션을 구동하는데 필요한 모든 것들을 도커 컨테이너 안에 담아놓는 것
> - 

### 가상화란?

> 하나의 서버 자원을 나눠서 갖며 성능을 분산 시키고, 분산된 서버들은 각기 다른 서비스를 수행할 수 있게 함
>
> 가상화를 통해 사용자가 많은 서비스에는 많은 자원을 할당해주고 적은 서비스에는 적게 할당시켜줌



##### 서버 가상화

> 하나의 물리적 서버 호스트에서 여러 개의 서버 운영 체제를 게스트로 실행할 수 있게 해주는 소프트웨어 아키텍처

- 하이퍼바이저
  - 서버 가상화 기술을 구현할 수 있게하는 소프트웨어
  - 하나의 호스트에 생성된 여러 개의 운영체제는 가상 머신이라는 단위로 구별 됨
  - 각 가상 머신에는 여러 운영체제가 설치되고 하이퍼바이저에 의해 생성되고 관리되는 운영체제를 게스트 운영체제라고 부름
  - 각 게스트 운영체제는 다른 게스트 운영체제와는 완전히 독립된 공간과 시스템 자원을 할당받아 사용
  - 대표적인 가상화 툴 VirtualBox, VMware 등이 있음
- 완벽한 운영체제를 만들 수 있다는 장점은 있으나, 성능이 느리고 용량이 큼
  - 예를 들면, 맥이라는 운영체제 위에서 윈도우, 리눅스 등을 이용할 수 있음 but 운영체제 자체가 너무 무거움




##### 컨테이너 기반 가상화

> 가상화된 공간을 생성하기 위해 프로세스 단위의 격리 환경을 만듦

- 컨테이너 안에는 애플리케이션을 구동하는데 필요한 랑브러리 및 실행 파일만 존재
- 따라서, 이미지의 용량이 줄어든다
- 도커는 컨테이너 기술에 여러 기능을 추가한 오픈소스 프로젝트
- 컨테이너
  - 임지의 목적에 따라 생성도는 프로세스 단위의 격리 환경
  - 컨테이너는 환경을 제공하며 프로세스의 생명주기를 관리
- 컨테이너가 구동되기 위해서는 컨테이너 엔진이 필요하고 이 컨테이너 엔진이 Host Os에 접근해서 필요한 것들을 처리해 줌
  - 컨테이너 엔진 중 가장 많이 이용되고 있는 것이 도커

- 컨테이너는 프로세스를 격리된 환경에서 관리하는데 이 때 격리된 환경은 Host OS를 의미하고 이를 통해 컨테이너에 어떤 설정을 하든 Host OS에 영향을 미치지 않음. 즉, 우리만의 독립된 개발 환경을 보장받을 수 있다는 것!
  - 이를 통해 프로세스를 컨테이너 단위로 바라 볼 수 있게되고, 프로세스의 관리 및 확장이 매우 용이해짐



#### 도커엔진

- 유저가 컨테이너를 쉽게 사용할 수 있게 해주는 주체

##### 도커엔진의 flow

1. 사용자가 docker 명령어 입력
2. 이를 전달받은 docker 클라이언트는 유닉스 소켓(var/run/docker.sock에 위치)을 통해 도커 데몬의 API를 호출
3. 도커 데몬은 명령어에 해당하는 작업을 수행 후 결과를 도커 클라이언트에게 반환하고 사용자에게 출력
   - 도커 데몬 : 도커 프로세스가 실행되어 입력 받을 준비가 된 상태
4. docerd는 컨테이너를 생성하고 실행하며 이미지를 관리하는 주체



### 도커의 3대 요소

#### 도커파일

> 컨테이너를 어떻게 만들어야하는지에 대한 설명서

- 어플리케이션을 구동하기 위해 필요한 파일들, 외부 디펜던시, 필요한 환경변수, 구동 방법에 대한 스크립트를 포함



#### 이미지

> 어플리케이션을 실행하는데 필요한 모든 세팅들이 포함 되어있음 (도커파일 포함)

- 애플리케이션의 순간을 캡처해서 박제해놓은 듯한 느낌

  - ex) node 이미지는 리눅스에 Node.js가 설치된 상태를 캡처해서 클라우드에 올려놓은 것

- 만들어진 이미지는 변경이 불가능함

- 객체 지향 언어로 비유하면 클래스와 같은 느낌

  - 클래스를 이용하여 인스턴스를 만들고, 인스턴스에 변경이 가해져도 클래스에는 영향이 없다.
  - 여러 인스턴스를 생성할 수 있다.
    - 즉, 이미지는 컨테이너를 찍어내는 틀

  

#### 컨테이너

> 어플리케이션의 이미지를 고립된 환경에서 실행할 수 있는 것

- 이미지를 이용해서 어플리케이션을 구동함
- 클래스의 인스턴스와 같음



#### 도커의 배포 == 이미지 공유

- 로컬 머신에서 이미지를 만들고 컨테이너 레지스트리에 PUSH
- 필요한 서버나 다른 개발자 PC에서 이미지를 가져와서 사용
  - 서버와 PC 모두에 반드시 도커가 설치되어있어야 함
- 컨테이너 레지스트리 프로그램
  - public
    - 도커 허브
    - 깃허브 패키지
  - private
    - 구글 클라우드
    - AWS
    - MS Azure
- 총 과정
  1. 도커 파일 생성 및 이미지 생성
  2. 로컬에서 컨테이너 레지스트리에 PUSH
  3. 서버에서 이미지 PULL
  4. 컨테이너 생성





## 실습

### 도커 파일 생성

- 파일명 : Dockerfile (확장자 X)

- 처음에는 베이스이미지를 등록

  - 어떤 베이스이미지를 등록할 것인가?

  ```dockerfile
  FROM BaseImage 
  ## 노드의 경우 등록되어 있음 
  ## FROM node:16-alpine
  ## 16은 노드의 버전, alpine은 최소한의 리눅스 (다 설정 가능)
  ```

- WORKDIR

  - 어떤 디렉토리에 애플리케이션을 복사해올 것인가?

  ```dockerfile
  WORKDIR /app
  
  ## app이라는 폴더 안에 프로젝트에 관련된 모든 파일들을 copy해오겠다는 뜻
  ```

- COPY

  - 어떤 파일들을 복사해올 것인가?
  - 빈번히 변경되는 파일일 수록 가장 마지막에 명시해주는 것이 좋음
    - 가장 마지막에 명시한 레이어(파일)를 가장 먼저 수정하기 때문에 이미지를 생성할 때 효율성이 좋음

  ```dockerfile
  COPY package.json package-lock.json
  ```

- RUN

  - 실행할 명령어

  ```dockerfile
  RUN npm install	
  # node에서는 install보다 npm ci 를 사용하는 것이 좋음
  ## ci는 package-lock.json 을 기준으로 설치하게 되기 때문
  # package.json vs package-lock.json
  ## package.json 은 최신버전이 있을 경우 최신버전을 설치하게 됨.
  ## 따라서, 개발 당시의 버전과 맞지 않을 가능성 존재
  ## package-lock.json 은 개발했을 당시의 정확한 버전을 기준으로 설치함
  ```

- CMD

  - 컨테이너 실행시 실행할 명령어

    ```dockerfile
    CMD ["http-server","-p","8080","./public"]
    ```

    - RUN은 이미지 생성 과정에서 실행할 명령어로 이미지에서 컨테이너를 실행하는 시점에서는 이미 실행되어있을 명령어들
    - CMD는 이미지로부터 컨테이너가 만들어져 가동될 때 바로 실행되는 명령어

- ENV

  - 환경변수 설정

  - 보안과 관련된 내용은 따로 처리가 필요함

    ```BASH
    # ENV 예시
    ENV MYSQL_DATABASE visitlog
    ```

    

- 빌드

  ```bash
  docker build -f Dockerfile -t fun-docker .
  ```

  - 가장 마지막 `.` : 도커가 실행하는데 필요한 파일(ex. dockerfile)의 위치(현재 위치 기준)
  - `-f` : 어떤 dockerfile을 사용할 것인지 명시 (파일명이 Dockerfile이 아닐 수도 있기 때문)
  - `-t` : 도커 이미지에 부여할 이름

  ```bash
  docker images
  ```

  - 로컬 머신에 만들어진 이미지들 확인 가능

  

- 이미지로 컨테이너 실행하기

  ```bash
  docker run -d -p 8080:8080 dockername
  ```

  - `-d` : detached를 의미. 명령어를 수행하고 다른 작업을 수행할 수 있도록. 즉, 컨테이너가 백그라운드에서 실행되도록 설정하는 옵션
  - `-p` : 포트 지정. 호스트 머신의 포트와 컨테이너 포트를 연결해주는 작업
  - `--name` : 컨테이너 이름 지정

  - run 명령어는 해당 이미지가 없을 경우 도커 허브로부터 해당 이미지를 다운받은 다음 컨테이너로 생성

    ```bash
    docker run -it 컨테이너명
    ```

    - 컨테이너를 연 다음 그 환경 안에서 CLI를 사용한다는 것

  

  ```bash
  docker ps
  ```

  - 현재 실행되고 있는 컨테이너들 확인 가능

    - `docker ps -a` 의 경우 작업이 중단된 컨테이너들도 확인 가능

  - 컨테이너 안으로 들어가기

    ```bash
    docker exec -it 컨테이너명 bash
    ```

    



- 배포

  - 도커 허브 사용 (계정 생성 필요)

    1. 레포지토리 생성

    2. 레포지토리 이름과 이미지 이름을 동일하게 지정해야함

       1. 이미지 이름 변경이 필요한 경우

          ```bash
          docker tag old_name:tagname new_name
          ```

    3. 로그인

       ```bash
       docker login
       ```

    4. PUSH

       ```bash
       docker push 계정명/이미지이름
       ```

       
